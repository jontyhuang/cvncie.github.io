<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>datawhale数据竞赛组队学习-task05模型融合</title>
    <url>/jontyhuang.github.io/2020/01/14/datawhale%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0-task05%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h1><p>顾名思义，模型融合就是综合考虑不同模型的情况，并将它们的结果融合到一起。</p>
<h2 id="1、Voting"><a href="#1、Voting" class="headerlink" title="1、Voting"></a>1、Voting</h2><p>Voting即投票机制，分为软投票和硬投票两种，其原理采用少数服从多数的思想。</p>
<p>硬投票：对多个模型直接进行投票，最终投票数最多的类为最终被预测的类。</p>
<p>软投票：和硬投票原理相同，增加了设置权重的功能，可以为不同模型设置不同权重，进而区别模型不同的重要度。</p>
<p>备注：此方法用于解决分类问题。</p>
<h2 id="2、Average"><a href="#2、Average" class="headerlink" title="2、Average"></a>2、Average</h2><p>Averaging，其原理是对模型结果取平均。</p>
<p>处理回归问题，直接取平均值作为最终的预测值。（也可以使用加权平均）</p>
<p>平均法存在问题就是如果不同回归方法的预测结果波动幅度相差比较大，那么波动小的回归结果在融合时候起的作用就比较小。</p>
<h2 id="3、Ranking"><a href="#3、Ranking" class="headerlink" title="3、Ranking"></a>3、Ranking</h2><p>Ranking的思想和Averaging一致，但是因为上述平均法存在一定的问题。</p>
<p>所以这里采用了把排名做平均，如果有权重，则求n个模型权重比排名之和，即为最后的结果。</p>
<h2 id="4、Bagging"><a href="#4、Bagging" class="headerlink" title="4、Bagging"></a>4、Bagging</h2><p>Bagging方法的出现，可以完美地解决了决策树过拟合的问题，同时bagging的使用也会使分类器分类效果得到了显著的提高。</p>
<p>应用场景：对不稳定的分类器做Bagging是一个好主意。在机器学习中，如果训练数据的一个小变化导致学习中的分类器的大变化，则该算法（或学习算法）被认为是不稳定的。</p>
<p>Bagging就是采用有放回的方式进行抽样，用抽样的样本建立子模型,对子模型进行训练，这个过程重复多次，最后进行融合。大概分为两步：</p>
<ul>
<li><p>1.重复K次</p>
<ul>
<li>有放回地重复抽样建模 </li>
<li>训练子模型</li>
</ul>
</li>
<li><p>2.模型融合</p>
<ul>
<li>模型融合，如果是分类问题用voting解决 。如果是回归问题用average解决。</li>
</ul>
</li>
</ul>
<p>注意：在bagging集成中，各个模型的预测不会彼此依赖。Bagging算法不用我们自己实现，随机森林就是基于Bagging算法的一个典型例子，采用的基分类器是决策树。可以直接调用。</p>
<h2 id="5、Boosting"><a href="#5、Boosting" class="headerlink" title="5、Boosting"></a>5、Boosting</h2><p>Boosting的思想是一种迭代的方法，它每次训练使用的都是同一个训练集。但是每次它会给这些分类错误的样例增加更大的权重，下一次迭代的目标就是能够更容易辨别出上一轮分类错误的样例。最终将这些弱分类器进行加权相加。</p>
<p>注意：Boosting下一次的迭代必须在上一次的基础上。</p>
<p>同样地，基于Boosting思想的有AdaBoost、GBDT等，也可以直接调用。</p>
<h2 id="6、Stacking"><a href="#6、Stacking" class="headerlink" title="6、Stacking"></a>6、Stacking</h2><p>stacking是一种分层模型集成框架。以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为训练集进行再训练，从而得到完整的stacking模型。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200114213656.png" alt=""></p>
<p>stacking两层模型都使用了全部的训练数据。</p>
<p>n个训练样本，m个测试样本。</p>
<p>第一层模型：</p>
<p>首先数据有训练集和测试集两部分</p>
<p>1、对训练集进行五折交叉验证，把训练集划分为A，B两部分</p>
<p>2、对A部分进行训练，对B部分进行预测，得到a1，五折后则为a1，a2，a3，a4，a5，对他们合并，形成n行一列的数据</p>
<p>3、对测试集进行预测，会得到b1，b2，b3，b4，b5，将各部分相加取平均得到m行一列的数据</p>
<p>4、以上是一个模型，如果有三个模型，则可以得到A1,A2,A3,B1,B2,B3</p>
<p>5、在此之后，我们把A1,A2,A3并列合并得到一个n行三列的矩阵作为training data，B1,B2,B3并列合并得到一个m行三列的矩阵作为testing data。让下一层的模型，基于他们进一步训练。</p>
<h2 id="7、Blending"><a href="#7、Blending" class="headerlink" title="7、Blending"></a>7、Blending</h2><p>Bending是一种模型融合方法，对于一般的Blending，主要思路是把原始的训练集先分成两部分，比如70%的数据作为新的训练集，剩下30%的数据作为测试集。第一层我们在这70%的数据上训练多个模型，然后去预测那30%数据的label和test的label。在第二层里，我们就直接用这30%数据在第一层预测的结果做为新特征继续训练即可。</p>
<p>Blending的优点在于：</p>
<ul>
<li><p>1.比stacking简单（因为不用进行k次的交叉验证来获得stacker feature）</p>
</li>
<li><p>2.避开了一个信息泄露问题：generlizers和stacker使用了不一样的数据集</p>
</li>
</ul>
<p>而缺点在于：</p>
<ul>
<li><p>1.使用了很少的数据（第二阶段的blender只使用training set10%的量）</p>
</li>
<li><p>2.blender可能会过拟合</p>
</li>
<li><p>3.stacking使用多次的交叉验证会比较稳健</p>
</li>
</ul>
<p>对于实践中的结果而言，stacking和blending的效果是差不多的，所以使用哪种方法都没什么所谓，完全取决于个人爱好。</p>
<h1 id="Stacking实现代码"><a href="#Stacking实现代码" class="headerlink" title="Stacking实现代码"></a>Stacking实现代码</h1><p>对训练集进行五折交叉验证的stacking，同时进行三次stacking。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="comment"># 训练集的 feature 特征矩阵  label</span></span><br><span class="line"><span class="comment"># test 测试集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stacking</span></span><br><span class="line"><span class="keyword">import</span>  lightgbm <span class="keyword">as</span> lgb</span><br><span class="line">    folds = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">2333</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="string">"===================================第一轮========================================================"</span></span><br><span class="line">    y_pre_list = []</span><br><span class="line">    r2_list = []</span><br><span class="line">    train_feat = pd.Series()</span><br><span class="line">    <span class="keyword">for</span> fold_, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(folds.split(feature.values, label)):</span><br><span class="line">        print(<span class="string">"fold &#123;&#125;"</span>.format(fold_))</span><br><span class="line">        trn_data = lgb.Dataset(feature.iloc[trn_idx], label[trn_idx], categorical_feature=categorical_feats)  <span class="comment"># 训练集</span></span><br><span class="line">        val_data = lgb.Dataset(feature.iloc[val_idx], label[val_idx], categorical_feature=categorical_feats)   <span class="comment"># 测试集</span></span><br><span class="line"></span><br><span class="line">        num_round = <span class="number">10000</span></span><br><span class="line">        clf = lgb.train(params, trn_data, num_round,valid_sets=[trn_data, val_data], verbose_eval=<span class="number">500</span>,</span><br><span class="line">                    early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">        y_pre = clf.predict(feature.iloc[val_idx], num_iteration=clf.best_iteration)</span><br><span class="line">        r2 = r2_score(y_pre,label[val_idx])</span><br><span class="line">        r2_list.append(r2)</span><br><span class="line">        train_feat = train_feat.append(pd.Series(y_pre,index=val_idx))</span><br><span class="line">        y_pre_test = clf.predict(test,num_iteration=clf.best_iteration)</span><br><span class="line">        y_pre_list.append(y_pre_test)</span><br><span class="line">    print(<span class="string">'r2 score&#123;:&#125;'</span>.format(r2))</span><br><span class="line">    print(<span class="string">'r2:&#123;:&#125;'</span>.format(np.mean(r2_list)))</span><br><span class="line"></span><br><span class="line">    y_pred_final=  (y_pre_list[<span class="number">0</span>]+y_pre_list[<span class="number">1</span>]+y_pre_list[<span class="number">2</span>]+y_pre_list[<span class="number">3</span>]+y_pre_list[<span class="number">4</span>])/<span class="number">5</span></span><br><span class="line">    feature[<span class="string">'pre'</span>] = train_feat</span><br><span class="line">    test[<span class="string">'pre'</span>] = y_pred_final</span><br><span class="line">    <span class="string">"===================================第二轮========================================================"</span></span><br><span class="line">    y_pre_list = []</span><br><span class="line">    r2_list = []</span><br><span class="line">    train_feat = pd.Series()</span><br><span class="line">    <span class="keyword">for</span> fold_, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(folds.split(feature.values, label)):</span><br><span class="line">        print(<span class="string">"fold &#123;&#125;"</span>.format(fold_))</span><br><span class="line">        trn_data = lgb.Dataset(feature.iloc[trn_idx], label[trn_idx], categorical_feature=categorical_feats)</span><br><span class="line">        val_data = lgb.Dataset(feature.iloc[val_idx], label[val_idx], categorical_feature=categorical_feats)</span><br><span class="line"></span><br><span class="line">        num_round = <span class="number">10000</span></span><br><span class="line">        clf = lgb.train(params, trn_data, num_round, feval=get_r2_metric,valid_sets=[trn_data, val_data], verbose_eval=<span class="number">500</span>,</span><br><span class="line">                    early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">        y_pre = clf.predict(feature.iloc[val_idx], num_iteration=clf.best_iteration)</span><br><span class="line">        r2 = r2_score(y_pre,label[val_idx])</span><br><span class="line">        r2_list.append(r2)</span><br><span class="line">        train_feat = train_feat.append(pd.Series(y_pre,index=val_idx))</span><br><span class="line">        y_pre_test = clf.predict(test,num_iteration=clf.best_iteration)</span><br><span class="line">        y_pre_list.append(y_pre_test)</span><br><span class="line">    print(<span class="string">'r2 score&#123;:&#125;'</span>.format(r2))</span><br><span class="line">    print(<span class="string">'r2:&#123;:&#125;'</span>.format(np.mean(r2_list)))</span><br><span class="line">    </span><br><span class="line">    y_pred_final=  (y_pre_list[<span class="number">0</span>]+y_pre_list[<span class="number">1</span>]+y_pre_list[<span class="number">2</span>]+y_pre_list[<span class="number">3</span>]+y_pre_list[<span class="number">4</span>])/<span class="number">5</span></span><br><span class="line">    feature[<span class="string">'pre_2'</span>] = train_feat</span><br><span class="line">    test[<span class="string">'pre_2'</span>] = y_pred_final</span><br><span class="line">    <span class="string">"=======================第三轮========================================================"</span></span><br><span class="line">    y_pre_list = []</span><br><span class="line">    r2_list = []</span><br><span class="line">    train_feat = pd.Series()</span><br><span class="line">    <span class="keyword">for</span> fold_, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(folds.split(feature.values, label)):</span><br><span class="line">        print(<span class="string">"fold &#123;&#125;"</span>.format(fold_))</span><br><span class="line">        trn_data = lgb.Dataset(feature.iloc[trn_idx], label[trn_idx], categorical_feature=categorical_feats)</span><br><span class="line">        val_data = lgb.Dataset(feature.iloc[val_idx], label[val_idx], categorical_feature=categorical_feats)</span><br><span class="line"></span><br><span class="line">        num_round = <span class="number">10000</span></span><br><span class="line">        clf = lgb.train(params, trn_data, num_round, feval=get_r2_metric,valid_sets=[trn_data, val_data], verbose_eval=<span class="number">500</span>,</span><br><span class="line">                    early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">        y_pre = clf.predict(feature.iloc[val_idx], num_iteration=clf.best_iteration)</span><br><span class="line">        r2 = r2_score(y_pre,label[val_idx])</span><br><span class="line">        r2_list.append(r2)</span><br><span class="line">        train_feat = train_feat.append(pd.Series(y_pre,index=val_idx))</span><br><span class="line">        y_pre_test = clf.predict(test,num_iteration=clf.best_iteration)</span><br><span class="line">        y_pre_list.append(y_pre_test)</span><br><span class="line">    print(<span class="string">'r2 score&#123;:&#125;'</span>.format(r2))</span><br><span class="line">    print(<span class="string">'r2:&#123;:&#125;'</span>.format(np.mean(r2_list)))</span><br><span class="line">    </span><br><span class="line">    y_pred_final=  (y_pre_list[<span class="number">0</span>]+y_pre_list[<span class="number">1</span>]+y_pre_list[<span class="number">2</span>]+y_pre_list[<span class="number">3</span>]+y_pre_list[<span class="number">4</span>])/<span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y_pred_final</span><br></pre></td></tr></table></figure>

<h1 id="Blending实现代码"><a href="#Blending实现代码" class="headerlink" title="Blending实现代码"></a>Blending实现代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blend</span><span class="params">(train,test,target)</span>:</span></span><br><span class="line">    <span class="string">'''5折'''</span></span><br><span class="line">    <span class="comment"># n_flods = 5</span></span><br><span class="line">    <span class="comment"># skf = list(StratifiedKFold(y, n_folds=n_flods))</span></span><br><span class="line">    <span class="string">'''切分训练数据集为d1,d2两部分'''</span></span><br><span class="line">    X_d1, X_d2, y_d1, y_d2 = train_test_split(train, target, test_size=<span class="number">0.5</span>, random_state=<span class="number">914</span>)</span><br><span class="line"></span><br><span class="line">    train_ = np.zeros((X_d2.shape[<span class="number">0</span>],len(clfs*<span class="number">3</span>)))</span><br><span class="line">    test_ = np.zeros((test.shape[<span class="number">0</span>],len(clfs*<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j,clf <span class="keyword">in</span> enumerate(clfs):</span><br><span class="line">        <span class="string">'''依次训练各个单模型'''</span></span><br><span class="line">        <span class="comment"># print(j, clf)</span></span><br><span class="line">        <span class="string">'''使用第1个部分作为预测，第2部分来训练模型，获得其预测的输出作为第2部分的新特征。'''</span></span><br><span class="line">        <span class="comment"># X_train, y_train, X_test, y_test = X[train], y[train], X[test], y[test]</span></span><br><span class="line">        X_d1fillna=X_d1.fillna(<span class="number">0</span>)</span><br><span class="line">        X_d2fillna = X_d2.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        X_predictfillna= test.fillna(<span class="number">0</span>)  <span class="comment"># 训练集的数据</span></span><br><span class="line"></span><br><span class="line">        clf.fit(X_d1fillna,y_d1)</span><br><span class="line">        y_submission = clf.predict(X_d2fillna)</span><br><span class="line">        y_test_submission = clf.predict(X_predictfillna)</span><br><span class="line"></span><br><span class="line">        train_[:,j*<span class="number">3</span>] = y_submission*y_submission</span><br><span class="line">        <span class="string">'''对于训练集分出的测试集，直接用这k个模型的预测值作为新的特征。'''</span></span><br><span class="line">        test_[:, j*<span class="number">3</span>] = y_test_submission*y_test_submission</span><br><span class="line">        <span class="comment"># 计算归一化的特征</span></span><br><span class="line">        train_[:, j+<span class="number">1</span>] =(y_submission - y_submission.min()) /(y_submission.max() - y_submission.min())</span><br><span class="line">        <span class="string">'''对于测试集，直接用这k个模型的预测值作为新的特征。'''</span></span><br><span class="line">        y_test_submission = (y_test_submission - y_test_submission.min()) / \</span><br><span class="line">                            (y_test_submission.max() - y_test_submission.min())</span><br><span class="line">        test_[:, j+<span class="number">1</span>] = y_test_submission</span><br><span class="line">        <span class="comment"># 计算log平滑后的特征</span></span><br><span class="line">        train_[:, j+<span class="number">2</span>] = np.log(y_submission)</span><br><span class="line">        <span class="string">'''对于测试集，直接用这k个模型的预测值作为新的特征。'''</span></span><br><span class="line">        y_test_submission =np.log(y_test_submission)</span><br><span class="line">        test_[:, j+<span class="number">2</span>] = y_test_submission</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print("val auc Score: %f" % r2_score(y_predict, dataset_d2[:, j]))</span></span><br><span class="line">        print(<span class="string">'已完成第'</span>,j)</span><br><span class="line"></span><br><span class="line">    train_.to_csv(<span class="string">'./input/train_blending.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    test_.to_csv(<span class="string">'./input/test_blending.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h1 id="stacking代码"><a href="#stacking代码" class="headerlink" title="stacking代码"></a>stacking代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以python自带的鸢尾花数据集为例</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X, y = iris.data[:, <span class="number">1</span>:<span class="number">3</span>], iris.target</span><br><span class="line"></span><br><span class="line">clf1 = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">clf2 = RandomForestClassifier(random_state=<span class="number">1</span>)</span><br><span class="line">clf3 = GaussianNB()</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">sclf = StackingClassifier(classifiers=[clf1, clf2, clf3], </span><br><span class="line">                          meta_classifier=lr)</span><br><span class="line"></span><br><span class="line">label = [<span class="string">'KNN'</span>, <span class="string">'Random Forest'</span>, <span class="string">'Naive Bayes'</span>, <span class="string">'Stacking Classifier'</span>]</span><br><span class="line">clf_list = [clf1, clf2, clf3, sclf]</span><br><span class="line">    </span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">grid = itertools.product([<span class="number">0</span>,<span class="number">1</span>],repeat=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">clf_cv_mean = []</span><br><span class="line">clf_cv_std = []</span><br><span class="line"><span class="keyword">for</span> clf, label, grd <span class="keyword">in</span> zip(clf_list, label, grid):</span><br><span class="line">        </span><br><span class="line">    scores = cross_val_score(clf, X, y, cv=<span class="number">3</span>, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">    print(<span class="string">"Accuracy: %.2f (+/- %.2f) [%s]"</span> %(scores.mean(), scores.std(), label))</span><br><span class="line">    clf_cv_mean.append(scores.mean())</span><br><span class="line">    clf_cv_std.append(scores.std())</span><br><span class="line">        </span><br><span class="line">    clf.fit(X, y)</span><br><span class="line">    ax = plt.subplot(gs[grd[<span class="number">0</span>], grd[<span class="number">1</span>]])</span><br><span class="line">    fig = plot_decision_regions(X=X, y=y, clf=clf)</span><br><span class="line">    plt.title(label)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200115184854.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>datawhale数据竞赛组队学习-task04模型选择</title>
    <url>/jontyhuang.github.io/2020/01/12/datawhale%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0-task04%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<a id="more"></a>

<p>我们以ligthGBM为例</p>
<h1 id="lightGBM"><a href="#lightGBM" class="headerlink" title="lightGBM"></a>lightGBM</h1><p><a href="https://www.jianshu.com/p/3daf08229d78" target="_blank" rel="noopener">lightGBM原理</a></p>
<p><a href="https://lightgbm.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">ligthGBM官方文档</a></p>
<h1 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h1><p><a href="https://lightgbm.readthedocs.io/en/latest/Parameters.html" target="_blank" rel="noopener">lightGBM参数</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lgb_params</span><span class="params">(space)</span>:</span></span><br><span class="line">    lgb_params = dict()</span><br><span class="line">    lgb_params[<span class="string">'boosting_type'</span>] = space[<span class="string">'boosting_type'</span>] <span class="keyword">if</span> <span class="string">'boosting_type'</span> <span class="keyword">in</span> space <span class="keyword">else</span> <span class="string">'gbdt'</span>  <span class="comment"># 未指定使用梯度提升决策树</span></span><br><span class="line">    lgb_params[<span class="string">'objective'</span>] = <span class="string">'regression'</span>  <span class="comment"># L2回归类型</span></span><br><span class="line">    lgb_params[<span class="string">'metric'</span>] = <span class="string">'rmse'</span>  <span class="comment"># 评估指标</span></span><br><span class="line">    lgb_params[<span class="string">'learning_rate'</span>] = space[<span class="string">'learning_rate'</span>]</span><br><span class="line">    lgb_params[<span class="string">'num_leaves'</span>] = int(space[<span class="string">'num_leaves'</span>])   <span class="comment"># 叶子数</span></span><br><span class="line">    lgb_params[<span class="string">'min_data_in_leaf'</span>] = int(space[<span class="string">'min_data_in_leaf'</span>])  <span class="comment"># 一个叶子上的最小数据量，防止生长为较深的树</span></span><br><span class="line">    lgb_params[<span class="string">'min_sum_hessian_in_leaf'</span>] = space[<span class="string">'min_sum_hessian_in_leaf'</span>]  <span class="comment"># 一个叶子的最小海塞矩阵之和</span></span><br><span class="line">    lgb_params[<span class="string">'max_depth'</span>] = <span class="number">-1</span>  <span class="comment"># 不指定最大深度</span></span><br><span class="line">    lgb_params[<span class="string">'lambda_l1'</span>] = space[<span class="string">'lambda_l1'</span>] <span class="keyword">if</span> <span class="string">'lambda_l1'</span> <span class="keyword">in</span> space <span class="keyword">else</span> <span class="number">0.0</span>   <span class="comment"># 正则项</span></span><br><span class="line">    lgb_params[<span class="string">'lambda_l2'</span>] = space[<span class="string">'lambda_l2'</span>] <span class="keyword">if</span> <span class="string">'lambda_l2'</span> <span class="keyword">in</span> space <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line">    lgb_params[<span class="string">'max_bin'</span>] = int(space[<span class="string">'max_bin'</span>]) <span class="keyword">if</span> <span class="string">'max_bin'</span> <span class="keyword">in</span> space <span class="keyword">else</span> <span class="number">256</span> <span class="comment">#   存储特征的最大箱数</span></span><br><span class="line">    lgb_params[<span class="string">'feature_fraction'</span>] = space[<span class="string">'feature_fraction'</span>]  <span class="comment"># 随机抽取特征的比例</span></span><br><span class="line">    lgb_params[<span class="string">'bagging_fraction'</span>] = space[<span class="string">'bagging_fraction'</span>]  <span class="comment"># 在不进行重采样的情况下随机选择部分数据的比例</span></span><br><span class="line">    lgb_params[<span class="string">'bagging_freq'</span>] = int(space[<span class="string">'bagging_freq'</span>]) <span class="keyword">if</span> <span class="string">'bagging_freq'</span> <span class="keyword">in</span> space <span class="keyword">else</span> <span class="number">1</span>   <span class="comment"># bagging的频率，k意味着每k次迭代执行bagging</span></span><br><span class="line">    lgb_params[<span class="string">'nthread'</span>] = <span class="number">4</span>  <span class="comment">#线程数</span></span><br><span class="line">    <span class="keyword">return</span> lgb_params</span><br></pre></td></tr></table></figure>

<h1 id="运用LightGBM"><a href="#运用LightGBM" class="headerlink" title="运用LightGBM"></a>运用LightGBM</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objective</span><span class="params">(space)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> obj_call_count, cur_best_score</span><br><span class="line"></span><br><span class="line">    obj_call_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\nLightGBM objective call #&#123;&#125; cur_best_score=&#123;:7.5f&#125;'</span>.format(obj_call_count,cur_best_score) )</span><br><span class="line"></span><br><span class="line">    lgb_params = get_lgb_params(space)  <span class="comment"># 读取参数</span></span><br><span class="line"></span><br><span class="line">    sorted_params = sorted(space.items(), key=<span class="keyword">lambda</span> z: z[<span class="number">0</span>])</span><br><span class="line">    params_str = str.join(<span class="string">' '</span>, [<span class="string">'&#123;&#125;=&#123;&#125;'</span>.format(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted_params])</span><br><span class="line">    print(<span class="string">'Params: &#123;&#125;'</span>.format(params_str) )</span><br><span class="line">    </span><br><span class="line">    kf = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    out_of_fold = np.zeros(len(X_train))</span><br><span class="line">    <span class="keyword">for</span> fold, (train_idx, val_idx) <span class="keyword">in</span> enumerate(kf.split(X_train)):</span><br><span class="line">        D_train = lgb.Dataset(X_train.iloc[train_idx], label=Y_train[train_idx])</span><br><span class="line">        D_val = lgb.Dataset(X_train.iloc[val_idx], label=Y_train[val_idx])</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        num_round = <span class="number">10000</span></span><br><span class="line">        clf = lgb.train(lgb_params,</span><br><span class="line">                           D_train,</span><br><span class="line">                           num_boost_round=num_round,</span><br><span class="line">                           <span class="comment"># metrics='mlogloss',</span></span><br><span class="line">                           valid_sets=D_val,</span><br><span class="line">                           <span class="comment"># valid_names='val',</span></span><br><span class="line">                           <span class="comment"># fobj=None,</span></span><br><span class="line">                           <span class="comment"># feval=None,</span></span><br><span class="line">                           <span class="comment"># init_model=None,</span></span><br><span class="line">                           <span class="comment"># feature_name='auto',</span></span><br><span class="line">                           <span class="comment"># categorical_feature='auto',</span></span><br><span class="line">                           early_stopping_rounds=<span class="number">200</span>,</span><br><span class="line">                           <span class="comment"># evals_result=None,</span></span><br><span class="line">                           verbose_eval=<span class="literal">False</span>,</span><br><span class="line">                           <span class="comment"># learning_rates=None,</span></span><br><span class="line">                           <span class="comment"># keep_training_booster=False,</span></span><br><span class="line">                           <span class="comment"># callbacks=None</span></span><br><span class="line">                           )</span><br><span class="line">        <span class="comment"># predict</span></span><br><span class="line">        nb_trees = clf.best_iteration  <span class="comment"># 选择指定模型的最佳迭代</span></span><br><span class="line">        val_loss = clf.best_score[<span class="string">'valid_0'</span>]</span><br><span class="line">        print(<span class="string">'nb_trees=&#123;&#125; val_loss=&#123;&#125;'</span>.format(nb_trees, val_loss))</span><br><span class="line">        out_of_fold[val_idx] = clf.predict(X_train.iloc[val_idx], num_iteration=nb_trees)</span><br><span class="line">        score = r2_score(out_of_fold, Y_train)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'val_r2_score=&#123;&#125;'</span>.format(score))</span><br><span class="line"></span><br><span class="line">    log_writer.write(<span class="string">'score=&#123;&#125; Params:&#123;&#125; nb_trees=&#123;&#125;\n'</span>.format(score, params_str, nb_trees ))</span><br><span class="line">    log_writer.flush()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> score&gt;cur_best_score:</span><br><span class="line">        cur_best_score = score</span><br><span class="line">        print(colorama.Fore.GREEN + <span class="string">'NEW BEST SCORE=&#123;&#125;'</span>.format(cur_best_score) + colorama.Fore.RESET)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'loss'</span>: -score, <span class="string">'status'</span>: STATUS_OK&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贝叶斯自动调参"><a href="#贝叶斯自动调参" class="headerlink" title="贝叶斯自动调参"></a>贝叶斯自动调参</h1><p><a href="https://www.jianshu.com/p/35eed1567463" target="_blank" rel="noopener">hyperopt简单使用</a></p>
<p><a href="https://github.com/FontTian/hyperopt-doc-zh/wiki/FMin">hyperopt中文文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">space =&#123;</span><br><span class="line">        <span class="string">'num_leaves'</span>: hp.quniform (<span class="string">'num_leaves'</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">'min_data_in_leaf'</span>:  hp.quniform (<span class="string">'min_data_in_leaf'</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">'feature_fraction'</span>: hp.uniform(<span class="string">'feature_fraction'</span>, <span class="number">0.75</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">'bagging_fraction'</span>: hp.uniform(<span class="string">'bagging_fraction'</span>, <span class="number">0.75</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">'learning_rate'</span>: hp.uniform(<span class="string">'learning_rate'</span>, <span class="number">0</span>, <span class="number">0.01</span>),</span><br><span class="line"><span class="comment">#         'learning_rate': hp.loguniform('learning_rate', -5.0, -2.3),</span></span><br><span class="line">        <span class="string">'min_sum_hessian_in_leaf'</span>: hp.loguniform(<span class="string">'min_sum_hessian_in_leaf'</span>, <span class="number">0</span>, <span class="number">2.3</span>),</span><br><span class="line">        <span class="string">'max_bin'</span>: hp.quniform (<span class="string">'max_bin'</span>, <span class="number">88</span>, <span class="number">200</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">'bagging_freq'</span>: hp.quniform (<span class="string">'bagging_freq'</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">'lambda_l1'</span>: hp.uniform(<span class="string">'lambda_l1'</span>, <span class="number">0</span>, <span class="number">10</span> ),</span><br><span class="line">        <span class="string">'lambda_l2'</span>: hp.uniform(<span class="string">'lambda_l2'</span>, <span class="number">0</span>, <span class="number">10</span> ),</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">trials = Trials()</span><br><span class="line">best = hyperopt.fmin(fn=objective,</span><br><span class="line">                     space=space,</span><br><span class="line">                     algo=HYPEROPT_ALGO,</span><br><span class="line">                     max_evals=N_HYPEROPT_PROBES,</span><br><span class="line">                     trials=trials,</span><br><span class="line">                     verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><p><a href="https://www.jianshu.com/p/7467e616f227" target="_blank" rel="noopener">XGBoost原理</a></p>
<p><a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" target="_blank" rel="noopener">官方地址</a></p>
]]></content>
      <categories>
        <category>basic learning of data competition</category>
      </categories>
  </entry>
  <entry>
    <title>datawhale数据竞赛组队学习-task03 特征工程</title>
    <url>/jontyhuang.github.io/2020/01/10/datawhale%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0-task03-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/%E5%AF%BC%E5%9B%BE1.jpg" alt=""></p>
<a id="more"></a>

<h1 id="特征合并"><a href="#特征合并" class="headerlink" title="特征合并"></a>特征合并</h1><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>根据area和room的图像对rentType的特征值“未知方式”进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">rent_data =  data_train[data_train[<span class="string">'rentType'</span>] != <span class="string">"未知方式"</span>]</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 解决中文显示问题-设置字体为黑体</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span> <span class="comment"># 解决保存图像是负号’-‘显示为方块的问题</span></span><br><span class="line">plt.figure(figsize=(<span class="number">9</span>,<span class="number">6</span>))</span><br><span class="line">sns.lmplot(<span class="string">'area'</span>,<span class="string">'Room'</span>,hue=<span class="string">'rentType'</span>,data=rent_data)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<p>由上述代码可得：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200110212238.png" alt=""></p>
<p>同时画出bathroom和area的关系图</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200111213656.png" alt=""></p>
<p>根据这个我们可以大概知道合租和整租的线性范围，由此可对“未知方式”进行判断。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 填充租房类型</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'Room'</span>] &lt;= <span class="number">1</span>), <span class="string">'rentType'</span>] = <span class="string">'整租'</span>  <span class="comment"># 将房间数小于1记为整租</span></span><br><span class="line">    <span class="comment"># print(data.loc[(data['rentType']=='未知方式')&amp;(data['Room_Bath']&gt;1),'rentType'])</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'Room_Bath'</span>] &gt; <span class="number">1</span>), <span class="string">'rentType'</span>] = <span class="string">'合租'</span>   <span class="comment"># 房间数和浴室比大于1</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'Room'</span>] &gt; <span class="number">1</span>) &amp; (data[<span class="string">'area'</span>] &lt; <span class="number">50</span>), <span class="string">'rentType'</span>] = <span class="string">'合租'</span>  <span class="comment"># 房间数大于1，面积小于50</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] / data[<span class="string">'Room'</span>] &lt; <span class="number">20</span>), <span class="string">'rentType'</span>] = <span class="string">'合租'</span>   <span class="comment"># 每个房间的面积小于20，则为合租</span></span><br><span class="line">    <span class="comment"># data.loc[(data['rentType']=='未知方式')&amp;(data['area']&gt;60),'rentType']='合租'</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] &lt;= <span class="number">50</span>) &amp; (data[<span class="string">'Room'</span>] == <span class="number">2</span>), <span class="string">'rentType'</span>] = <span class="string">'合租'</span>  <span class="comment"># 两个房间，总面积小于50</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] &gt; <span class="number">60</span>) &amp; (data[<span class="string">'Room'</span>] == <span class="number">2</span>), <span class="string">'rentType'</span>] = <span class="string">'整租'</span> <span class="comment"># 两个房间，总面积大于60</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] &lt;= <span class="number">60</span>) &amp; (data[<span class="string">'Room'</span>] == <span class="number">3</span>), <span class="string">'rentType'</span>] = <span class="string">'合租'</span>   <span class="comment">#三个房间，总面积小于60</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] &gt; <span class="number">60</span>) &amp; (data[<span class="string">'Room'</span>] == <span class="number">3</span>), <span class="string">'rentType'</span>] = <span class="string">'整租'</span>   <span class="comment"># 三个房间，总面积大于60</span></span><br><span class="line">    data.loc[(data[<span class="string">'rentType'</span>] == <span class="string">'未知方式'</span>) &amp; (data[<span class="string">'area'</span>] &gt;= <span class="number">100</span>) &amp; (data[<span class="string">'Room'</span>] &gt; <span class="number">3</span>), <span class="string">'rentType'</span>] = <span class="string">'整租'</span>    <span class="comment"># 三个房间，总面积大于100</span></span><br></pre></td></tr></table></figure>

<p>下面的代码是对特征进行合并（相同属性之间进行合并）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并部分配套设施特征</span></span><br><span class="line">    <span class="comment"># 合并交通</span></span><br><span class="line">    data[<span class="string">'trainsportNum'</span>] = <span class="number">5</span> * data[<span class="string">'subwayStationNum'</span>] / data[<span class="string">'subwayStationNum'</span>].mean() + data[<span class="string">'busStationNum'</span>] / \</span><br><span class="line">                                                                                             data[<span class="string">'busStationNum'</span>].mean()</span><br><span class="line">    <span class="comment"># 合并学校</span></span><br><span class="line">    data[<span class="string">'all_SchoolNum'</span>] = <span class="number">2</span> * data[<span class="string">'interSchoolNum'</span>] / data[<span class="string">'interSchoolNum'</span>].mean() + data[<span class="string">'schoolNum'</span>] / data[</span><br><span class="line">        <span class="string">'schoolNum'</span>].mean() \</span><br><span class="line">                            + data[<span class="string">'privateSchoolNum'</span>] / data[<span class="string">'privateSchoolNum'</span>].mean()</span><br><span class="line">    <span class="comment">#合并医院，同时医院比药店更重要</span></span><br><span class="line">    data[<span class="string">'all_hospitalNum'</span>] = <span class="number">2</span> * data[<span class="string">'hospitalNum'</span>] / data[<span class="string">'hospitalNum'</span>].mean() + \</span><br><span class="line">                              data[<span class="string">'drugStoreNum'</span>] / data[<span class="string">'drugStoreNum'</span>].mean()</span><br><span class="line">    <span class="comment"># 合并商场</span></span><br><span class="line">    data[<span class="string">'all_mall'</span>] = data[<span class="string">'mallNum'</span>] / data[<span class="string">'mallNum'</span>].mean() + \</span><br><span class="line">                       data[<span class="string">'superMarketNum'</span>] / data[<span class="string">'superMarketNum'</span>].mean()</span><br><span class="line">    data[<span class="string">'otherNum'</span>] = data[<span class="string">'gymNum'</span>] / data[<span class="string">'gymNum'</span>].mean() + data[<span class="string">'bankNum'</span>] / data[<span class="string">'bankNum'</span>].mean() + \</span><br><span class="line">                       data[<span class="string">'shopNum'</span>] / data[<span class="string">'shopNum'</span>].mean() + <span class="number">2</span> * data[<span class="string">'parkNum'</span>] / data[<span class="string">'parkNum'</span>].mean()</span><br><span class="line"></span><br><span class="line">    data.drop([<span class="string">'subwayStationNum'</span>, <span class="string">'busStationNum'</span>,</span><br><span class="line">               <span class="string">'interSchoolNum'</span>, <span class="string">'schoolNum'</span>, <span class="string">'privateSchoolNum'</span>,</span><br><span class="line">               <span class="string">'hospitalNum'</span>, <span class="string">'drugStoreNum'</span>, <span class="string">'mallNum'</span>, <span class="string">'superMarketNum'</span>, <span class="string">'gymNum'</span>, <span class="string">'bankNum'</span>, <span class="string">'shopNum'</span>, <span class="string">'parkNum'</span>],</span><br><span class="line">              axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h1 id="2、特征选择"><a href="#2、特征选择" class="headerlink" title="2、特征选择"></a>2、特征选择</h1><p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p>
<ul>
<li>特征是否发散:如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li>
<li>特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</li>
</ul>
<p>根据特征选择的形式又可以将特征选择方法分为3种：</p>
<ul>
<li><p>Filter:过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p>
</li>
<li><p>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</p>
</li>
<li><p>Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</p>
</li>
</ul>
<p>　　我们使用sklearn中的feature_selection库来进行特征选择。</p>
<h2 id="2-1、Filter"><a href="#2-1、Filter" class="headerlink" title="2.1、Filter"></a>2.1、Filter</h2><h3 id="2-1-1、方差选择法"><a href="#2-1-1、方差选择法" class="headerlink" title="2.1.1、方差选择法"></a>2.1.1、方差选择法</h3><p>使用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。使用feature_selection库的VarianceThreshold类来选择特征的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line">Variance = VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(train)</span><br><span class="line">print(len(pd.DataFrame(Variance).columns))</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、相关系数法"><a href="#2-1-2、相关系数法" class="headerlink" title="2.1.2、相关系数法"></a>2.1.2、相关系数法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相关系数法特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"></span><br><span class="line">print(<span class="string">"训练集数据"</span>,train.shape)</span><br><span class="line">target_train= target_data</span><br><span class="line">sk=SelectKBest(k=<span class="number">150</span>)   <span class="comment"># 使用default classification function :f_classif,也可以自定义</span></span><br><span class="line">new_train=sk.fit_transform(train,target_train)   <span class="comment"># 拟合数据</span></span><br><span class="line">print(<span class="string">"拟合数据,选取最优的150"</span>,new_train.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对应列索引</span></span><br><span class="line">select_columns=sk.get_support(indices = <span class="literal">True</span>)</span><br><span class="line">print(select_columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对应列名</span></span><br><span class="line"><span class="comment"># print(test.columns[select_columns])</span></span><br><span class="line">select_columns_name=test.columns[select_columns]</span><br><span class="line">new_test=test[select_columns_name]</span><br><span class="line">print(new_test.shape)</span><br><span class="line"><span class="comment"># Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso=Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso.fit(new_train,target_train)</span><br><span class="line"><span class="comment">#预测测试集和训练集结果</span></span><br><span class="line">y_pred_train=lasso.predict(new_train)</span><br><span class="line"></span><br><span class="line">y_pred_test=lasso.predict(new_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对比结果</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">score_train=r2_score(y_pred_train,target_train)</span><br><span class="line">print(<span class="string">"训练集结果："</span>,score_train)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-卡方检验"><a href="#2-1-3-卡方检验" class="headerlink" title="2.1.3 卡方检验"></a>2.1.3 卡方检验</h3><p>经典的卡方检验是检验定性自变量对定性因变量的相关性。假设自变量有N种取值，因变量有M种取值，考虑自变量等于i且因变量等于j的样本频数的观察值与期望的差距，构建统计量：  $X^2=\sum\frac{(A-E)^2}{E}$</p>
<p><a href="http://wiki.mbalib.com/wiki/卡方检验" target="_blank" rel="noopener">这个统计量的含义简而言之就是自变量对因变量的相关性</a>。用feature_selection库的SelectKBest类结合卡方检验来选择特征的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"> </span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据</span></span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(train, target_train)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4、互信息法"><a href="#2-1-4、互信息法" class="headerlink" title="2.1.4、互信息法"></a>2.1.4、互信息法</h3><p>经典的互信息也是评价定性自变量对定性因变量的相关性的，互信息计算公式如下：</p>
<p>$I(X;Y) = \sum_{x\in X}\sum_{y\in X}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}$</p>
<p>为了处理定量数据，最大信息系数法被提出，使用feature_selection库的SelectKBest类结合最大信息系数法来选择特征的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于MINE的设计不是函数式的，定义mic方法将其为函数式的，返回一个二元组，二元组的第2项设置成固定的P值0.5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mic</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    m = MINE()</span><br><span class="line">    m.compute_score(x, y)</span><br><span class="line">    <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择K个最好的特征，返回特征选择后的数据</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(train, target_train)</span><br></pre></td></tr></table></figure>

<h2 id="2-2、Wrapper"><a href="#2-2、Wrapper" class="headerlink" title="2.2、Wrapper"></a>2.2、Wrapper</h2><p>递归消除特征法使用一个基模型来进行多轮训练，每轮训练后，消除若干权值系数的特征，再基于新的特征集进行下一轮训练。使用feature_selection库的RFE类来选择特征的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Wrapper 特征选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">rfe = RFE(lr, n_features_to_select=<span class="number">160</span>)</span><br><span class="line">rfe.fit(train,target_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RFE(estimator=LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None,</span></span><br><span class="line"><span class="comment">#                                normalize=False),</span></span><br><span class="line"><span class="comment">#     n_features_to_select=40, step=1, verbose=0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(rfe.support_)</span><br><span class="line">select_columns = [f <span class="keyword">for</span> f, s <span class="keyword">in</span> zip(train.columns, rfe.support_) <span class="keyword">if</span> s]</span><br><span class="line">print(len(select_columns))</span><br><span class="line">new_train = train[select_columns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso=Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso.fit(new_train,target_train)</span><br><span class="line"><span class="comment">#预测测试集和训练集结果</span></span><br><span class="line">y_pred_train=lasso.predict(new_train)</span><br><span class="line"></span><br><span class="line">y_pred_test=lasso.predict(new_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对比结果</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">score_train=r2_score(y_pred_train,target_train)</span><br><span class="line">print(<span class="string">"训练集结果："</span>,score_train)</span><br></pre></td></tr></table></figure>

<h2 id="2-3、Embedded"><a href="#2-3、Embedded" class="headerlink" title="2.3、Embedded"></a>2.3、Embedded</h2><h3 id="2-3-1-基于惩罚项的特征选择法"><a href="#2-3-1-基于惩罚项的特征选择法" class="headerlink" title="2.3.1 基于惩罚项的特征选择法"></a>2.3.1 基于惩罚项的特征选择法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Embedded</span></span><br><span class="line"><span class="comment"># 基于惩罚项的特征选择法</span></span><br><span class="line"><span class="comment"># Lasso(l1)和Ridge(l2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"></span><br><span class="line">ridge = Ridge(alpha=<span class="number">5</span>)</span><br><span class="line">ridge.fit(train,target_train)</span><br><span class="line"></span><br><span class="line">Ridge(alpha=<span class="number">5</span>, copy_X=<span class="literal">True</span>, fit_intercept=<span class="literal">True</span>, max_iter=<span class="literal">None</span>, normalize=<span class="literal">False</span>,</span><br><span class="line">      random_state=<span class="literal">None</span>, solver=<span class="string">'auto'</span>, tol=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征系数排序</span></span><br><span class="line">coefSort = ridge.coef_.argsort()</span><br><span class="line">print(coefSort)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征系数</span></span><br><span class="line">featureCoefSore=ridge.coef_[coefSort]</span><br><span class="line">print(featureCoefSore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select_columns = [f <span class="keyword">for</span> f, s <span class="keyword">in</span> zip(train.columns, featureCoefSore) <span class="keyword">if</span> abs(s)&gt; <span class="number">0.0000005</span> ] </span><br><span class="line"><span class="comment"># 选择绝对值大于0.0000005的特征</span></span><br><span class="line"></span><br><span class="line">new_train = train[select_columns]</span><br><span class="line">new_test = test[select_columns]</span><br><span class="line"><span class="comment"># Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso=Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso.fit(new_train,target_train)</span><br><span class="line"><span class="comment">#预测测试集和训练集结果</span></span><br><span class="line">y_pred_train=lasso.predict(new_train)</span><br><span class="line"></span><br><span class="line">y_pred_test=lasso.predict(new_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对比结果</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">score_train=r2_score(y_pred_train,target_train)</span><br><span class="line">print(<span class="string">"训练集结果："</span>,score_train)</span><br><span class="line">score_test=r2_score(y_pred_test, target_test)</span><br><span class="line">print(<span class="string">"测试集结果："</span>,score_test)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2、基于树模型的特征选择法"><a href="#2-3-2、基于树模型的特征选择法" class="headerlink" title="2.3.2、基于树模型的特征选择法"></a>2.3.2、基于树模型的特征选择法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Embedded</span></span><br><span class="line"><span class="comment"># 基于树模型的特征选择法</span></span><br><span class="line"><span class="comment"># 随机森林 平均不纯度减少（mean decrease impurity</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">rf = RandomForestRegressor()</span><br><span class="line"><span class="comment"># 训练随机森林模型，并通过feature_importances_属性获取每个特征的重要性分数。rf = RandomForestRegressor()</span></span><br><span class="line">rf.fit(train,target_train)</span><br><span class="line">print(<span class="string">"Features sorted by their score:"</span>)</span><br><span class="line">print(sorted(zip(map(<span class="keyword">lambda</span> x: round(x, <span class="number">4</span>), rf.feature_importances_), train.columns),</span><br><span class="line">             reverse=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">select_columns = [f <span class="keyword">for</span> f, s <span class="keyword">in</span> zip(train.columns, rf.feature_importances_) <span class="keyword">if</span> abs(s)&gt; <span class="number">0.00005</span> ] </span><br><span class="line"><span class="comment"># 选择绝对值大于0.00005的特征</span></span><br><span class="line"></span><br><span class="line">new_train = train[select_columns]</span><br><span class="line">new_test = test[select_columns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso=Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso.fit(new_train,target_train)</span><br><span class="line"><span class="comment">#预测测试集和训练集结果</span></span><br><span class="line">y_pred_train=lasso.predict(new_train)</span><br><span class="line"></span><br><span class="line">y_pred_test=lasso.predict(new_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对比结果</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">score_train=r2_score(y_pred_train,target_train)</span><br><span class="line">print(<span class="string">"训练集结果："</span>,score_train)</span><br><span class="line">score_test=r2_score(y_pred_test, target_test)</span><br><span class="line">print(<span class="string">"测试集结果："</span>,score_test)</span><br></pre></td></tr></table></figure>

<h2 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h2><table>
<thead>
<tr>
<th>类</th>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VarianceThreshold</td>
<td>Filter</td>
<td>方差选择法</td>
</tr>
<tr>
<td>SelectKBest</td>
<td>Filter</td>
<td>可选关联系数、卡方校验、最大信息系数作为得分计算的方法</td>
</tr>
<tr>
<td>RFE</td>
<td>Wrapper</td>
<td>递归地训练基模型，将权值系数较小的特征从特征集合中消除</td>
</tr>
<tr>
<td>SelectFromModel</td>
<td>Embedded</td>
<td>训练基模型，选择权值系数较高的特征</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>basic learning of data competition</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning Ioslation Forest</title>
    <url>/jontyhuang.github.io/2020/01/08/machine-learning-Ioslation-Forest/</url>
    <content><![CDATA[<p>异常检测 (anomaly detection)，又被称为“离群点检测” (outlier detection)，是机器学习研究领域中跟现实紧密联系、有广泛应用需求的一类问题。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/IsolationForest.jpeg" alt=""></p>
<a id="more"></a>

<h1 id="一、算法介绍"><a href="#一、算法介绍" class="headerlink" title="一、算法介绍"></a>一、算法介绍</h1><h2 id="1、iTree（孤立树）"><a href="#1、iTree（孤立树）" class="headerlink" title="1、iTree（孤立树）"></a>1、iTree（孤立树）</h2><p>iTree是一种<strong>随机二叉树</strong>。给定一堆数据集D，这里D的<strong>所有属性都是连续型的变量</strong>。</p>
<p>iTree构成过程如下：</p>
<ul>
<li>随机选择一个属性Attr</li>
<li>随机选择该属性的一个值Value</li>
<li>根据Attr对每条记录进行分类，把Attr小于Value的记录放在左子树，大于Value的记录放在右子树</li>
<li>然后递归的构造出左子树和右子树，直到满足以下条件：<ul>
<li>传入的数据集只有一条记录或者多条一样的记录</li>
<li>树的高度达到限定高度</li>
</ul>
</li>
</ul>
<p>下面是iTree的构造过程：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108124546.png" alt=""></p>
<h2 id="2、预测过程"><a href="#2、预测过程" class="headerlink" title="2、预测过程"></a>2、预测过程</h2><p><strong>异常点一般都是非常稀有的，在iTree中会很快被划分到叶子节点，因此可以用叶子节点到根节点的路径h(x)长度来判断一条记录x是否是异常点</strong>。</p>
<p>譬如：我们对下面的数据点构造iTree，B只需3次就会被分割处理，而与A聚在一起的点需要进行多次分割。个人感觉和决策树差不多，但是决策树是根据信息增益进行分割的。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108125709.png" alt=""></p>
<p>假设要预测的样本为$x$。iTree的训练样本中同样落在$x$所在叶子节点的样本数为$T.size$,则数据$x$在这颗iTree的路径长度为$h(x)$,则$x$的路径长度用以下公式进行计算：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108151038.png" alt=""></p>
<p>其中,$e$表示数据$x$从iTree的根节点到叶子节点过程中经过的边的数目，$C(T.size)$可以认为是一个修正值，它表示一棵用$T.size$条样本数据构建的二叉树的平均路径长度。一般，$C(n)$的计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108151759.png" alt=""></p>
<p>其中$H(k) = ln(k) + \xi$,$\xi$是欧拉常数。</p>
<p>假设训练一棵iTree的样本数目为$\Psi$，则$x$所在这棵iTree的异常指数为</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108152442.png" alt=""></p>
<p>从异常分值的公式看，$s(x,\psi)$取值范围为[0,1]，可以看到，如果h(x)越小，则s(x,ψ)越接近1，如果h(x)越大，则s(x,ψ)越接近0.</p>
<p>如果数据$x$在多棵 iTree 中的平均路径长度越短，得分越接近 1，表明数据$x$越异常；如果数据x在多棵 iTree 中的平均路径长度越长，得分越接近 0，表示数据 xxx 越正常；如果数据 xxx 在多棵 iTree 中的平均路径长度接近整体均值，则打分会在 0.5 附近。</p>
<h2 id="2、iForest"><a href="#2、iForest" class="headerlink" title="2、iForest"></a>2、iForest</h2><p>iForest构造方法是随机采样一部分数据集去构造每棵树，保证不同树之间的差异性，采样的数据量$\Psi$不一定等于n,论文中提到当超过256之后效果提升不大。</p>
<p>除了限制采样的大小以外，我们还需要给每棵树设置最大高度$l=ceiling(\log_2{\Psi})$,这是因为异常数据的路径长度都非常小，所以我们只需将异常值和正常值分开即可，所以只需关心低于平均高度的部分就好了。</p>
<p>iForest是由多颗iTree构成的，所以其iForest异常分值公式变为</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108153934.png" alt=""></p>
<h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><p>iForest算法主要有两个参数：一个是二叉树的个数；另一个是训练单棵 iTree 时候抽取样本的数目。实验表明，当设定为 100 棵树，抽样样本数为 256 条的时候，iForest在大多数情况下就已经可以取得不错的效果。这也体现了算法的简单、高效。</p>
<p>Isolation Forest 是无监督的异常检测算法，在实际应用时，并不需要标签。需要注意的是：（1）如果训练样本中异常样本的比例比较高，违背了先前提到的异常检测的基本假设，可能最终的效果会受影响；（2）异常检测跟具体的应用场景紧密相关，算法检测出的“异常”不一定是我们实际想要的。比如，在识别虚假交易时，异常的交易未必就是虚假的交易。所以，在特征选择时，可能需要过滤不太相关的特征，以免识别出一些不太相关的“异常”。</p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>datawhale数据竞赛组队学习-task02-数据清洗</title>
    <url>/jontyhuang.github.io/2020/01/07/datawhale%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0-task02/</url>
    <content><![CDATA[<p>数据清洗的优良取决于<strong>第一步对数据分析是否透彻</strong>，是否清楚数据中的分类特征和数值型特征，以及哪些特征存在缺失值，分类特征中各个分类特征的文本信息是否有意义，是否需要进一步处理</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109190913.png" alt=""></p>
<a id="more"></a>

<h1 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h1><h2 id="分类特征"><a href="#分类特征" class="headerlink" title="分类特征"></a>分类特征</h2><ul>
<li><p>对分类特征中无意义的文本信息进行填充处理</p>
<ul>
<li><p><strong>使用指定的特征值去代替特殊文本信息</strong>。譬如”rentType”存在“–”这种无意义的特征值转为“未知方式”</p>
</li>
<li><p><strong>使用频次最多的特征值去代替</strong>，譬如特征“buildYear”中的特征点“暂无信息”转为频次最多的特征值1994</p>
</li>
</ul>
</li>
<li><p>特殊的分类特征处理方式</p>
<ul>
<li>对tradeTime的特征值进行分割，分为month和day，这样分类特征就转为了数值型特征</li>
</ul>
</li>
</ul>
<p>对分类特征进行labelEncode编码处理，以便模型的使用。</p>
<h2 id="数值型特征"><a href="#数值型特征" class="headerlink" title="数值型特征"></a>数值型特征</h2><ul>
<li>主要是对缺失值的处理，处理方法有平均值。</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocessingData</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="comment"># 填充缺失值</span></span><br><span class="line">    data[<span class="string">'rentType'</span>][data[<span class="string">'rentType'</span>] == <span class="string">'--'</span>] = <span class="string">'未知方式'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换object类型数据</span></span><br><span class="line">    columns = [<span class="string">'rentType'</span>,<span class="string">'communityName'</span>,<span class="string">'houseType'</span>, <span class="string">'houseFloor'</span>, <span class="string">'houseToward'</span>, <span class="string">'houseDecoration'</span>,  <span class="string">'region'</span>, <span class="string">'plate'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> columns:</span><br><span class="line">        data[feature] = LabelEncoder().fit_transform(data[feature]) <span class="comment"># 对分类特征进行labelEcode编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#处理objec类型的数值信息，将其中的文本信息转为频次最多的数值信息 </span></span><br><span class="line">    <span class="comment">#将buildYear列转换为整型数据</span></span><br><span class="line">    buildYearmean = pd.DataFrame(data[data[<span class="string">'buildYear'</span>] != <span class="string">'暂无信息'</span>][<span class="string">'buildYear'</span>].mode()) <span class="comment"># 提取出现最多的次数的年数</span></span><br><span class="line">    data.loc[data[data[<span class="string">'buildYear'</span>] == <span class="string">'暂无信息'</span>].index, <span class="string">'buildYear'</span>] = buildYearmean.iloc[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    data[<span class="string">'buildYear'</span>] = data[<span class="string">'buildYear'</span>].astype(<span class="string">'int'</span>) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理pv和uv的空值</span></span><br><span class="line">    data[<span class="string">'pv'</span>].fillna(data[<span class="string">'pv'</span>].mean(), inplace=<span class="literal">True</span>)   <span class="comment"># 使用数据的平均值填充空值</span></span><br><span class="line">    data[<span class="string">'uv'</span>].fillna(data[<span class="string">'uv'</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">    data[<span class="string">'pv'</span>] = data[<span class="string">'pv'</span>].astype(<span class="string">'int'</span>)</span><br><span class="line">    data[<span class="string">'uv'</span>] = data[<span class="string">'uv'</span>].astype(<span class="string">'int'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割交易时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month</span><span class="params">(x)</span>:</span></span><br><span class="line">        month = int(x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> month</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(x)</span>:</span></span><br><span class="line">        day = int(x.split(<span class="string">'/'</span>)[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> day</span><br><span class="line">    data[<span class="string">'month'</span>] = data[<span class="string">'tradeTime'</span>].apply(<span class="keyword">lambda</span> x: month(x)) <span class="comment"># apply将month函数映射到各行各列</span></span><br><span class="line">    data[<span class="string">'day'</span>] = data[<span class="string">'tradeTime'</span>].apply(<span class="keyword">lambda</span> x: day(x))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 去掉部分特征</span></span><br><span class="line">    data.drop(<span class="string">'city'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(<span class="string">'tradeTime'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(<span class="string">'ID'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">data_train = preprocessingData(data_train)</span><br></pre></td></tr></table></figure>

<h1 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h1><ul>
<li>孤立森林(IsolationForest)寻找异常值(<a href="https://jontyhuang.github.io/jontyhuang.github.io/2020/01/08/machine-learning-Ioslation-Forest/" target="_blank" rel="noopener">孤立森林的讲解链接</a>）</li>
<li>根据箱图人为的粗略去除一些异常的样本</li>
<li>根据数据分析时describe()函数所出的数据寻找出异常值，具体剔除哪些样本点需要进行不断的测试</li>
</ul>
<h2 id="处理之前的数据"><a href="#处理之前的数据" class="headerlink" title="处理之前的数据"></a>处理之前的数据</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109180924.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109181832.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109181010.png" alt=""></p>
<p>根据分析，我们可以发现area和totalFloor存在不符合常理的异常值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clean data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清洗tradeMoney的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IF_drop</span><span class="params">(train)</span>:</span></span><br><span class="line">    IForest = IsolationForest(contamination=<span class="number">0.01</span>)</span><br><span class="line">    IForest.fit(train[<span class="string">"tradeMoney"</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">    y_pred = IForest.predict(train[<span class="string">"tradeMoney"</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">    drop_index = train.loc[y_pred==<span class="number">-1</span>].index</span><br><span class="line">    print(drop_index)</span><br><span class="line">    train.drop(drop_index,inplace=<span class="literal">True</span>)  <span class="comment"># inpalce对原数据进行操作，不新建新的dataframe</span></span><br><span class="line">    <span class="keyword">return</span> train</span><br><span class="line"></span><br><span class="line">data_train = IF_drop(data_train)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropData</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="comment"># 丢弃部分异常值</span></span><br><span class="line">    train = train[train.area &lt;= <span class="number">200</span>]</span><br><span class="line">    train = train[(train.tradeMoney &lt;=<span class="number">16000</span>) &amp; (train.tradeMoney &gt;=<span class="number">700</span>)]</span><br><span class="line">    train.drop(train[(train[<span class="string">'totalFloor'</span>] == <span class="number">0</span>)].index, inplace=<span class="literal">True</span>)  <span class="comment"># 去掉总层数为0的数据</span></span><br><span class="line">    <span class="keyword">return</span> train  </span><br><span class="line"><span class="comment">#数据集异常值处理</span></span><br><span class="line">data_train = dropData(data_train)</span><br><span class="line"><span class="comment"># 处理异常值后再次查看面积和租金分布图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">sns.boxplot(data_train.area)</span><br><span class="line">plt.show()</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">sns.boxplot(data_train.tradeMoney),</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200108162435.png" alt=""></p>
<h1 id="深度清洗"><a href="#深度清洗" class="headerlink" title="深度清洗"></a>深度清洗</h1><p>深度清洗，我认为还是对异常值的清洗，但是这种异常值的清洗是对多维度数据的清洗，通过多个特征的去判断一个样本是否为异常样本。</p>
<p>通过对train数据和test数据的分析，</p>
<ul>
<li>我们发现city是一样的，同时region=‘RG00015’在测试集中不存在，同时根据箱图我们发现region=‘RG00015’数据点很少，只有一个。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109185344.png" alt=""></p>
<p>通过上图，我们大概可以对一些单位面积租金不合理的样本进行删除，其中删除代码包含在了z最下面代码之中。</p>
<p>下面这个代码是对每个地区的每平方米租金的分析，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_ana = data_train.tradeMoney / data_train.area</span><br><span class="line">print(data_ana.describe())</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">sns.boxplot(data_ana),</span><br><span class="line">plt.show()</span><br><span class="line">data_train.loc[data_ana[data_ana&gt;<span class="number">1000</span>].index,[<span class="string">'area'</span>,<span class="string">'region'</span>,<span class="string">'tradeMoney'</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> set(data_train.region.values):</span><br><span class="line">    plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">    plt.title(i)</span><br><span class="line">    sns.boxplot(data_ana.loc[data_train[data_train[<span class="string">'region'</span>] == i].index]),</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>通过以上的简单的分析，可以去除一些部分异常点，</p>
<p>下面的代码是以region为主要特征进行清洗的（因为城市一样）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对每个地区的逻辑异常值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanData</span><span class="params">(data)</span>:</span></span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00001'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">50</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00001'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">25000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00001'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">250</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">20000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00001'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">400</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00001'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">100</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00002'</span>) &amp; (data[<span class="string">'area'</span>]&lt;<span class="number">100</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">60000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'area'</span>]&lt;<span class="number">300</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">30000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">500</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">50</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1500</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">100</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">300</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">5000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">20</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00003'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">600</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">40000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00004'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">80</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00006'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">200</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00005'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">180</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00005'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">200</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00006'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">200</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00007'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">100</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2500</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00010'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">200</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">25000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00010'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">400</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">15000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00010'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">3000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">200</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00010'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">7000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">75</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00010'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">12500</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">100</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00004'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">400</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">20000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00008'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">80</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00009'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">40000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00009'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">300</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00009'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">100</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00011'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">10000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">390</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00012'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">120</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">5000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00013'</span>) &amp; (data[<span class="string">'area'</span>]&lt;<span class="number">100</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">40000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00013'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">400</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00013'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">80</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">2000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">300</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">40000</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1300</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">80</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">8000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">200</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">20</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">25000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">200</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">20000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">250</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00005'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">30000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">100</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00005'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">50000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">600</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00005'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">350</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00006'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">4000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">100</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00006'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">600</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">100</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00006'</span>) &amp; (data[<span class="string">'area'</span>]&gt;<span class="number">165</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00012'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">800</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">30</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00007'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1100</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">50</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00004'</span>) &amp; (data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">8000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">80</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.loc[(data[<span class="string">'region'</span>]==<span class="string">'RG00002'</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">50</span>)&amp;(data[<span class="string">'rentType'</span>]==<span class="string">'合租'</span>),<span class="string">'rentType'</span>]=<span class="string">'整租'</span>   <span class="comment"># 修改rentype数据</span></span><br><span class="line">    data.loc[(data[<span class="string">'region'</span>]==<span class="string">'RG00014'</span>)&amp;(data[<span class="string">'rentType'</span>]==<span class="string">'合租'</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">60</span>),<span class="string">'rentType'</span>]=<span class="string">'整租'</span></span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00008'</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">15000</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">110</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00008'</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&gt;<span class="number">20000</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">110</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00008'</span>)&amp;(data[<span class="string">'tradeMoney'</span>]&lt;<span class="number">1500</span>)&amp;(data[<span class="string">'area'</span>]&lt;<span class="number">50</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00008'</span>)&amp;(data[<span class="string">'rentType'</span>]==<span class="string">'合租'</span>)&amp;(data[<span class="string">'area'</span>]&gt;<span class="number">50</span>)].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.drop(data[(data[<span class="string">'region'</span>]==<span class="string">'RG00015'</span>) ].index,inplace=<span class="literal">True</span>)</span><br><span class="line">    data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">data_train = cleanData(data_train)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>basic learning of data competition</category>
      </categories>
  </entry>
  <entry>
    <title>datawhale数据竞赛组队学习—-task01-数据分析</title>
    <url>/jontyhuang.github.io/2020/01/06/datawhale%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%E2%80%94-task01/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/%E5%AF%BC%E5%9B%BE1.png" alt=""></p>
<a id="more"></a>

<h1 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h1><p>房价预测是一个典型的回归问题。</p>
<p>$R^{2}=1-\frac{SS_{res}}{SS_{tot}}=1-\frac{\sum\left(y_{i}\hat{y}<em>{i}\right)^{2}}{\sum\left(y</em>{i}\overline{y}\right)^{2}}$</p>
<p>其中，我们发现当模型预测结果越好时，即分子值越小，评价分数越接近1.也就是说score值越大，模型越好。</p>
<p>所给的数据特征大部分是同一个板块的特征。</p>
<h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#导入warnings包，利用过滤器来实现忽略警告语句。</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GBDT</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line"><span class="comment"># XGBoost</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="comment"># LightGBM</span></span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment">#载入数据</span></span><br><span class="line">data_train = pd.read_csv(<span class="string">'./train_data.csv'</span>)</span><br><span class="line">data_train[<span class="string">'Type'</span>] = <span class="string">'Train'</span>   <span class="comment"># 增加新的一列Type</span></span><br><span class="line"></span><br><span class="line">data_test = pd.read_csv(<span class="string">'./test_a.csv'</span>)</span><br><span class="line">data_test[<span class="string">'Type'</span>] = <span class="string">'Test'</span></span><br><span class="line">data_all = pd.concat([data_train, data_test], ignore_index=<span class="literal">True</span>)  <span class="comment"># 拼接数据，同时忽略需要连接的frame本身的index。当原本的index没有特别意义的时候可以使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总体情况</span></span><br><span class="line">print(data_train.info())</span><br><span class="line">print(data_train.describe())  <span class="comment"># 得到统计数目，针对数值类型数据</span></span><br><span class="line">data_train.head()  <span class="comment"># 返回前n行数据</span></span><br></pre></td></tr></table></figure>

<h1 id="数据总览"><a href="#数据总览" class="headerlink" title="数据总览"></a>数据总览</h1><p>根据info()函数我们可以直接看出存在缺失值的特征。</p>
<p>根据describe()函数我们可以大致看出异常值，初步了解一个特征的好坏。譬如下图，我们思考房子面积是否存在为1 的情况。很显然不存在，是没有意义的，所以这个数据是异常值。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200109213807.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 总体情况</span></span><br><span class="line">print(data_train.info())</span><br><span class="line">print(data_train.describe())  <span class="comment"># 得到统计数目，针对数值类型数据</span></span><br><span class="line">data_train.head()  <span class="comment"># 返回前n行数据</span></span><br></pre></td></tr></table></figure>

<p>我们有52列数据，有describe()函数我们可以知道有40列数据为数值型(其中房价为label值）。</p>
<p>我们注意到builYear是整数数据，但是数据类型是object。</p>
<p>当然这一步是数据的简单描述，真正对数据分析的步骤是数据可视化。</p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="提取出分类特征和数值型特征"><a href="#提取出分类特征和数值型特征" class="headerlink" title="提取出分类特征和数值型特征"></a>提取出分类特征和数值型特征</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据特征含义和特征一览，大致可以判断出数值型和类别型特征如下</span></span><br><span class="line">categorical_feas = [<span class="string">'rentType'</span>, <span class="string">'houseType'</span>, <span class="string">'houseFloor'</span>, <span class="string">'region'</span>, <span class="string">'plate'</span>, <span class="string">'houseToward'</span>, <span class="string">'houseDecoration'</span>,</span><br><span class="line">    <span class="string">'communityName'</span>,<span class="string">'city'</span>,<span class="string">'region'</span>,<span class="string">'plate'</span>,<span class="string">'buildYear'</span>]</span><br><span class="line">numerical_feas=[<span class="string">'ID'</span>,<span class="string">'area'</span>,<span class="string">'totalFloor'</span>,<span class="string">'saleSecHouseNum'</span>,<span class="string">'subwayStationNum'</span>,</span><br><span class="line">    <span class="string">'busStationNum'</span>,<span class="string">'interSchoolNum'</span>,<span class="string">'schoolNum'</span>,<span class="string">'privateSchoolNum'</span>,<span class="string">'hospitalNum'</span>,</span><br><span class="line">    <span class="string">'drugStoreNum'</span>,<span class="string">'gymNum'</span>,<span class="string">'bankNum'</span>,<span class="string">'shopNum'</span>,<span class="string">'parkNum'</span>,<span class="string">'mallNum'</span>,<span class="string">'superMarketNum'</span>,</span><br><span class="line">    <span class="string">'totalTradeMoney'</span>,<span class="string">'totalTradeArea'</span>,<span class="string">'tradeMeanPrice'</span>,<span class="string">'tradeSecNum'</span>,<span class="string">'totalNewTradeMoney'</span>,</span><br><span class="line">    <span class="string">'totalNewTradeArea'</span>,<span class="string">'tradeNewMeanPrice'</span>,<span class="string">'tradeNewNum'</span>,<span class="string">'remainNewNum'</span>,<span class="string">'supplyNewNum'</span>,</span><br><span class="line">    <span class="string">'supplyLandNum'</span>,<span class="string">'supplyLandArea'</span>,<span class="string">'tradeLandNum'</span>,<span class="string">'tradeLandArea'</span>,<span class="string">'landTotalPrice'</span>,</span><br><span class="line">    <span class="string">'landMeanPrice'</span>,<span class="string">'totalWorkers'</span>,<span class="string">'newWorkers'</span>,<span class="string">'residentPopulation'</span>,<span class="string">'pv'</span>,<span class="string">'uv'</span>,<span class="string">'lookNum'</span>]</span><br><span class="line">print(len(numerical_feas))</span><br></pre></td></tr></table></figure>



<h2 id="缺失值分析"><a href="#缺失值分析" class="headerlink" title="缺失值分析"></a>缺失值分析</h2><h2 id="寻找存在缺失值的特征"><a href="#寻找存在缺失值的特征" class="headerlink" title="寻找存在缺失值的特征"></a>寻找存在缺失值的特征</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(data_train.isnull().sum())</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200106213438.png" alt=""></p>
<p>有上图我们知道pv和uv特征存在缺失值。</p>
<h2 id="缺失值分析-1"><a href="#缺失值分析-1" class="headerlink" title="缺失值分析"></a>缺失值分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缺失值分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missing_values</span><span class="params">(df)</span>:</span></span><br><span class="line">    alldata_na = pd.DataFrame(df.isnull().sum(), columns=&#123;<span class="string">'missingNum'</span>&#125;)</span><br><span class="line">    alldata_na[<span class="string">'existNum'</span>] = len(df) - alldata_na[<span class="string">'missingNum'</span>]</span><br><span class="line">    alldata_na[<span class="string">'sum'</span>] = len(df)</span><br><span class="line">    alldata_na[<span class="string">'missingRatio'</span>] = alldata_na[<span class="string">'missingNum'</span>]/len(df)*<span class="number">100</span></span><br><span class="line">    alldata_na[<span class="string">'dtype'</span>] = df.dtypes</span><br><span class="line">    <span class="comment">#ascending：默认True升序排列；False降序排列</span></span><br><span class="line">    alldata_na = alldata_na[alldata_na[<span class="string">'missingNum'</span>]&gt;<span class="number">0</span>].reset_index().sort_values(by=[<span class="string">'missingNum'</span>,<span class="string">'index'</span>],ascending=[<span class="literal">False</span>,<span class="literal">True</span>])</span><br><span class="line">    alldata_na.set_index(<span class="string">'index'</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> alldata_na</span><br><span class="line"></span><br><span class="line">missing_values(data_train)</span><br><span class="line">analy_data = data_train[data_train[<span class="string">'uv'</span>].isnull() == <span class="literal">True</span>] <span class="comment"># 找出uv列存在缺失值的列</span></span><br><span class="line">print(analy_data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_train.columns:</span><br><span class="line">    print(i, analy_data.loc[:,i].value_counts().size)</span><br></pre></td></tr></table></figure>

<p>和讲解的一样，所缺失的数据都是同一个板块的数据。</p>
<h2 id="单调特征列分析"><a href="#单调特征列分析" class="headerlink" title="单调特征列分析"></a>单调特征列分析</h2><p>变量之间的单调性关系，譬如房价和面积的关系，时间和房价的单调关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#是否有单调特征列(单调的特征列很大可能是时间)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">incresing</span><span class="params">(vals)</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    len_ = len(vals)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> vals[i+<span class="number">1</span>] &gt; vals[i]:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">fea_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> data_train.columns]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> fea_cols:</span><br><span class="line">    cnt = incresing(data_train[col].values)</span><br><span class="line">    <span class="keyword">if</span> cnt / data_train.shape[<span class="number">0</span>] &gt;= <span class="number">0.55</span>:</span><br><span class="line">        print(<span class="string">'单调特征：'</span>,col)</span><br><span class="line">        print(<span class="string">'单调特征值个数：'</span>, cnt)</span><br><span class="line">        print(<span class="string">'单调特征值比例：'</span>, cnt / data_train.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20200106213316.png" alt=""></p>
<h2 id="特征nunique分布"><a href="#特征nunique分布" class="headerlink" title="特征nunique分布"></a>特征nunique分布</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特征nunique分布</span></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> categorical_feas:</span><br><span class="line">    print(feature + <span class="string">"的特征分布如下："</span>)</span><br><span class="line">    print(data_train[feature].value_counts())</span><br><span class="line">    <span class="keyword">if</span> feature != <span class="string">'communityName'</span>: <span class="comment"># communityName值太多，暂且不看图表</span></span><br><span class="line">        plt.hist(data_all[feature], bins=<span class="number">4</span>)  <span class="comment"># 绘制直方图，bins指定箱子的个数</span></span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

<p>发现communityName特征画不出图来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data_train[<span class="string">'communityName'</span>].value_counts())</span><br><span class="line">print(data_test[<span class="string">'communityName'</span>].value_counts())</span><br></pre></td></tr></table></figure>

<p>根据统计发现，该特征有4236个特征点。</p>
<h2 id="统计特征值频次大于100的特征"><a href="#统计特征值频次大于100的特征" class="headerlink" title="统计特征值频次大于100的特征"></a>统计特征值频次大于100的特征</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计特征值出现频次大于100的特征</span></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> categorical_feas:</span><br><span class="line">    df_value_counts = pd.DataFrame(data_train[feature].value_counts())   <span class="comment"># 对feature进行统计</span></span><br><span class="line">    df_value_counts = df_value_counts.reset_index()</span><br><span class="line">    df_value_counts.columns = [feature, <span class="string">'counts'</span>] <span class="comment"># change column names</span></span><br><span class="line">    print(df_value_counts[df_value_counts[<span class="string">'counts'</span>] &gt;= <span class="number">100</span>])</span><br></pre></td></tr></table></figure>



<h1 id="label分析"><a href="#label分析" class="headerlink" title="label分析"></a>label分析</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Labe 分布</span></span><br><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">3</span>,figsize=(<span class="number">20</span>,<span class="number">5</span>))</span><br><span class="line">fig.set_size_inches(<span class="number">20</span>,<span class="number">12</span>)</span><br><span class="line">sns.distplot(data_train[<span class="string">'tradeMoney'</span>],ax=axes[<span class="number">0</span>][<span class="number">0</span>])   <span class="comment"># 整体绘图</span></span><br><span class="line">sns.distplot(data_train[(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">20000</span>)][<span class="string">'tradeMoney'</span>],ax=axes[<span class="number">0</span>][<span class="number">1</span>])  <span class="comment"># 由第一幅图画出大部分数据所在位置</span></span><br><span class="line">sns.distplot(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">20000</span>)&amp;(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">50000</span>)][<span class="string">'tradeMoney'</span>],ax=axes[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">sns.distplot(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)&amp;(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">100000</span>)][<span class="string">'tradeMoney'</span>],ax=axes[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">sns.distplot(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">100000</span>)][<span class="string">'tradeMoney'</span>],ax=axes[<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>使用seaborn包绘图，可以得出直方图和拟合的概率分布图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"money&lt;=10000"</span>,len(data_train[(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">10000</span>)][<span class="string">'tradeMoney'</span>]))</span><br><span class="line">print(<span class="string">"10000&lt;money&lt;=20000"</span>,len(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">10000</span>)&amp;(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">20000</span>)][<span class="string">'tradeMoney'</span>]))</span><br><span class="line">print(<span class="string">"20000&lt;money&lt;=50000"</span>,len(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">20000</span>)&amp;(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">50000</span>)][<span class="string">'tradeMoney'</span>]))</span><br><span class="line">print(<span class="string">"50000&lt;money&lt;=100000"</span>,len(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">50000</span>)&amp;(data_train[<span class="string">'tradeMoney'</span>]&lt;=<span class="number">100000</span>)][<span class="string">'tradeMoney'</span>]))</span><br><span class="line">print(<span class="string">"100000&lt;money"</span>,len(data_train[(data_train[<span class="string">'tradeMoney'</span>]&gt;<span class="number">100000</span>)][<span class="string">'tradeMoney'</span>]))</span><br></pre></td></tr></table></figure>

<h1 id="数据分析玄学总结"><a href="#数据分析玄学总结" class="headerlink" title="数据分析玄学总结"></a>数据分析玄学总结</h1><ul>
<li>相关性过高的特征不宜全部放在模型中去，cov()跑int类型数据的相关性</li>
<li>可以根据特征之间的相关性构建新的特征或者新的目标变量</li>
<li>同时，我们可能需要关注一下目标变量的时序关系，变量之间单调性关系</li>
<li>查看各个特征的特征值，以便处理缺失值和无意义的数据，其处理方法有很多<ul>
<li>转为其他的特征，“–”变为“未知方式”</li>
<li>作为新的特征。</li>
<li>填充，寻找变量之间的关系进行填充，众数填充，数学方法填充</li>
<li>删除，如果一个特征缺失比例过大且不重要，删除该特征</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>basic learning of data competition</category>
      </categories>
  </entry>
  <entry>
    <title>java ArrayList</title>
    <url>/jontyhuang.github.io/2020/01/02/java-ArrayList/</url>
    <content><![CDATA[<a id="more"></a>

]]></content>
  </entry>
  <entry>
    <title>blue cup ADV193 盾神与条状项链</title>
    <url>/jontyhuang.github.io/2020/01/01/blue-cup-ADV193-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%9D%A1%E7%8A%B6%E9%A1%B9%E9%93%BE/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>machine learning k-均值聚类</title>
    <url>/jontyhuang.github.io/2019/12/19/machine-learning-k-%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>  聚类与分类的最大不同在于，分类的目标事先已知，而聚类则不一样。因为其产生的结果与分类相同，而只是类别没有预先定义，聚类有时也被称为无监督分类</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB.jpeg" alt="">  </p>
<a id="more"></a>

<p>  聚类是一种无监督的学习，它将相似的对象归到同一个簇中。它有点像全自动分类。聚类方法几乎可以应用于所有对象，簇内的对象越相似，聚类的效果越好。本章要学习一种称为K-均值（K-means）聚类的算法。之所以称之为K-均值是因为它可以发现k个不同的簇，且每个簇的中心采用簇中所含值的均值计算而成。下面会逐步介绍该算法的更多细节。  </p>
<h1 id="K-均值聚类算法"><a href="#K-均值聚类算法" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191219201324.png" alt=""></p>
<p>   K-均值是发现给定数据集的k个簇的算法。簇个数k是用户给定的，每一个簇通过其质心（centroid），即簇中所有点的中心来描述。  </p>
<p>K-均值算法的工作流程是这样的。首先，随机确定k个初始点作为质心。然后将数据集中的<br>每个点分配到一个簇中，具体来讲，为每个点找距其最近的质心，并将其分配给该质心所对应的簇。这一步完成之后，每个簇的质心更新为该簇所有点的平均值。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadDataSet</span><span class="params">(fileName)</span>:      #general function to parse tab -delimited floats</span></span><br><span class="line">    dataMat = []                #assume last column is target value</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line in fr.readlines():</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        fltLine = map(float,curLine) #map all elements to float()</span><br><span class="line">        dataMat.append(fltLine)</span><br><span class="line">    <span class="keyword">return</span> dataMat</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">distEclud</span><span class="params">(vecA, vecB)</span>:</span></span><br><span class="line"><span class="function">    return <span class="title">sqrt</span><span class="params">(sum(power(vecA - vecB, <span class="number">2</span>)</span>)) #la.<span class="title">norm</span><span class="params">(vecA-vecB)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">randCent</span><span class="params">(dataSet, k)</span>:   # 构建k个随机质心</span></span><br><span class="line"><span class="function">    n </span>= shape(dataSet)[<span class="number">1</span>]</span><br><span class="line">    centroids = mat(zeros((k,n)))#create centroid mat</span><br><span class="line">    <span class="function"><span class="keyword">for</span> j in <span class="title">range</span><span class="params">(n)</span>:#create random cluster centers, within bounds of each dimension</span></span><br><span class="line"><span class="function">        minJ </span>= min(dataSet[:,j]) </span><br><span class="line">        rangeJ = <span class="keyword">float</span>(max(dataSet[:,j]) - minJ)</span><br><span class="line">        centroids[:,j] = mat(minJ + rangeJ * random.rand(k,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure>

<p>接下来我们准备实现数据点的簇分配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kMeans</span><span class="params">(dataSet, k, distMeas=distEclud, createCent=randCent)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建K个质心,然后将每个店分配到最近的质心,再重新计算质心。</span></span><br><span class="line"><span class="string">    这个过程重复数次,直到数据点的簇分配结果不再改变为止</span></span><br><span class="line"><span class="string">    :param dataMat: 数据集</span></span><br><span class="line"><span class="string">    :param k: 簇的数目</span></span><br><span class="line"><span class="string">    :param distMeans: 计算距离</span></span><br><span class="line"><span class="string">    :param createCent: 创建初始质心</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = shape(dataSet)[<span class="number">0</span>] <span class="comment"># 样本数</span></span><br><span class="line">    <span class="comment"># clusterAssment包含两个列:一列记录簇索引值,第二列存储误差(误差是指当前点到簇质心的距离,后面会使用该误差来评价聚类的效果)</span></span><br><span class="line">    clusterAssment = mat(zeros((m,<span class="number">2</span>)))</span><br><span class="line">    centroids = createCent(dataSet, k)   <span class="comment"># 创建k个质心 </span></span><br><span class="line">    clusterChanged = <span class="literal">True</span>   <span class="comment"># 初始化标志变量,用于判断迭代是否继续,如果True,则继续迭代</span></span><br><span class="line">    <span class="keyword">while</span> clusterChanged:</span><br><span class="line">        clusterChanged = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):<span class="comment">#寻找最近的质点</span></span><br><span class="line">            minDist = inf; minIndex = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">                distJI = distMeas(centroids[j,:],dataSet[i,:])</span><br><span class="line">                <span class="keyword">if</span> distJI &lt; minDist:</span><br><span class="line">                    minDist = distJI; minIndex = j</span><br><span class="line">            <span class="comment"># 如果任一点的簇分配结果发生改变,则更新clusterChanged标志</span></span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i,<span class="number">0</span>] != minIndex: clusterChanged = <span class="literal">True</span></span><br><span class="line">            clusterAssment[i,:] = minIndex,minDist**<span class="number">2</span></span><br><span class="line">        print(centroids)</span><br><span class="line">        <span class="comment"># 遍历所有质心并更新它们的取值</span></span><br><span class="line">        <span class="keyword">for</span> cent <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment"># 通过数据过滤来获得给定簇的所有点</span></span><br><span class="line">            ptsInClust = dataSet[nonzero(clusterAssment[:,<span class="number">0</span>].A==cent)[<span class="number">0</span>]]<span class="comment">#get all the point in this cluster</span></span><br><span class="line">            <span class="comment"># 计算所有点的均值,axis=0表示沿矩阵的列方向进行均值计算</span></span><br><span class="line">            centroids[cent,:] = mean(ptsInClust, axis=<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> centroids, clusterAssment</span><br></pre></td></tr></table></figure>

<h1 id="聚类性能指标SSE"><a href="#聚类性能指标SSE" class="headerlink" title="聚类性能指标SSE"></a>聚类性能指标SSE</h1><p>  在K-均值聚类中簇的数目k是一个用户预先定义的参数，那么用户如何才能知道k的选择是否正确？如何才能知道生成的簇比较好呢？在包含簇分配结果的矩阵中保存着每个点的误差，即该点到簇质心的距离平方值。  </p>
<p>  我们使用SSE误差平方和来评价聚类性能，SSE值越小表示数据点越接近于它们的质心，聚类效果也越好。因为对误差取了平方，因此更加重视那些远离中心的点。一种肯定可以降低SSE值的方法是增加簇的个数，但这违背了聚类的目标。聚类的目标是在保持簇数目不变的情况下提高簇的质量。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191219211739.png" alt=""></p>
<p>  考虑图10-2中的聚类结果，这是在一个包含三个簇的数据集上运行K-均值算法之后的结果，但是点的簇分配结果值没有那么准确。 K-均值算法收敛但聚类效果较差的原因是， K-均值算法收敛到了局部最小值，而非全局最小值（局部最小值指结果还可以但并非最好结果，全局最小值是可能的最好结果）  </p>
<p> 那么如何对图10-2的结果进行改进？你可以对生成的簇进行后处理，一种方法是将具有最大SSE值的簇划分成两个簇。具体实现时可以将最大簇包含的点过滤出来并在这些点上运行K-均值算法，其中k设为2. </p>
<p>  为了保持簇总数不变，可以将某两个簇进行合并。从图10-2中很明显就可以看出，应该将图下部两个出错的簇质心进行合并。可以很容易对二维数据上的聚类进行可视化，但是如果遇到40维的数据应该如何去做？<br>有两种可以量化的办法：合并最近的质心，或者合并两个使得SSE增幅最小的质心。第一种<br>思路通过计算所有质心之间的距离，然后合并距离最近的两个点来实现。第二种方法需要合并两个簇然后计算总SSE值。必须在所有可能的两个簇上重复上述处理过程，直到找到合并最佳的两个簇为止。接下来将讨论利用上述簇划分技术得到更好的聚类结果的方法。  </p>
<h1 id="二分均值算法"><a href="#二分均值算法" class="headerlink" title="二分均值算法"></a>二分均值算法</h1><p>  为克服K-均值算法收敛于局部最小值的问题，有人提出了另一个称为二分K-（bisecting K-means）的算法。该算法首先将所有点作为一个簇，然后将该簇一分为二。之后选择其中一个簇继续进行划分，选择哪一个簇进行划分取决于对其划分是否可以最大程度降低SSE的值。上述基于SSE的划分过程不断重复，直到得到用户指定的簇数目为止。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">biKmeans</span><span class="params">(dataMat, k, distMeas=distEclud)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    在给定数据集,所期望的簇数目和距离计算方法的条件下,函数返回聚类结果</span></span><br><span class="line"><span class="string">    :param dataMat:</span></span><br><span class="line"><span class="string">    :param k:</span></span><br><span class="line"><span class="string">    :param distMeas:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    m, n = shape(dataMat)</span><br><span class="line">    <span class="comment"># 创建一个矩阵来存储数据集中每个点的簇分配结果及平方误差</span></span><br><span class="line">    clusterAssment = mat(zeros((m, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment"># 计算整个数据集的质心,并使用一个列表来保留所有的质心</span></span><br><span class="line">    centroid0 = mean(dataMat, axis=<span class="number">0</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">    centList = [centroid0]</span><br><span class="line">    <span class="comment"># 遍历数据集中所有点来计算每个点到质心的误差值</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        clusterAssment[j, <span class="number">1</span>] = distMeas(mat(centroid0), dataMat[j, :]) ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># 对簇不停的进行划分,直到得到想要的簇数目为止</span></span><br><span class="line">    <span class="keyword">while</span> (len(centList) &lt; k):</span><br><span class="line">        <span class="comment"># 初始化最小SSE为无穷大,用于比较划分前后的SSE</span></span><br><span class="line">        lowestSSE = inf</span><br><span class="line">        <span class="comment"># 通过考察簇列表中的值来获得当前簇的数目,遍历所有的簇来决定最佳的簇进行划分</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(centList)):</span><br><span class="line">            <span class="comment"># 对每一个簇,将该簇中的所有点堪称一个小的数据集</span></span><br><span class="line">            ptsInCurrCluster = dataMat[nonzero(clusterAssment[:, <span class="number">0</span>].A == i)[<span class="number">0</span>], :]</span><br><span class="line">            <span class="comment"># 将ptsInCurrCluster输入到函数kMeans中进行处理,k=2,</span></span><br><span class="line">            <span class="comment"># kMeans会生成两个质心(簇),同时给出每个簇的误差值</span></span><br><span class="line">            centroidMat, splitClustAss = kMeans(ptsInCurrCluster, <span class="number">2</span>, distMeas)</span><br><span class="line">            <span class="comment"># 将误差值与剩余数据集的误差之和作为本次划分的误差</span></span><br><span class="line">            sseSplit = sum(splitClustAss[:, <span class="number">1</span>])</span><br><span class="line">            sseNotSplit = sum(clusterAssment[nonzero(clusterAssment[:, <span class="number">0</span>].A != i)[<span class="number">0</span>], <span class="number">1</span>])</span><br><span class="line">            print(<span class="string">'sseSplit, and notSplit: '</span>, sseSplit, sseNotSplit)</span><br><span class="line">            <span class="comment"># 如果本次划分的SSE值最小,则本次划分被保存</span></span><br><span class="line">            <span class="keyword">if</span> (sseSplit + sseNotSplit) &lt; lowestSSE:</span><br><span class="line">                bestCentToSplit = i</span><br><span class="line">                bestNewCents = centroidMat</span><br><span class="line">                bestClustAss = splitClustAss.copy()</span><br><span class="line">                lowestSSE = sseSplit + sseNotSplit</span><br><span class="line">        <span class="comment"># 找出最好的簇分配结果</span></span><br><span class="line">        <span class="comment"># 调用kmeans函数并且指定簇数为2时,会得到两个编号分别为0和1的结果簇</span></span><br><span class="line">        bestClustAss[nonzero(bestClustAss[:, <span class="number">0</span>].A == <span class="number">1</span>)[<span class="number">0</span>], <span class="number">0</span>] = len(centList)</span><br><span class="line">        <span class="comment"># 更新为最佳质心</span></span><br><span class="line">        bestClustAss[nonzero(bestClustAss[:, <span class="number">0</span>].A == <span class="number">0</span>)[<span class="number">0</span>], <span class="number">0</span>] = bestCentToSplit</span><br><span class="line">        print(<span class="string">'the bestCentToSplit is: '</span>, bestCentToSplit)</span><br><span class="line">        print(<span class="string">'the len of bestClustAss is: '</span>, len(bestClustAss))</span><br><span class="line">        <span class="comment"># 更新质心列表</span></span><br><span class="line">        <span class="comment"># 更新原质心list中的第i个质心为使用二分kMeans后bestNewCents的第一个质心</span></span><br><span class="line">        centList[bestCentToSplit] = bestNewCents[<span class="number">0</span>, :].tolist()[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 添加bestNewCents的第二个质心</span></span><br><span class="line">        centList.append(bestNewCents[<span class="number">1</span>, :].tolist()[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 重新分配最好簇下的数据(质心)以及SSE</span></span><br><span class="line">        clusterAssment[nonzero(clusterAssment[:, <span class="number">0</span>].A == bestCentToSplit)[<span class="number">0</span>], :] = bestClustAss</span><br><span class="line">    <span class="keyword">return</span> mat(centList), clusterAssment</span><br></pre></td></tr></table></figure>

<p> nonzero()将布尔数组转换成一组整数数组，然后使用整数数组进行下标运算(返回数组中值不为0的元素下标）。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191219213945.png" alt=""></p>
<h1 id="示例：对地理坐标进行聚类"><a href="#示例：对地理坐标进行聚类" class="headerlink" title="示例：对地理坐标进行聚类"></a>示例：对地理坐标进行聚类</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clusterClubs</span><span class="params">(fileName, imgName, numClust=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将文本文件的解析,聚类以及画图都封装在一起</span></span><br><span class="line"><span class="string">    :param fileName: 文本数据路径</span></span><br><span class="line"><span class="string">    :param imgName: 图片路径</span></span><br><span class="line"><span class="string">    :param numClust: 希望得到的簇数目</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 创建一个空列表</span></span><br><span class="line">    datList = []</span><br><span class="line">    <span class="comment"># 打开文本文件获取第4列和第5列,这两列分别对应维度和经度,然后将这些值封装到datList</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(fileName).readlines():</span><br><span class="line">        lineArr = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        datList.append([float(lineArr[<span class="number">4</span>]), float(lineArr[<span class="number">3</span>])])</span><br><span class="line">    datMat = mat(datList)</span><br><span class="line">    <span class="comment"># 调用biKmeans并使用distSLC函数作为聚类中使用的距离计算方式</span></span><br><span class="line">    myCentroids, clustAssing = biKmeans(datMat, numClust, distMeas=distSLC)</span><br><span class="line">    <span class="comment"># 创建一幅图和一个举行,使用该矩形来决定绘制图的哪一部分</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    rect = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]</span><br><span class="line">    <span class="comment"># 构建一个标记形状的列表用于绘制散点图</span></span><br><span class="line">    scatterMarkers = [<span class="string">'s'</span>, <span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'8'</span>, <span class="string">'p'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'h'</span>, <span class="string">'&gt;'</span>, <span class="string">'&lt;'</span>]</span><br><span class="line">    axprops = dict(xticks=[], yticks=[])</span><br><span class="line">    ax0 = fig.add_axes(rect, label=<span class="string">'ax0'</span>, **axprops)</span><br><span class="line">    <span class="comment"># 使用imread函数基于一幅图像来创建矩阵</span></span><br><span class="line">    imgP = plt.imread(imgName)</span><br><span class="line">    <span class="comment"># 使用imshow绘制该矩阵</span></span><br><span class="line">    ax0.imshow(imgP)</span><br><span class="line">    <span class="comment"># 再同一幅图上绘制一张新图,允许使用两套坐标系统并不做任何缩放或偏移</span></span><br><span class="line">    ax1 = fig.add_axes(rect, label=<span class="string">'ax1'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 遍历每一个簇并将它们一一画出来,标记类型从前面创建的scatterMarkers列表中得到</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numClust):</span><br><span class="line">        ptsInCurrCluster = datMat[nonzero(clustAssing[:, <span class="number">0</span>].A == i)[<span class="number">0</span>], :]</span><br><span class="line">        <span class="comment"># 使用索引i % len(scatterMarkers)来选择标记形状,这意味这当有更多簇时,可以循环使用这标记</span></span><br><span class="line">        markerStyle = scatterMarkers[i % len(scatterMarkers)]</span><br><span class="line">        <span class="comment"># 使用十字标记来表示簇中心并在图中显示</span></span><br><span class="line">        ax1.scatter(ptsInCurrCluster[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>], ptsInCurrCluster[:, <span class="number">1</span>].flatten().A[<span class="number">0</span>], marker=markerStyle,</span><br><span class="line">                    s=<span class="number">90</span>)</span><br><span class="line">    ax1.scatter(myCentroids[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>], myCentroids[:, <span class="number">1</span>].flatten().A[<span class="number">0</span>], marker=<span class="string">'+'</span>, s=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>software design 结构型设计模式</title>
    <url>/jontyhuang.github.io/2019/12/16/software-design-%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>结构型设计模式主要是将现有的类和对象组合在一起形成强大结构的模式</p>
<a id="more"></a>

<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>  若一个软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题。为了避免系统中出现大量相同或相似的对象，同时又不影响客户端程序通过面向对象的方式对这些对象进行操作，享元模式 因此诞生。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216214820.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216214907.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216215746.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216220116.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216220229.png" alt=""></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216215328.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216215409.png" alt=""></p>
<p>单例模式保证Factory类是唯一的，简单工厂模式是去生产黑白两种棋子。因此单例加简单工厂生产了唯一的黑白棋子，使整个程序共享黑白棋子。</p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111643.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111753.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111811.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111827.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111849.png" alt=""></p>
<h2 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h2><p>将外观类抽象化。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217112245.png" alt=""></p>
<p>  定义：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。  </p>
<p>  在 适配器模式 中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。从而解决了接口不兼容的问题，使得原本没有任何关系的类可以协同<br>工作。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216230025.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216231252.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216230926.png" alt=""></p>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216231726.png" alt=""></p>
<p>定义：  将抽象部分与它的实现部分分离，使它们都可以独立地变化。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232104.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232142.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232256.png" alt=""></p>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232600.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232632.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232711.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216232831.png" alt=""></p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234154.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234245.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234449.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234524.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234549.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234648.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234735.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216234841.png" alt=""></p>
<h2 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216235221.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216235302.png" alt=""></p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217071952.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217104613.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217104637.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217104715.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217104753.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217104913.png" alt=""></p>
<h2 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217105552.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217105658.png" alt=""></p>
<h2 id="透明装饰模式"><a href="#透明装饰模式" class="headerlink" title="透明装饰模式"></a>透明装饰模式</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217105804.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217105915.png" alt=""></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217110717.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217110756.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217110912.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217110839.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217110939.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111226.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111325.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111341.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111358.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111437.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191217111450.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>software design 创建型设计模式</title>
    <url>/jontyhuang.github.io/2019/12/16/software-design-%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpeg" alt=""></p>
<a id="more"></a>

<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216112354.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216112515.png" alt=""></p>
<p>  在使用 简单工厂模式 时，首先需要对产品类进行重构，不能设计<strong>一个包罗万象的产品类</strong>，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类实现。  </p>
<p>  <strong>简单工厂模式</strong>的核心是<strong>工厂类</strong>，在没有工厂类之前，客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类中的静态工厂方法，根据传入的不同参数创建不同的产品对象。  </p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>  工厂方法模式（Factory Method Pattern）定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式 让一个类的实例化延迟到其子类。  </p>
<p>  在<strong>工厂方法模式</strong>中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，提供一个与产品等级结构对应的工厂等级结构。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216122220.png" alt=""></p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191216122306140.png" alt="image-20191216122306140"></p>
<p>总结：相比于简单工厂模式，工厂方法模式使用抽象类工厂来生成多个工厂，增强了工厂类的扩展性。但是无论哪个工厂，产品的类型是要相同的。</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>工厂方法模式存在的问题：</p>
<ul>
<li><p>但是上述工厂方法模式，如果我们将产品的层次增加一个，针对每个一个新增加具体组件都需要增加一个具体工厂，  这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销。  </p>
<p>在 工厂方法模式 中具体工厂负责生产具体产品，每一个具体工厂对应一种具体产品。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱等多种电器，而不是只生产某一种电器。  </p>
</li>
<li><p>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。  </p>
</li>
</ul>
<ul>
<li>产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱。海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成一个产品族。  </li>
</ul>
<p><strong>抽象工厂模式</strong>与<strong>工厂方法模式</strong>最大的区别在于：</p>
<ul>
<li>工厂方法模式：针对的是一个产品等级结构；</li>
<li>抽象工厂模式：针对的是一个产品族，每一个具体工厂可以生产属于一个产品族的所有产品。  </li>
</ul>
<p>抽象工厂：</p>
<p>  提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。（对product进行抽象）  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216205150.png" alt=""></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>  确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216173732.png" alt=""></p>
<p>单例类的三个要点：</p>
<ul>
<li>在单例类（ Singleton ）的内部实现只生成一个实例，同时它提供一个静态的 GetInstance() 工厂方法，让客户可以访问它的唯一实例；  </li>
<li>为了防止在外部对其实例化，将其构造函数设计为私有；  </li>
<li>在单例类内部定义一个 Singleton 类型的静态对象，作为外部共<br>享的唯一实例；  </li>
</ul>
<h2 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216174130.png" alt=""></p>
<h2 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h2><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191216174209924.png" alt="image-20191216174209924"></p>
<ul>
<li><p>饿汉式单例模式<br>当加载类时，初始化静态变量 Instance （调用私有构造函数），创建单例类的唯一实例。如果使用饿汉式单例类，不会出现创建多个单例对象的情况，可确保单例对象的唯一性。  </p>
</li>
<li><p>懒汉式单例模式<br>懒汉式单例类在第一次调用 GetInstance() 方法时实例化，在类加载时并不自实例化，这种技术称为延迟加载（Lazy Load）技术，即需要的时候再加载实例。但实际运行中可能存在多线程调用 GetInstance() 方法的情况，这样不能保证单例对象的唯一<br>性。  </p>
</li>
</ul>
<h3 id="为什么懒汉式不安全"><a href="#为什么懒汉式不安全" class="headerlink" title="为什么懒汉式不安全?"></a>为什么懒汉式不安全?</h3><p>我们假设有多个线程1，线程2都需要使用这个单例对象。而恰巧，线程1在判断完s==null后突然交换了cpu的使用权，变为线程2执行，由于s仍然为null，那么线程2中就会创建这个Singleton的单例对象。之后线程1拿回cpu的使用权，而正好线程1之前暂停的位置就是判断s是否为null之后，创建对象之前。这样线程1又会创建一个新的Singleton对象。</p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>  使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。  </p>
<p>  需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。  </p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>  建造者模式（Builder Pattern）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216204501.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191216204734.png" alt=""></p>
<p><strong>建造者模式</strong>与<strong>抽象工厂模式</strong>有点类似：  </p>
<ul>
<li><p>抽象工厂模式 返回一系列相关产品，而 建造者模式 返回一个<br>完整的复杂产品。  </p>
</li>
<li><p>在 抽象工厂模式 中，客户端通过选择具体工厂来生成所需对<br>象，而在 建造者模式 中，客户端通过指定具体建造者类型并通<br>过 Director 类去一步一步构建一个复杂对象，然后将结果返<br>回。  </p>
</li>
<li><p>如果将 抽象工厂模式 看成一个汽车配件生产厂，生产不同类型<br>的汽车配件，那么<strong>建造者模式</strong>就是一个汽车组装厂，通过对配<br>件进行组装返回一辆完整的汽车。  </p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>blue cup ADV94 盾神与积木游戏</title>
    <url>/jontyhuang.github.io/2019/12/15/blue-cup-ADV94-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E7%A7%AF%E6%9C%A8%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>  问题描述<br>最近的m天盾神都去幼⼉园陪⼩朋友们玩去了+<br>每个⼩朋友都拿到了⼀些积⽊，他们各⾃需要不同数量的积⽊来拼⼀些他们想要的东⻄。但是有的⼩<br>朋友拿得多，有的⼩朋友拿得少，有些⼩朋友需要拿到其他⼩朋友的积⽊才能完成他的⼤作。如果某<br>个⼩朋友完成了他的作品，那么他就会把⾃⼰的作品推倒，⽽⽆私地把他的所有积⽊都奉献出来；但<br>是，如果他还没有完成⾃⼰的作品，他是不会把积⽊让出去的哟+<br>盾神看到这么和谐的⼩朋友们感到⾮常开⼼，于是想帮助他们所有⼈都完成他们各⾃的作品。盾神现<br>在在想，这个理想有没有可能实现呢？于是把这个问题交给了他最信赖的你。<br>输⼊格式<br>第⼀⾏为⼀个数m。<br>接下来有m组数据。每⼀组的第⼀⾏为n，表示这天有n个⼩朋友。接下来的n⾏每⾏两个数，分别表<br>示他现在拥有的积⽊数和他⼀共需要的积⽊数。<br>输出格式<br>输出m⾏，如果第i天能顺利完成所有作品，输出YES，否则输出NO。<br>样例输⼊<br>2 2<br>2 2<br>1 3<br>3<br>1 5<br>3 3<br>0 4<br>样例输出<br>YES<br>NO<br>数据规模和约定<br>1&lt;=n&lt;=10000， 1&lt;=m&lt;=10。  </p>
<a id="more"></a>

<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>这个题目我使用的银行家算法。去找出一个安全序列，如果是安全的话，那么遍历B.Length次就可以求出安全序列，每次遍历必找到至少一个可分配的人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.SysexMessage;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"><span class="keyword">import</span> javax.swing.text.StyledEditorKit.BoldAction;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.INTERNAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] num;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">make</span><span class="params">(<span class="keyword">int</span>[][] A)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> relax = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> len = A.length;</span><br><span class="line">		<span class="keyword">boolean</span>[] B = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">		<span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (count &lt;=len)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> ((A[i][<span class="number">0</span>] + relax) &gt;= A[i][<span class="number">1</span>]  &amp;&amp; B[i]== <span class="keyword">false</span>)&#123;</span><br><span class="line">					</span><br><span class="line">					relax += A[i][<span class="number">0</span>];</span><br><span class="line">					B[i] = <span class="keyword">true</span>;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		count ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Boolean sBoolean : B)&#123;</span><br><span class="line">			<span class="keyword">if</span> (sBoolean == <span class="keyword">false</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	   Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	   <span class="keyword">int</span> m = inScanner.nextInt();</span><br><span class="line">	   <span class="keyword">int</span>[][] A;</span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		   <span class="keyword">int</span> n= inScanner.nextInt();</span><br><span class="line">		   A = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">		   <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			   A[j][<span class="number">0</span>] = inScanner.nextInt();</span><br><span class="line">			   A[j][<span class="number">1</span>] = inScanner.nextInt();</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">if</span> (make(A) == <span class="keyword">true</span>)</span><br><span class="line">		   &#123;</span><br><span class="line">			   System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">			   </span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">else</span>&#123;</span><br><span class="line">			   System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">		   &#125;</span><br><span class="line">		   </span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="comment">//////////////////////////</span></span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">"\n程序运行时间"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup ADV202 最长公共子序列</title>
    <url>/jontyhuang.github.io/2019/12/10/blue-cup-ADV202-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>  问题描述<br>给定两个字符串，寻找这两个字串之间的最⻓公共⼦序列。<br>输⼊格式<br>输⼊两⾏，分别包含⼀个字符串，仅含有⼩写字⺟。<br>输出格式<br>最⻓公共⼦序列的⻓度。<br>样例输⼊<br>abcdgh<br>aedfhb<br>样例输出<br>3<br>样例说明<br>最⻓公共⼦序列为a， d， h。<br>数据规模和约定<br>字串⻓度1+1000  </p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.INTERNAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] num;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	   Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	   String s1 = inScanner.next();</span><br><span class="line">	   String s2 = inScanner.next();</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">int</span> s1len = s1.length();</span><br><span class="line">	   <span class="keyword">int</span> s2len = s2.length();</span><br><span class="line">	   inScanner.close();</span><br><span class="line">	   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	   <span class="comment">//////////</span></span><br><span class="line">	   <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1len+<span class="number">1</span>][s2len+<span class="number">1</span>];</span><br><span class="line">	   <span class="keyword">char</span>[] a = s1.toCharArray();</span><br><span class="line">	   <span class="keyword">char</span>[]  b = s2.toCharArray();</span><br><span class="line">	   </span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=s1len;i++)&#123;</span><br><span class="line">		   <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=s2len;j++)&#123;</span><br><span class="line">			   <span class="keyword">if</span>(a[i-<span class="number">1</span>] == b[j-<span class="number">1</span>])&#123;</span><br><span class="line">				   dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">// 将前一个匹配的字符串添加进来</span></span><br><span class="line">			   &#125;</span><br><span class="line">			   <span class="keyword">else</span>&#123;</span><br><span class="line">				   dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">			   &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	   System.out.println(dp[s1len][s2len]);</span><br><span class="line">	   <span class="comment">//////////////////////////</span></span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">"\n程序运行时间"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning  Regularization</title>
    <url>/jontyhuang.github.io/2019/12/09/machine-learning-Regularization/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209202718.png" alt=""></p>
<a id="more"></a>

<h1 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h1><p>过度拟合的问题通常发生在变量（特征）过多的时候。这种情况下训练出的方程总是能很好的拟合训练数据，也就是说，我们的代价函数可能非常接近于 0 或者就为 0。</p>
<p>但是，这样的曲线千方百计的去拟合训练数据，这样会导致它无法泛化到新的数据样本中，以至于无法预测新样本价格。在这里，<strong>术语”泛化”指的是一个假设模型能够应用到新样本的能力。</strong>新样本数据是指没有出现在训练集中的数据。</p>
<p>下面是线性回归的过拟合问题：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209163702.png" alt=""></p>
<h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><p>上述问题，我们一般有两种解决方法：</p>
<ul>
<li>尽量减少选取变量的数量，这需要我们人工去筛选特征变量。</li>
<li>正则化。我们保留所有的特征变量，但是减少特征变量的数量级。</li>
</ul>
<p>常见的四种正则化方式：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209202812.png" alt=""></p>
<p>lasso回归的代价函数：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209202905.png" alt=""></p>
<p>关于加入了lasso回归发线性回归的梯度下降：</p>
<p>下式的sgn函数的系数存在一些错误，应该还需要除以2.</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209204518.png" alt=""></p>
<h2 id="举例解释"><a href="#举例解释" class="headerlink" title="举例解释"></a>举例解释</h2><p>现在我们使用两个函数去拟合同一个样本，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209194523.png" alt=""></p>
<p>我们发现两个函数拟合的都很好，甚至高次函数拟合的会更好，但是这样的函数未必是一个好的结果，可能存在过拟合的问题。</p>
<p>我们在原来的代价函数上添加惩罚项，使得参数$\theta_3$和$\theta_4$足够小。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209194835.png" alt=""></p>
<p>当我们尽量让上述的代价函数最小时，$\theta_3$和$\theta_4$会尽可能接近于0，就相当于三次项和四次项都不存在一样。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209195048.png" alt=""></p>
<p> 我们最终恰当地拟合了数据，我们所使用的正是二次函数加上一些非常小，贡献很小项（因为这些项的 θ3、 θ4 非常接近于0）。显然，这是一个更好的假设。 </p>
<h2 id="更一般的思路"><a href="#更一般的思路" class="headerlink" title="更一般的思路"></a>更一般的思路</h2><p>在我们上面的例子中，我们惩罚的只是 θ3 和 θ4 ，使这两个值均接近于零，从而我们得到了一个更简单的假设，实际上这个假设大抵上是一个二次函数。</p>
<p>但更一般地说，如果我们像惩罚 θ3 和 θ4 这样惩罚其它参数，那么我们往往可以得到一个相对较为简单的假设。</p>
<p>如果我们有一百个特征，实际上我们并不知道如何选择关联度更好的参数，如何缩小参数的数目等等。因此在正则化里，我们要做的事情，就是把减小我们的代价函数（例子中是线性回归的代价函数）所有的参数值，</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209195431.png" alt=""></p>
<p>其中$\lambda$是正则化参数。</p>
<p>$\lambda$的作用是保持均方误差较小和参数值较小的平衡，从而保证了模型的简单性。</p>
<p>当我们把$\lambda$ 值选的过大时，也就是只有参数值很小的情况下甚至接近于0，代价函数才能过很小。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209200135.png" alt=""></p>
<p>如果我们这么做。模型就相当于只剩下了$\theta_0$常数，拟合了一条直线，这很明显是欠拟合的。其选择的特性也非常少。</p>
<p>因此我们不妨理解为，当数据的特征过少时，即模型比较简单，我们可以让$\lambda$过大，来获得一个比较简单的模型。当然具体$\lambda$具体是多少，还需要我们自己去选择。</p>
<h1 id="Regularized-Linear-Regression"><a href="#Regularized-Linear-Regression" class="headerlink" title="Regularized Linear Regression"></a>Regularized Linear Regression</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209200704.png" alt=""></p>
<h2 id="模型的求解"><a href="#模型的求解" class="headerlink" title="模型的求解"></a>模型的求解</h2><h3 id="1-梯度下降"><a href="#1-梯度下降" class="headerlink" title="1.梯度下降"></a>1.梯度下降</h3><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209200952.png" alt=""></p>
<h3 id="2-正规方程"><a href="#2-正规方程" class="headerlink" title="2.正规方程"></a>2.正规方程</h3><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209201140.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209201319.png" alt=""></p>
<p>我们知道，当样本数过少，导致特征数量大于样本数量，那么$X^TX$是不可逆矩阵，所以我们无法使用正规方程去解出$\theta$，但是正则化为我们解决了这个问题，加入了正则项之后，下面的矩阵是可逆的。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209201708.png" alt=""></p>
<h1 id="Regularized-Logistic-Regression"><a href="#Regularized-Logistic-Regression" class="headerlink" title="Regularized Logistic Regression"></a>Regularized Logistic Regression</h1><h1 id="添加正则项"><a href="#添加正则项" class="headerlink" title="添加正则项"></a>添加正则项</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209202107.png" alt=""></p>
<p>导数如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209202135.png" alt=""></p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning neural network</title>
    <url>/jontyhuang.github.io/2019/12/08/machine-learning-natural-network/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208205601.png" alt=""></p>
<a id="more"></a>

<p>细化个神经元，非线性函数通常是sigmoid函数，tanh，reul</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208211123684.png" alt="image-20191208211123684"></p>
<p>这个非线性函数的作用？</p>
<ul>
<li>如果不是非线性函数，神经网络的输出都是线性组合，那么祈祷书就是一个常数，与输入无关，就等于一个感知机。</li>
<li>非线性函数是逼近函数，输出有界。例如，sigmoid函数，从数学上看，中央区信号增益较大，两边的信号增益小。从神经科学上看，中央区酷似神经元的兴奋区，两侧酷似神经元的抑制态。</li>
</ul>
<h1 id="激活函数的饱和性"><a href="#激活函数的饱和性" class="headerlink" title="激活函数的饱和性"></a>激活函数的饱和性</h1><h2 id="软饱和"><a href="#软饱和" class="headerlink" title="软饱和"></a>软饱和</h2><p>当一个激活函数$f(x)$满足:</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208220726.png" alt=""></p>
<p>我们称之为右饱和</p>
<p>满足：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208220806.png" alt=""></p>
<p>我们称之为左饱和。</p>
<p>当一个函数$f(x)$满足上述左右饱和时，我们称之为软包和。</p>
<h2 id="硬饱和"><a href="#硬饱和" class="headerlink" title="硬饱和"></a>硬饱和</h2><p> 相对应的，对任意的x，如果存在常数c，当x&gt;c时恒有 f′(x)=0则称其为<strong>右硬饱和</strong>，当x比c小时恒 有f′(x)=0则称其为<strong>左硬饱和</strong>。若既满足左硬饱和，又满足右硬饱和，则称这种激活函数为<strong>硬饱和</strong>。 </p>
<h1 id="简单的神经网络"><a href="#简单的神经网络" class="headerlink" title="简单的神经网络"></a>简单的神经网络</h1><h2 id="与AND"><a href="#与AND" class="headerlink" title="与AND"></a>与AND</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208205816.png" alt=""></p>
<h2 id="或OR"><a href="#或OR" class="headerlink" title="或OR"></a>或OR</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208205905.png" alt=""></p>
<h2 id="非NEGATION"><a href="#非NEGATION" class="headerlink" title="非NEGATION"></a>非NEGATION</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208205945.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208210039.png" alt=""></p>
<h2 id="异或XNOR"><a href="#异或XNOR" class="headerlink" title="异或XNOR"></a>异或XNOR</h2><p><strong>传统的神经网络和经典机器学习方法是无法对异或进行分类的</strong></p>
<p>两层神经网络</p>
<p>将其转为<strong>或问题</strong></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208210334.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/109bb60bcaf9de398720dd1ec59c259.jpg" alt=""></p>
<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>当我们使用softmax得到了概率之后，选取其中最大概率的事件作为结果，我如何评价我的结果呢？</p>
<p>我们使用交叉熵去进行评价，其公式如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209112412.png" alt=""></p>
<ul>
<li>$M$——类别的数量；</li>
<li>$y_c$ ——指示变量（0或1）,如果该类别和样本的类别相同就是1，否则是0；</li>
<li>$P_c$ ——对于观测样本属于类别C的预测概率。 </li>
</ul>
<p>当我们对输入进行预测时，输出的结果是第$j$类，则上述公式简化为$Loss = -  \ln  a_j$，其中$y_j$为1</p>
<p>我们对$a_i$求导可得:$\frac{\delta Loss}{\delta a_i} = -\frac{1}{a_i}$</p>
<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><h2 id="1-双曲正切函数tanh"><a href="#1-双曲正切函数tanh" class="headerlink" title="1.双曲正切函数tanh"></a>1.双曲正切函数tanh</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208215157.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208215213.png" alt=""></p>
<p>优势：</p>
<p>1.比Sigmoid函数收敛速度更快。<br>2.相比Sigmoid函数，其输出以0为中心，因此实际应用中 tanh 会比 sigmoid 更好，因为 tanh 的输出均值比 sigmoid 更接近 0，SGD会更接近 natural gradient（一种二次优化技术），从而降低所需的迭代次数。<br>缺点：<br>还是没有改变Sigmoid函数的最大问题——由于饱和性产生的梯度消失。</p>
<h2 id="2-ReLu函数"><a href="#2-ReLu函数" class="headerlink" title="2.ReLu函数"></a>2.ReLu函数</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208222501.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208222543.png" alt=""></p>
<p>优点：</p>
<ul>
<li>实现单侧抑制，兴奋界相对宽阔，稀疏激活性</li>
<li>相比于sigmoid，tanh函数，它们都有指数运算，而ReLu计算简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ReLU单元比较脆弱并且可能“死掉”，而且是不可逆的，因此导致了数据多样化的丢失。通过合理设置学习率，会降低神经元“死掉”的概率。 </li>
</ul>
<h2 id="3-Leaky-ReLU"><a href="#3-Leaky-ReLU" class="headerlink" title="3.Leaky ReLU"></a>3.Leaky ReLU</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208225118.png" alt=""></p>
<p> 其中 <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="[公式]"> 是很小的负数梯度值，比如0.01，Leaky ReLU非线性函数图像如下图所示。这样做目的是使负轴信息不会全部丢失，解决了ReLU神经元“死掉”的问题。更进一步的方法是PReLU，即把$\varepsilon$当做每个神经元中的一个参数，是可以通过梯度下降求解的。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208225411.png" alt=""></p>
<h2 id="3-sotfmax函数"><a href="#3-sotfmax函数" class="headerlink" title="3.sotfmax函数"></a>3.sotfmax函数</h2><p>softmax函数常应用于多分类的过程，它将神经元的输出，映射到（0，1）区间。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208211410.png" alt=""></p>
<p> 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    x = x - np.max(x)  <span class="comment"># 防止x中的数过大，导致超出运算范围，实际操作等于分子分母同除exp(np.max(X))</span></span><br><span class="line">    exps = np.exp(x)</span><br><span class="line">    <span class="keyword">return</span> exps / np.sum(exps)</span><br></pre></td></tr></table></figure>



<p><img src="https://upload-images.jianshu.io/upload_images/5236230-12cd299a8d571d1e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/678/format/webp" alt="img"> </p>
<p>我们可以发现，越大的数，其softmax之后的值越大。</p>
<p>为什么需要softmax？</p>
<p>假如，我们有两个数，a和b，其中a &gt; b，在选择大数时，我们会直接去选a,因此这个会造成不断选择的情况下小数的饥饿。我希望大数可以经常被取到，而小数也可以被取到。如果我使用softmax函数将他们映射为概率。</p>
<h3 id="对sorftmax求导"><a href="#对sorftmax求导" class="headerlink" title="对sorftmax求导"></a>对sorftmax求导</h3><p>这里导数分为两种情况：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208214543.png" alt=""></p>
<p> <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191208214559.png" alt=""></p>
<h1 id="反向传播的简单例子"><a href="#反向传播的简单例子" class="headerlink" title="反向传播的简单例子"></a>反向传播的简单例子</h1><p>网络如下:</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191209152604.png" alt=""></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""softmax函数"""</span></span><br><span class="line">    x = x - np.max(x)</span><br><span class="line">    exps = np.exp(x)</span><br><span class="line">    <span class="keyword">return</span> exps / np.sum(exps,axis =<span class="number">1</span>,keepdims = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot  <span class="keyword">as</span> plt</span><br><span class="line"><span class="string">"""生成样本"""</span></span><br><span class="line">np.random.seed(<span class="number">777</span>)</span><br><span class="line">X,y = sklearn.datasets.make_moons(<span class="number">500</span>, noise = <span class="number">0.1</span>)  <span class="comment"># 生成500个数据，。很明显线性logstic regreation是不行的</span></span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span> ], X[:,<span class="number">1</span>],c=y)</span><br><span class="line">plt.show()</span><br><span class="line">print(y)</span><br><span class="line">trainset_length = len(X)</span><br><span class="line">lr = <span class="number">0.01</span></span><br><span class="line">nn_output_dim =<span class="number">2</span></span><br><span class="line">nn_intput_dim = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_loss</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="string">"""计算交叉熵"""</span></span><br><span class="line">    W1,b1,W2,b2 = model[<span class="string">"W1"</span>],model[<span class="string">"b1"</span>],model[<span class="string">"W2"</span>],model[<span class="string">"b2"</span>]</span><br><span class="line">    z1 = X.dot(W1) + b1</span><br><span class="line">    a1 = np.tanh(z1)</span><br><span class="line">    z2 = a1.dot(W2) + b2</span><br><span class="line"><span class="comment">#     exp_scores  = np.exp(z2)</span></span><br><span class="line"><span class="comment">#     probs = exp_scores / np.sum(exp_scores, axis =1,keepdims= True)</span></span><br><span class="line">    probs = softmax(z2)</span><br><span class="line">    log_probs = -np.log(probs[range(trainset_length),y])  <span class="comment"># 因为是0和1，0的交叉熵为0</span></span><br><span class="line">    loss = np.sum(log_probs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / trainset_length * loss  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">(nn_hidden_dim, num_psses = <span class="number">200</span>, print_loss = True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    nn_hidden_dim : 隐藏层的结点数</span></span><br><span class="line"><span class="string">    num_psses : 迭代次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    W1 = np.random.randn(nn_intput_dim, nn_hidden_dim) / np.sqrt(nn_intput_dim)</span><br><span class="line">    b1 = np.zeros((<span class="number">1</span>,nn_hidden_dim))</span><br><span class="line">    W2 = np.random.randn(nn_hidden_dim, nn_output_dim) / np.sqrt(nn_intput_dim)</span><br><span class="line">    b2 = np.zeros((<span class="number">1</span>, nn_output_dim))</span><br><span class="line">   </span><br><span class="line">    model  =&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_psses):</span><br><span class="line">        <span class="comment"># 正向传播</span></span><br><span class="line">        z1 = X.dot(W1) + b1</span><br><span class="line">        a1  =np.tanh(z1)   <span class="comment">#激活函数</span></span><br><span class="line">        z2 = a1.dot(W2) + b2   <span class="comment">#dot是矩阵乘法</span></span><br><span class="line">        probs = softmax(z2)</span><br><span class="line"></span><br><span class="line">        delta3 = probs</span><br><span class="line">        delta3[range(trainset_length),y] -= <span class="number">1</span>  <span class="comment"># 交叉熵对z2层的导数</span></span><br><span class="line">        dW2 = (a1.T).dot(delta3)  <span class="comment"># 交叉熵对w2的导数      </span></span><br><span class="line">        db2 = np.sum(delta3, axis =<span class="number">0</span>, keepdims = <span class="literal">True</span>)  <span class="comment"># # 交叉熵对b2的导数</span></span><br><span class="line">        delta2 = delta3.dot(W2.T) * (<span class="number">1</span> - np.power(a1, <span class="number">2</span>))   <span class="comment"># 交叉熵对z1的导数</span></span><br><span class="line">        dW1  =np.dot(X.T, delta2)  <span class="comment"># 交叉熵对w1的导数b</span></span><br><span class="line">        db1 = np.sum(delta2, axis = <span class="number">0</span>,keepdims = <span class="literal">True</span>)  <span class="comment"># 交叉熵对b1的导数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 梯度更新</span></span><br><span class="line">        W1 -= lr * dW1</span><br><span class="line">        b1 -= lr * db1</span><br><span class="line">        W2 -= lr * dW2</span><br><span class="line">        b2 -= lr * db2</span><br><span class="line">                  </span><br><span class="line">        model = &#123;<span class="string">'W1'</span>:W1,<span class="string">"b1"</span>:b1,<span class="string">"W2"</span>:W2,<span class="string">"b2"</span>:b2&#125;</span><br><span class="line">        <span class="keyword">if</span> print_loss <span class="keyword">and</span> i % <span class="number">10</span> ==<span class="number">0</span>:</span><br><span class="line">                  print(<span class="string">'Loss after iteration &#123;&#125; : &#123;&#125;'</span>.format(i,calculate_loss(model)))</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">model = build_model(<span class="number">10</span>, <span class="number">500</span>,print_loss = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup ADV205 拿糖果</title>
    <url>/jontyhuang.github.io/2019/12/07/blue-cup-ADV205-%E6%8B%BF%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>妈妈给小B买了N块糖！但是她不允许小B直接吃掉。</p>
<p>假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。</p>
<p>现在小B希望知道最多可以拿多少糖。</p>
<p>一个整数 N</p>
<p>输出格式</p>
<p>最多可以拿多少糖</p>
<p>样例输入</p>
<p>15</p>
<p>样例输出</p>
<p>6</p>
<p>数据规模和约定</p>
<p>N &lt;= 100000</p>
<a id="more"></a>

<p>思路：解题过程中，我们肯定思考到要想知道N的最多拿糖数，必然需要知道N-2*P(P为拿糖数)，因此此题是一个动态规划题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.INTERNAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	   Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	   <span class="keyword">int</span> n = inScanner.nextInt();</span><br><span class="line">	   inScanner.close();</span><br><span class="line">	   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	   <span class="comment">//////////</span></span><br><span class="line">	   <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">	   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">	   <span class="keyword">int</span>[] prim = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">	   <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i &lt;<span class="number">350</span>;++i)&#123;  <span class="comment">//糖果最大为100001，其根号值比小于350</span></span><br><span class="line">		  <span class="keyword">if</span>(temp[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		  <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; <span class="number">100001</span>; j+=i)<span class="comment">//id的公倍数都不是质数</span></span><br><span class="line">	            temp[j] = <span class="number">1</span>;</span><br><span class="line">		  prim[index] = i;</span><br><span class="line">		  index++;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;           <span class="comment">//遍历每个糖果数</span></span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; index; ++j) &#123;  <span class="comment">// 遍历每个质数</span></span><br><span class="line">	            <span class="keyword">if</span> (prim[j] &gt; Math.sqrt(i)) <span class="keyword">break</span>;   <span class="comment">// prim[j] * 2 小于 i</span></span><br><span class="line">	            <span class="keyword">if</span> (i % prim[j] == <span class="number">0</span>) <span class="comment">// 如果prim[j]是其质因数</span></span><br><span class="line">	                dp[i] = Math.max(dp[i], dp[i-<span class="number">2</span>*(prim[j])] + prim[j]);</span><br><span class="line">	        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	 System.out.print(dp[n]);</span><br><span class="line">	   <span class="comment">//////////////////////////</span></span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">"\n程序运行时间"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>blue cup BASIC30 阶乘计算</title>
    <url>/jontyhuang.github.io/2019/12/05/blue-cup-BASIC30-%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>  问题描述<br>输⼊⼀个正整数n，输出n!的值。<br>其中n!=1<em>2</em>3<em>…</em>n。<br>算法描述<br>n!可能很⼤，⽽计算机能表示的整数范围有限，需要使⽤⾼精度计算的⽅法。使⽤⼀个数组A来表示⼀<br>个⼤整数a， A[0]表示a的个位， A[1]表示a的⼗位，依次类推。<br>将a乘以⼀个整数k变为将数组A的每⼀个元素都乘以k，请注意处理相应的进位。<br>⾸先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。<br>输⼊格式<br>输⼊包含⼀个正整数n， n&lt;=1000。<br>输出格式<br>输出n!的准确值。<br>样例输⼊  </p>
<p> 10<br>样例输出<br>3628800  </p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.INTERNAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> cnt =<span class="number">0</span>, num =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isVisit[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> max=<span class="number">10000</span>; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	   Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	   <span class="keyword">int</span> n = inScanner.nextInt();</span><br><span class="line">	   inScanner.close();</span><br><span class="line">	   <span class="comment">//////////</span></span><br><span class="line">	   <span class="keyword">long</span> startTime = System.nanoTime(); <span class="comment">// 获取开始时间</span></span><br><span class="line">	   <span class="keyword">int</span>[]  A = <span class="keyword">new</span> <span class="keyword">int</span>[max +<span class="number">1</span>];</span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">		   A[i] =<span class="number">0</span>;</span><br><span class="line">	   &#125;</span><br><span class="line">	  A[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">int</span> wei = <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		  <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;max;j++)&#123;</span><br><span class="line">			  <span class="keyword">int</span> tepm = A[j]* i + r;</span><br><span class="line">			  r = tepm /<span class="number">10</span>;</span><br><span class="line"><span class="comment">//			  if(r !=0) wei= Math.min(j+1, wei+1);</span></span><br><span class="line">			  A[j] = tepm % <span class="number">10</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">int</span> m =max;</span><br><span class="line">	  <span class="keyword">while</span>(A[m--] == <span class="number">0</span> &amp;&amp; m&gt;= <span class="number">0</span>);</span><br><span class="line">		  </span><br><span class="line">		  <span class="keyword">for</span>(<span class="keyword">int</span> i =m +<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)System.out.print(A[i]);</span><br><span class="line"><span class="comment">//	for(int i=wei;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">//	System.out.print(A[i]);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	   </span><br><span class="line">	   </span><br><span class="line">	   </span><br><span class="line">	 </span><br><span class="line">	   <span class="comment">//////////////////////////</span></span><br><span class="line">	    <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    System.out.println(<span class="string">"\n程序运行时间"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup PREV3 带分数</title>
    <url>/jontyhuang.github.io/2019/12/04/blue-cup-PREV3-%E5%B8%A6%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>100 可以表示为带分数的形式：100 = 3 + 69258 / 714。</p>
<p>还可以表示为：100 = 82 + 3546 / 197。</p>
<p>注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。</p>
<p>类似这样的带分数，100 有 11 种表示法。</p>
<p>输入格式<br>从标准输入读入一个正整数N (N&lt;1000*1000)</p>
<p>输出格式<br>程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。</p>
<p>注意：不要求输出每个表示，只统计有多少表示法！</p>
<p>样例输入1<br>100<br>样例输出1<br>11<br>样例输入2<br>105<br>样例输出2<br>6<br>【分析】用深度优先搜索，将1～9形成一个全排列，根据整数部分、分子和分母的长度来分割整个排列。设整数部分为a，分子为b，分母为c，这个数字的带分数形式就是a + (b / c)。a和b的长度是1～7，c的长度是由a和b来确定的，三个数字的总长度是9。最后验证a + (b / c)是否等于输入的数字。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> cnt =<span class="number">0</span>, num =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isVisit[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	    String s = inScanner.nextLine();</span><br><span class="line">	    num = Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line">	   </span><br><span class="line">	    inScanner.close();</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++)&#123;</span><br><span class="line">	    		<span class="keyword">if</span>(<span class="number">9</span> - i - j &gt;=<span class="number">1</span>)&#123;</span><br><span class="line">	    			dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, i, j, <span class="number">9</span>-i-j);    <span class="comment">// 对每次不同的长度进行dfs</span></span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    System.out.print(cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> alen, <span class="keyword">int</span> blen,<span class="keyword">int</span> clen)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(alen == <span class="number">0</span> &amp;&amp; blen ==<span class="number">0</span> &amp;&amp; clen == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(b%c == <span class="number">0</span> &amp;&amp; num == a + b / c)&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!isVisit[i])&#123;</span><br><span class="line">			isVisit[i] = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">0</span> &lt;alen)dfs(a*<span class="number">10</span>+i, b, c, alen-<span class="number">1</span>, blen, clen);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> &lt; blen) dfs(a, b*<span class="number">10</span>+i, c, alen, blen-<span class="number">1</span>, clen);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> &lt; clen) dfs(a, b, c * <span class="number">10</span> +i, alen, blen, clen-<span class="number">1</span>);</span><br><span class="line">			isVisit[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup PREV5 错误票据</title>
    <url>/jontyhuang.github.io/2019/12/03/blue-cup-PREV5-%E9%94%99%E8%AF%AF%E7%A5%A8%E6%8D%AE/</url>
    <content><![CDATA[<p>  问题描述<br>某涉密单位下发了某种票据，并要在年终全部收回。<br>每张票据有唯⼀的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。<br>因为⼯作⼈员疏忽，在录⼊ID号的时候发⽣了⼀处错误，造成了某个ID断号，另外⼀个ID重号。<br>你的任务是通过编程，找出断号的ID和重号的ID。<br>假设断号不可能发⽣在最⼤和最⼩号。<br>输⼊格式<br>要求程序⾸先输⼊⼀个整数N(N&lt;100)表示后⾯数据⾏数。<br>接着读⼊N⾏数据。<br>每⾏数据⻓度不等，是⽤空格分开的若⼲个（不⼤于100个）正整数（不⼤于100000），请注意⾏内<br>和⾏末可能有多余的空格，你的程序需要能处理这些空格。<br>每个整数代表⼀个ID号。<br>输出格式<br>要求程序输出1⾏，含两个整数m n，⽤空格分隔。<br>其中， m表示断号ID， n表示重号ID<br>样例输⼊1<br>2<br>5 6 8 11 9<br>10 12 9<br>样例输出1<br>7 9<br>样例输⼊2<br>6<br>164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196<br>172 189 127 107 112 192 103 131 133 169 158<br>128 102 110 148 139 157 140 195 197<br>185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190<br>149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188<br>113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119<br>样例输出2<br>105 120  </p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span>[][] a;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	    <span class="keyword">int</span> n = inScanner.nextInt();</span><br><span class="line">	    inScanner.nextLine();</span><br><span class="line">	    <span class="keyword">int</span>[] corrent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">	    <span class="keyword">int</span> min =<span class="number">10000</span>;</span><br><span class="line">	    <span class="keyword">int</span> max =<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	    	String[] id = inScanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;id.length;j++)&#123;</span><br><span class="line">	    		</span><br><span class="line">	    		</span><br><span class="line">	    		<span class="keyword">int</span> num = Integer.parseInt(id[j]); <span class="comment">// 将字符转为整型</span></span><br><span class="line">	    		corrent[num]++;</span><br><span class="line">	    		<span class="keyword">if</span>(num&lt;min) min =num;</span><br><span class="line">	    		<span class="keyword">if</span>(num &gt;max) max =num;</span><br><span class="line">	    		</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=min;i&lt;max+<span class="number">1</span>;i++)&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(corrent[i]==<span class="number">0</span>)&#123;System.out.println(i);x =i;&#125;</span><br><span class="line">	    	<span class="keyword">if</span>(corrent[i]==<span class="number">2</span>)y=i;</span><br><span class="line">	    &#125;</span><br><span class="line">	    System.out.println(x + <span class="string">" "</span> + y);</span><br><span class="line">	    inScanner.close();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup PREV33 兰顿蚂蚁</title>
    <url>/jontyhuang.github.io/2019/12/02/blue-cup-PREV33-%E5%85%B0%E9%A1%BF%E8%9A%82%E8%9A%81/</url>
    <content><![CDATA[<p>【题目】<br>兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。<br>平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。<br>蚂蚁的头部朝向为：上下左右其中一方。<br>蚂蚁的移动规则十分简单：<br>若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；<br>若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。<br>规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，<br>蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。<br>蚂蚁的路线是很难事先预测的。<br>你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。<br>【数据格式】<br>输入数据的第一行是 m n 两个整数（3 &lt; m, n &lt; 100），表示正方形格子的行数和列数。<br>接下来是 m 行数据。<br>每行数据为 n 个被空格分开的数字。0 表示白格，1 表示黑格。<br>接下来是一行数据：x y s k, 其中x y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。<br>s 是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k 表示蚂蚁走的步数。<br>输出数据为两个空格分开的整数 p q, 分别表示蚂蚁在k步后，所处格子的行号和列号。<br>例如, 输入：<br>5 6<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 1 0 0 0<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>2 3 L 5<br>程序应该输出：<br>1 3<br>再例如, 输入：<br>3 3<br>0 0 0<br>1 1 1<br>1 1 1<br>1 1 U 6<br>程序应该输出：<br>0 0</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream.GetField;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.x500.X500Principal;</span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.HTMLReader.IsindexAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String ss = <span class="string">"URDL"</span>;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span>[][] a;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> s,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 转换方向，并将格子颜色换掉</span></span><br><span class="line">		<span class="keyword">int</span> index = ss.indexOf(s);  <span class="comment">// 获取s的索引位置</span></span><br><span class="line">		<span class="keyword">if</span>(a[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">			index --;</span><br><span class="line">			<span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">				index =<span class="number">3</span>;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			a[x][y] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			index = (index+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">			a[x][y] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ss.charAt(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">char</span> dist, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">			System.out.print(x + <span class="string">" "</span> + y);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		dist = getNext(dist, x, y);</span><br><span class="line">		<span class="keyword">switch</span> (dist) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">			x--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">			y--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">			x++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">			y++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		walk( x, y, dist, k-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    Scanner inScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	    <span class="keyword">int</span> m = inScanner.nextInt();</span><br><span class="line">	    <span class="keyword">int</span> n = inScanner.nextInt();</span><br><span class="line">	    a =<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">	    		a[i][j] = inScanner.nextInt();</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">int</span> x = inScanner.nextInt();</span><br><span class="line">	    <span class="keyword">int</span> y = inScanner.nextInt();</span><br><span class="line">	    <span class="keyword">char</span> dirt = inScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">int</span> k = inScanner.nextInt();</span><br><span class="line">	    walk(x, y, dirt, k);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup  排队打水</title>
    <url>/jontyhuang.github.io/2019/11/28/blue-cup-%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4/</url>
    <content><![CDATA[<p>有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2…………tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？</p>
<p>输入格式<br>第一行n，r (n&lt;=500,r&lt;=75)<br>第二行为n个人打水所用的时间Ti (Ti&lt;=100)；<br>输出格式<br>最少的花费时间<br>样例输入<br>3 2<br>1 2 3</p>
<p>样例输出<br>7</p>
<a id="more"></a>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>先让打水时间少的人打水。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.x500.X500Principal;</span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.HTMLReader.IsindexAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String S1;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		n = in.nextInt();     <span class="comment">// 人数</span></span><br><span class="line">		r = in.nextInt();    <span class="comment">// 水龙头数</span></span><br><span class="line">		<span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			t[i] = in.nextInt();  <span class="comment">// 存储打水的时间</span></span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(t);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//记录时间</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; t.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;r)&#123;</span><br><span class="line">				sum += t[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">			t[i] += t[i-r];</span><br><span class="line">			sum += t[i];</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	System.out.print(sum);	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning SVM</title>
    <url>/jontyhuang.github.io/2019/11/28/machine-learning-SVM/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/SVM.jpg" alt=""></p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128115838.png" alt=""></p>
<h1 id="1-线性可分支持向量机"><a href="#1-线性可分支持向量机" class="headerlink" title="1. 线性可分支持向量机"></a>1. 线性可分支持向量机</h1><p>考虑一个二分类问题，假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或者离散集合，特征空间为欧式空间或者希尔伯特空间。线性可分支持向量机，线性支持向量机假设这两个空间的元素一一对应，并将输入空间中输入映射为特征空间中的特征向量，支持向量机的学习是在特征空间中进行的。学习的目标是在特征空间中寻找一个超平面，能够将实例分到不同的类，分离超平面对应于方程$w\cdot x+b = 0$,它由法向量w和截距b决定。</p>
<p>一般的当数据线性可分时，存在无穷个分离超平面可将两类数据正确分开。线性可分支持向量机利用间隔最大化求最优分离超平面。这时，解是唯一的。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128120617.png" alt=""></p>
<h2 id="1-1-函数间隔"><a href="#1-1-函数间隔" class="headerlink" title="1.1 函数间隔"></a>1.1 函数间隔</h2><p>我们用函数间隔来表示分类预测的确信程度，离超平面越近，其置信程度越低。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128150452.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128120944.png" alt=""></p>
<p>函数间隔可以表示分类预测的正确性和置信度，但是在选择超平面时, 只有函数间隔还不够。因为只要成比例地改变w和b, 例如将它们改为2w和2b，超平面没有改变，但是函数间隔变为原来的两倍了。因此，我们需要对于分离超平面的法向量w加一些约束，如规范化，$||w|| =1$ ,使得间隔是确定的，这时的函数间隔为几何间隔。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128150930.png" alt=""></p>
<p>当样本点被超平面正确分类时，几何间隔就是实例点到超平面的距离。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128151144.png" alt=""></p>
<h2 id="1-2-间隔最大化"><a href="#1-2-间隔最大化" class="headerlink" title="1.2 间隔最大化"></a>1.2 间隔最大化</h2><p>支持向量机学习的基本思想就是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对于线性可分数据集而言，线性可分分离超平面有无穷多个（等价于感知机），但是几何间隔最大的分离超平面是唯一的。这里的间隔最大化又称为硬间隔最大化。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128151510.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128151853.png" alt=""></p>
<p>上述问题是凸二次规划问题，解出最优解$w^<em>$,$b^</em>$。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128152144.png" alt=""> </p>
<h2 id="1-3-支持向量和间隔边界"><a href="#1-3-支持向量和间隔边界" class="headerlink" title="1.3 支持向量和间隔边界"></a>1.3 支持向量和间隔边界</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128154248.png" alt=""></p>
<h2 id="1-4-对偶问题的求解"><a href="#1-4-对偶问题的求解" class="headerlink" title="1.4 对偶问题的求解"></a>1.4 对偶问题的求解</h2><p>线性可分支持向量机的最优化问题可以应用拉格朗日对偶性，通过求解对偶问题求解最优解。这样做，第一是对偶问题往往容易求解，第二是自然引入核函数，进而推广到非线性分类问题。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128154640.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128154746.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128155150.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128155424.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128155808.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128160613.png" alt=""></p>
<h1 id="2-线性支持向量机"><a href="#2-线性支持向量机" class="headerlink" title="2. 线性支持向量机"></a>2. 线性支持向量机</h1><p>线性不可分意味着某些样本点不能满足函数间隔大于等于1的约束条件。为了解决这个问题，我们对每个样本点引入一个松弛变量$\xi_i \geq 0 $;</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128161204.png" alt=""></p>
<h2 id="2-1-对偶算法"><a href="#2-1-对偶算法" class="headerlink" title="2.1 对偶算法"></a>2.1 对偶算法</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128161413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128161533.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128161736.png" alt=""></p>
<h2 id="2-2-支持向量"><a href="#2-2-支持向量" class="headerlink" title="2.2 支持向量"></a>2.2 支持向量</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128162117.png" alt=""></p>
<h1 id="SVM实战（SMO高效优化算法）"><a href="#SVM实战（SMO高效优化算法）" class="headerlink" title="SVM实战（SMO高效优化算法）"></a>SVM实战（SMO高效优化算法）</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191128162557.png" alt=""></p>
<p>  SMO算法的目标是求出一系列$\alpha$和b，一旦求出了这些$\alpha$，就很容易计算出权重向量w并得到分隔超平面。  </p>
<p>  SMO算法的工作原理是：每次循环中选择两个$\alpha$进行优化处理。一旦找到一对合适的<br>$\alpha$，那么就增大其中一个同时减小另一个。这里所谓的“合适”就是指两个$\alpha$必须要符合<br>一定的条件，条件之一就是这两个$\alpha$必须要在间隔边界之外，而其第二个条件则是这两个$\alpha$<br>还没有进行过区间化处理或者不在边界上。  </p>
<p>  首先在数据集上遍历每一个$\alpha$，然后在剩下的$\alpha$集合中随机选择另一个$\alpha$，从而构建$\alpha$对。这里有一点相当重要，就是我们要同时改变两个$\alpha$。之所以这样做是因为我们有一个约束条件：  $\Sigma\alpha_i\cdot y_i= 0$</p>
<p>所以当我们改变一个$\alpha$值时，为了约束条件的成立，必须再改变一个。</p>
<p>  为此，我们将构建一个辅助函数，用于在某个区间范围内随机选择一个整数。同时，我们也需要另一个辅助函数，用于在数值太大时对其进行调整。下面的程序清单给出了这两个函数的实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    <span class="string">"""加载数据"""</span></span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        dataMat.append([float(lineArr[<span class="number">0</span>]), float(lineArr[<span class="number">1</span>])])</span><br><span class="line">        labelMat.append(float(lineArr[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat,labelMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJrand</span><span class="params">(i,m)</span>:</span></span><br><span class="line">    <span class="string">"""随机选取另一个alpha"""</span></span><br><span class="line">    j=i <span class="comment">#we want to select any J not equal to i</span></span><br><span class="line">    <span class="keyword">while</span> (j==i):</span><br><span class="line">        j = int(random.uniform(<span class="number">0</span>,m))</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clipAlpha</span><span class="params">(aj,H,L)</span>:</span></span><br><span class="line">    <span class="string">"""调整alpha的值"""</span></span><br><span class="line">    <span class="keyword">if</span> aj &gt; H: </span><br><span class="line">        aj = H</span><br><span class="line">    <span class="keyword">if</span> L &gt; aj:</span><br><span class="line">        aj = L</span><br><span class="line">    <span class="keyword">return</span> aj</span><br></pre></td></tr></table></figure>



<p>SMO算法程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoSimple</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    dataMatin - 数据集</span></span><br><span class="line"><span class="string">    classLabels - 类别标签</span></span><br><span class="line"><span class="string">    C - 常数C</span></span><br><span class="line"><span class="string">    toler - 容错率</span></span><br><span class="line"><span class="string">    maxIter - 退出最大循环次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()</span><br><span class="line">    b = <span class="number">0</span>; m,n = shape(dataMatrix)</span><br><span class="line">    alphas = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (iter &lt; maxIter):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span>  <span class="comment"># 用于记录alpha是否已经进行优化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b    <span class="comment"># 预测类别</span></span><br><span class="line">            Ei = fXi - float(labelMat[i])<span class="comment">#if checks if an example violates KKT conditions  计算误差</span></span><br><span class="line">            <span class="keyword">if</span> ((labelMat[i]*Ei &lt; -toler) <span class="keyword">and</span> (alphas[i] &lt; C)) <span class="keyword">or</span> ((labelMat[i]*Ei &gt; toler) <span class="keyword">and</span> (alphas[i] &gt; <span class="number">0</span>)):     <span class="comment"># 如果误差过大</span></span><br><span class="line">                j = selectJrand(i,m)  <span class="comment"># 选取第二个alpha值</span></span><br><span class="line">                fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b  <span class="comment"># 计算j的类别</span></span><br><span class="line">                Ej = fXj - float(labelMat[j])</span><br><span class="line">                alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();</span><br><span class="line">                <span class="keyword">if</span> (labelMat[i] != labelMat[j]):  </span><br><span class="line">                    L = max(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">                    H = min(C, C + alphas[j] - alphas[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = max(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">                    H = min(C, alphas[j] + alphas[i])</span><br><span class="line">                <span class="keyword">if</span> L==H: <span class="keyword">print</span> <span class="string">"L==H"</span>; <span class="keyword">continue</span></span><br><span class="line">                eta = <span class="number">2.0</span> * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: <span class="keyword">print</span> <span class="string">"eta&gt;=0"</span>; <span class="keyword">continue</span></span><br><span class="line">                alphas[j] -= labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">                alphas[j] = clipAlpha(alphas[j],H,L)</span><br><span class="line">                <span class="keyword">if</span> (abs(alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): <span class="keyword">print</span> <span class="string">"j not moving enough"</span>; <span class="keyword">continue</span></span><br><span class="line">                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">                                                                        <span class="comment">#the update is in the oppostie direction</span></span><br><span class="line">                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T</span><br><span class="line">                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; alphas[i]) <span class="keyword">and</span> (C &gt; alphas[i]): b = b1</span><br><span class="line">                <span class="keyword">elif</span> (<span class="number">0</span> &lt; alphas[j]) <span class="keyword">and</span> (C &gt; alphas[j]): b = b2</span><br><span class="line">                <span class="keyword">else</span>: b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">                alphaPairsChanged += <span class="number">1</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"iter: %d i:%d, pairs changed %d"</span> % (iter,i,alphaPairsChanged)</span><br><span class="line">        <span class="keyword">if</span> (alphaPairsChanged == <span class="number">0</span>): iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: iter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"iteration number: %d"</span> % iter</span><br><span class="line">    <span class="keyword">return</span> b,alphas</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup 特殊的质数肋骨</title>
    <url>/jontyhuang.github.io/2019/11/25/blue-cup-%E7%89%B9%E6%AE%8A%E7%9A%84%E8%B4%A8%E6%95%B0%E8%82%8B%E9%AA%A8/</url>
    <content><![CDATA[<p>11.25<br>问题描述<br>农民约翰母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。<br>例如有四根肋骨的数字分别是：7 3 3 1，那么全部肋骨上的数字 7331是质数；三根肋骨 733是质数；二根肋骨 73 是质数；当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。<br>写一个程序对给定的肋骨的数目 N (1&lt;=N&lt;=8),求出所有的特殊质数。数字1不被看作一个质数。<br>输入格式<br>单独的一行包含N。<br>输出格式<br>按顺序输出长度为 N 的特殊质数,每行一个。<br>样例输入<br>4<br>样例输出<br> 2333<br> 2339<br> 2393<br> 2399<br> 2939<br> 3119<br> 3137<br> 3733<br> 3739<br> 3793<br> 3797<br> 5939<br> 7193<br> 7331<br> 7333<br> 7393</p>
<a id="more"></a>

<h1 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h1><ul>
<li>第一个，我们在拿到这个题目的时候，肯定思考的遍历所有的n位数，去判断它是不是特殊质数。这个思路是完全正确的，但是这种暴力的解法肯定存在时间超出的问题。那么我们是不是去思考有没有方法让我们减少遍历的次数呢？答案肯定是有的。</li>
<li>从题目出发，题目要求n位数的每位都是质数且每个高位的组合也是质数。所以我们从高位去遍历，当这个数不是质数肯定不符合题目的要求，如果符合要求，那么就将这个数乘以10，继续遍历以它位高位构造的数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.x500.X500Principal;</span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.HTMLReader.IsindexAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String S1;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is</span><span class="params">(<span class="keyword">int</span> num)</span>    <span class="comment">// 判断num是否为质数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span> || num ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>;i * i &lt;= num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(num % i == <span class="number">0</span> )<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span>  level)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(level == n)&#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(is(num * <span class="number">10</span> +i))</span><br><span class="line">				&#123;</span><br><span class="line">					fun(num*<span class="number">10</span>+i, level + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		n = in.nextInt();     <span class="comment">// 获取质数的长度</span></span><br><span class="line">		fun(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup 现代诗如蚯</title>
    <url>/jontyhuang.github.io/2019/11/24/blue-cup-%E7%8E%B0%E4%BB%A3%E8%AF%97%E5%A6%82%E8%9A%AF/</url>
    <content><![CDATA[<p>问题描述<br>现代诗如蚯 断成好几截都不会死 字符串断成好几截 有可能完全一样 请编写程序 输入字符串 输出该字符串最多能断成多少截完全一样的子串<br>输入格式<br>一行，一个字符串<br>输出格式<br>一行，一个正整数表示该字符串最多能断成的截数<br>样例输入<br>abcabcabcabc<br>样例输出<br>4<br>样例说明<br>最多能断成四个”abc”，也就是abc重复四遍便是原串<br>同时也能断成两个”abcabc”<br>最坏情况是断成一个原串”abcabcabcabc”<br>数据规模和约定<br>字符串长度&lt;=1000</p>
<a id="more"></a>

<h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><p>每次以分组数进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String S1;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		S1 = in.next();   </span><br><span class="line">		<span class="keyword">int</span> len= S1.length();</span><br><span class="line">		<span class="keyword">int</span> x =<span class="number">2</span>;   <span class="comment">// 记录被分为的组数</span></span><br><span class="line">		<span class="keyword">int</span> max_x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;x&lt;=len;x++)&#123;</span><br><span class="line">			<span class="keyword">int</span> num = len /x;</span><br><span class="line">			<span class="keyword">if</span> (len%x ==<span class="number">0</span>)&#123;   <span class="comment">// 字符串可被整除</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len -num;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(S1.charAt(i) != S1.charAt(i+num))</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">if</span>(i == len -num -<span class="number">1</span>)</span><br><span class="line">						 max_x = x;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	System.out.print(max_x);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>每次以分组的字符串大小进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String S1;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		S1 = in.next();   </span><br><span class="line">		<span class="keyword">int</span> len= S1.length();</span><br><span class="line">		<span class="keyword">int</span> max_x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;len/<span class="number">2</span>;i++)&#123;<span class="comment">//i是一组字符串的长度</span></span><br><span class="line">			<span class="keyword">if</span>(len%i != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			String t1 = S1.substring(<span class="number">0</span>,i);</span><br><span class="line">			String t2;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;len;j=j+i)&#123;</span><br><span class="line">				t2 = S1.substring(j,j+i);</span><br><span class="line">				<span class="keyword">if</span>(t1.equals(t2) == <span class="keyword">false</span>)  <span class="comment">//使用equal去判断，因为字符串是值类型</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(j == len - i)</span><br><span class="line">				&#123;</span><br><span class="line">					max_x = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(max_x != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	System.out.print(len / max_x);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup 分分钟的碎碎念</title>
    <url>/jontyhuang.github.io/2019/11/24/blue-cup-%E5%88%86%E5%88%86%E9%92%9F%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>11.24<br>蓝桥杯 adv156 分分钟的碎碎念<br>问题描述<br>以前有个孩子，他分分钟都在碎碎念。不过，他的念头之间是有因果关系的。他会在本子里记录每一个念头，并用箭头画出这个念头的来源于之前的哪一个念头。翻开这个本子，你一定会被互相穿梭的箭头给搅晕，现在他希望你用程序计算出这些念头中最长的一条因果链。<br>将念头从1到n编号，念头i来源于念头from[i]，保证from[i]&lt;i，from[i]=0表示该念头没有来源念头，只是脑袋一抽，灵光一现。<br>输入格式<br>第一行一个正整数n表示念头的数量<br>接下来n行依次给出from[1]，from[2]，…，from[n]<br>输出格式<br>共一行，一个正整数L表示最长的念头因果链中的念头数量<br>样例输入<br>8<br>0<br>1<br>0<br>3<br>2<br>4<br>2<br>4</p>
<p>样例输出<br>3<br>样例说明<br>最长的因果链有： 1-&gt;2-&gt;5 (from[5]=2,from[2]=1,from[1]=0) 1-&gt;2-&gt;7 (from[7]=2,from[2]=1,from[1]=0) 3-&gt;4-&gt;6 (from[6]=4,from[4]=3,from[3]=0) 3-&gt;4-&gt;8 (from[8]=4,from[4]=3,from[3]=0)<br>数据规模和约定<br>字符串长度&lt;=1000</p>
<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>使用递归去不断寻找一个念头的果念头，但是我们需要定义一个static类型的变量去存储最大的念头书 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> cnt)</span></span>&#123;  <span class="comment">//寻找m是哪些的源头。cnt记录念头数量</span></span><br><span class="line">		<span class="keyword">int</span> s;</span><br><span class="line">		<span class="keyword">for</span>(s = <span class="number">1</span>;s&lt;=n;s++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[s]==m)&#123;  <span class="comment">// 如果成立说明m是s的源头，一开始m为0，说明我们第一步寻找的源念头，不断递归寻找念头的果念头</span></span><br><span class="line">				fun(s, cnt+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s == n +<span class="number">1</span>)&#123;</span><br><span class="line">			sum = Math.max(sum, cnt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		n = in.nextInt();   <span class="comment">//n个数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">			ans[i] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fun(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		System.out.print(sum);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>使用迭代去不断寻找源头，知道ans[i] = i或者ans[i] = 0停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>   n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);   <span class="comment">//数据整理</span></span><br><span class="line">		n = in.nextInt();   <span class="comment">//n个数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">			ans[i] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = ans[i];   <span class="comment">// i为为念头，cnt为前趋念头</span></span><br><span class="line">			 <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 num =<span class="number">1</span>;   <span class="comment">//这个思路只存在念头i 和cnt</span></span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span>&#123;</span><br><span class="line">				 num =<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">while</span> (ans[cnt] !=<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(cnt == ans[cnt])</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">						cnt = ans[cnt]; <span class="comment">//寻找cnt的前趋念头</span></span><br><span class="line">						num++;</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			 sum = Math.max(sum, num);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.print(sum);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning Naive Bayes</title>
    <url>/jontyhuang.github.io/2019/11/21/machine-learning-Naive-Bayes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191121105241.png" alt=""></p>
<a id="more"></a>

<h1 id="1-贝叶斯决策"><a href="#1-贝叶斯决策" class="headerlink" title="1. 贝叶斯决策"></a>1. 贝叶斯决策</h1><h2 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h2><p>我们现在用p1(x,y)表示数据点(x,y)属于类别1的概率，用p2(x,y)表示数据点(x,y)属于类别2的概率，<br>那么对于一个新数据点(x,y)，可以用下面的规则来判断它的类别：<br> 如果 p1(x,y) &gt; p2(x,y)，那么类别为1。<br> 如果 p2(x,y) &gt; p1(x,y)，那么类别为2。  </p>
<p>应用贝叶斯准则得到：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191121105859.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191121105923.png" alt=""></p>
<p>朴素贝叶斯朴素之处：特征之间相互独立。</p>
<p>同时还有一个重要假设：每个特征同等重要</p>
<p>贝叶斯模型通常有两种实现方式，一种是贝努利模型，一种是基于多项式模型的实现。本文实现第一种算法。</p>
<h1 id="2-使用朴素贝叶斯进行l留言分类"><a href="#2-使用朴素贝叶斯进行l留言分类" class="headerlink" title="2. 使用朴素贝叶斯进行l留言分类"></a>2. 使用朴素贝叶斯进行l留言分类</h1><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191121110226284.png" alt="image-20191121110226284"></p>
<h2 id="2-1-使用python进行分类"><a href="#2-1-使用python进行分类" class="headerlink" title="2.1  使用python进行分类"></a>2.1  使用python进行分类</h2><p>  要从文本中获取特征，需要先拆分文本。具体如何做呢？这里的特征是来自文本的词条<br>（token），一个词条是字符的任意组合。可以把词条想象为单词，也可以使用非单词词条，如URL、IP地址或者任意其他字符串。然后将每一个文本片段表示为一个词条向量，其中值为1表示词条出现在文档中， 0表示词条未出现。<br>    以在线社区的留言板为例。为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的语言，那么就将该留言标识为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类别：侮辱类和非侮辱类，使用1和0分别表示。</p>
<p>​    接下来首先给出将文本转换为数字向量的过程，然后介绍如何基于这些向量来计算条件概率，并在此基础上构建分类器，最后还要介绍一些利用Python实现朴素贝叶斯过程中需要考虑的问题。  </p>
<h2 id="2-2-准备数据：-从文本中构建词向量"><a href="#2-2-准备数据：-从文本中构建词向量" class="headerlink" title="2.2 准备数据： 从文本中构建词向量"></a>2.2 准备数据： 从文本中构建词向量</h2><p>我们将文本转为单词向量或者词条向量。</p>
<p>考虑出现在所有文档中的所有单词，再决定将哪些词纳入词汇表或者说所要的词汇集合，然后必须要将每一篇文档转换为词汇表上的向量。接下来我们正式开始。  </p>
<p>将词表转为向量的转换函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""创建实验样本"""</span>    </span><br><span class="line">    postingList=[[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">                 [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">                 [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                 [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]    <span class="comment">#1 is abusive, 0 not</span></span><br><span class="line">    <span class="keyword">return</span> postingList,classVec</span><br><span class="line">                 </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取所有单词的集合</span></span><br><span class="line"><span class="string">    :param data_set: 数据集</span></span><br><span class="line"><span class="string">    :return: 所有单词的集合(即不含重复元素的单词列表)    </span></span><br><span class="line"><span class="string">        """</span>    </span><br><span class="line">    vocabSet = set([])  <span class="comment">#create empty set</span></span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | set(document) <span class="comment">#union of the two sets</span></span><br><span class="line">    <span class="keyword">return</span> list(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历查看该单词是否出现，出现该单词则将该单词置1</span></span><br><span class="line"><span class="string">    :param vocab_list: 所有单词集合列表</span></span><br><span class="line"><span class="string">    :param input_set: 输入数据集</span></span><br><span class="line"><span class="string">    :return: 匹配列表[0,1,0,1...]，其中 1与0 表示词汇表中的单词是否出现在输入的数据集中    </span></span><br><span class="line"><span class="string">        """</span>    </span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: print(<span class="string">"the word: %s is not in my Vocabulary!"</span> % word)</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191122235049.png" alt=""></p>
<p>返回的列表不存在重复的单词。我们还可以对词表进行排序。</p>
<p>返回的列表不存在重复的单词。我们还可以对词表进行排序。</p>
<h2 id="2-3-训练算法：从词向量计算概率"><a href="#2-3-训练算法：从词向量计算概率" class="headerlink" title="2.3 训练算法：从词向量计算概率"></a>2.3 训练算法：从词向量计算概率</h2><p>前面我们将一组单词转为了一组数字，接下来如果将这些数字转为概率。</p>
<p>这里的贝叶斯公式如下。将之前的x,y 用w替换了。w就是一个向量</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191122235428.png" alt=""></p>
<p>  我们将使用上述公式，对每个类计算该值，然后比较这两个概率值的大小。如何计算呢？首先可以通过类别i（侮辱性留言或非侮辱性留言）中文档数除以总的文档数来计算概率p(ci)。接下来计算$p(w|c_i)$，这里就要用到朴素贝叶斯假设。如果将w展开为一个个独立征，那么就可以将上述概率写作$p(w_0,w_1,w_2..w_N|c_i)$。这里假设所有词都互相独立，该假设也称作条件独立性假设，它意味着可以使用$p(w_0|c_i)p(w_1|c_i)p(w_2|c_i)…p(w_N|c_i)$来计算上述概率，<strong>同时在分类时，分母$p(w)$是一样的，所以实际计算过程中，这个量并不需要计算</strong>,这就极大地简化了计算的过程。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191122235833.png" alt=""></p>
<p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">     :param trainMatrix:  type is ndarray</span></span><br><span class="line"><span class="string">                    总的输入文本，大致是 [[0,1,0,1], [], []]</span></span><br><span class="line"><span class="string">    :param trainCategory: 文件对应的类别分类， [0, 1, 0],</span></span><br><span class="line"><span class="string">                            列表的长度应该等于上面那个输入文本的长度</span></span><br><span class="line"><span class="string">    :return:     </span></span><br><span class="line"><span class="string">        """</span>            </span><br><span class="line">    numTrainDocs = len(trainMatrix)  <span class="comment"># 记录文章数</span></span><br><span class="line">    numWords = len(trainMatrix[<span class="number">0</span>])  <span class="comment"># 记录单词数</span></span><br><span class="line">    pAbusive = sum(trainCategory)/float(numTrainDocs) <span class="comment"># 计算出现侮辱性文件出现的概率</span></span><br><span class="line">    p0Num = zeros(numWords); p1Num = zeros(numWords)      <span class="comment">#change to ones() </span></span><br><span class="line">    p0Denom = <span class="number">0.0</span>; p1Denom = <span class="number">0.0</span>                        <span class="comment">#change to 2.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):   <span class="comment"># 遍历训练文件</span></span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:  <span class="comment"># 如果是侮辱性文件，就计算此侮辱性文件中出现的侮辱性单词的个数</span></span><br><span class="line">            p1Num += trainMatrix[i]     </span><br><span class="line">            p1Denom += sum(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += sum(trainMatrix[i])</span><br><span class="line">    p1Vect = log(p1Num/p1Denom)          <span class="comment"># change to log()</span></span><br><span class="line">    p0Vect = log(p0Num/p0Denom)          <span class="comment">#change to log()</span></span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</span><br></pre></td></tr></table></figure>

<p>  计算$p(w_i|c_1)$和$p(w_i|c_0)$，需要初始化程序中的分子变量和分母变量 。由于w中元素如此<br>众多，因此可以使用NumPy数组快速计算这些值。上述程序中的分母变量是一个元素个数等于词汇表大小的NumPy数组。在for循环中，要遍历训练集trainMatrix中的所有文档。一旦某个词语（侮辱性或正常词语）在某一文档中出现，则该词对应的个数（p1Num或者p0Num）就加1，而且在所有的文档中，该文档的总词数也相应加1 。对于两个类别都要进行同样的计算处理。<br>  最后，对每个元素除以该类别中的总词数 。利用NumPy可以很好实现，用一个数组除以浮<br>点数即可，若使用常规的Python列表则难以完成这种任务，读者可以自己尝试一下。最后，函数会返回两个向量和一个概率。  </p>
<h2 id="2-4-优化贝叶斯模型"><a href="#2-4-优化贝叶斯模型" class="headerlink" title="2.4 优化贝叶斯模型"></a>2.4 优化贝叶斯模型</h2><p>利用贝叶斯分类器进行文档分类时，要计算多个概率的乘积以获得文档属于某个类别的概率,即$p(w_0|1)p(w_1|1)p(w_2|1)$,如果其中一个概率值为0，那么最后的乘积也为0。为降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。</p>
<p>因此我们将trainNB0()的第四行和第五行进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p0Num = ones(numWords); p1Num = ones(numWords)      <span class="comment">#change to ones() </span></span><br><span class="line">    p0Denom = <span class="number">2.0</span>; p1Denom = <span class="number">2.0</span>                        <span class="comment">#change to 2.0</span></span><br></pre></td></tr></table></figure>

<p>  另一个问题就是下溢出，这是由于太多很小的数相乘造成的。当计算乘积<br>$p(w_0|c_i)p(w_1|c_i)p(w_2|c_i)…p(w_N|c_i)$时，由于大部分因子都非常小，所以程序会下溢出或者得到不正确的答案。（读者可以用Python尝试相乘许多很小的数，最后四舍五入后会得到0。）一种解决办法是对乘积取自然对数。在代数中有ln(a*b) = ln(a)+ln(b)，于是通过求对数可以避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。图4-4给出函数f(x)与ln(f(x))的曲线。检查这两条曲线，就会发现它们在相同区域内同时增加或者减少，并且在相同点上取到极值。它们的取值虽然不同，但不影响最终结果。通过修改return前的两行代码，将上述做法用到分类器中  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1Vect = log(p1Num/p1Denom)          <span class="comment">#change to log()</span></span><br><span class="line">p0Vect = log(p0Num/p0Denom)          <span class="comment">#change to log()</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191123072555.png" alt=""></p>
<p>分类程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">    p1 = sum(vec2Classify * p1Vec) + log(pClass1)    <span class="comment">#element-wise mult</span></span><br><span class="line">    p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    print(testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb))</span><br><span class="line">    testEntry = [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    print(testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb))</span><br></pre></td></tr></table></figure>

<h2 id="2-5-准备词袋模型"><a href="#2-5-准备词袋模型" class="headerlink" title="2.5 准备词袋模型"></a>2.5 准备词袋模型</h2><p>  目前为止，我们将每个词的出现与否作为一个特征，这可以被描述为词集模型（set-of-words model）。如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某种信息，这种方法被称为词袋模型（bag-of-words model）。在词袋中，每个单词可以出现多次，而在词集中，每个词只能出现一次。为适应词袋模型，需要对函数setOfWords2Vec()稍加修改，修改后的函数称为bagOfWords2Vec()。  </p>
<p>程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>





<h1 id="3-使用朴素贝叶斯过滤垃圾邮件"><a href="#3-使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="3. 使用朴素贝叶斯过滤垃圾邮件"></a>3. 使用朴素贝叶斯过滤垃圾邮件</h1><p>  使用朴素贝叶斯解决一些现实生活中的问题时，需要先从文本内容得到字符串列表，然后生成词向量。下面这个例子中，我们将了解朴素贝叶斯的一个最著名的应用：电子邮件垃圾过滤。  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191123090254.png" alt=""></p>
<h2 id="3-1-准备数据：切割文本"><a href="#3-1-准备数据：切割文本" class="headerlink" title="3.1 准备数据：切割文本"></a>3.1 准备数据：切割文本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span>    <span class="comment">#input is big string, #output is word list</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    listOfTokens = re.split(<span class="string">r'\W*'</span>, bigString)</span><br><span class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>] </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    <span class="string">"""创建词袋模型"""</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">    docList=[]; classList = []; fullText =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            wordList = textParse(open(<span class="string">'E:/lsgo-machine-learning/machinelearninginaction/Ch04/email/spam/&#123;&#125;.txt'</span>.format(i)).read())</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            wordList = textParse(open(<span class="string">'E:/lsgo-machine-learning/machinelearninginaction/Ch04/email/spam/&#123;&#125;.txt'</span>.format(i), encoding=<span class="string">'Windows 1252'</span>).read())</span><br><span class="line">    </span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            wordList = textParse(open(<span class="string">'E:/lsgo-machine-learning/machinelearninginaction/Ch04/email/spam/&#123;&#125;.txt'</span>.format(i)).read())</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            wordList = textParse(open(<span class="string">'E:/lsgo-machine-learning/machinelearninginaction/Ch04/email/spam/&#123;&#125;.txt'</span>.format(i), encoding=<span class="string">'Windows 1252'</span>).read())</span><br><span class="line">    </span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabList(docList)<span class="comment">#create vocabulary，创建单词集合</span></span><br><span class="line">    trainingSet = list(range(<span class="number">50</span>)); testSet=[]           <span class="comment">#create test set</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 选出十个文档作为测试集</span></span><br><span class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span>(trainingSet[randIndex])  </span><br><span class="line">    trainMat=[]; trainClasses = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:<span class="comment">#train the classifier (get probs) trainNB0</span></span><br><span class="line">        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))  <span class="comment"># 创建词袋</span></span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses))  <span class="comment"># 训练模型</span></span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:        <span class="comment">#classify the remaining items</span></span><br><span class="line">        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])   <span class="comment"># 创建词向量</span></span><br><span class="line">        <span class="keyword">if</span> classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">            print(<span class="string">"classification error"</span>,docList[docIndex])</span><br><span class="line">    print(<span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet))</span><br><span class="line">    <span class="comment">#return vocabList,fullText</span></span><br><span class="line">spamTest()</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning decision-making tree</title>
    <url>/jontyhuang.github.io/2019/11/16/machine-learning-decision-making-tree/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="1-使用ID3算法构造策树"><a href="#1-使用ID3算法构造策树" class="headerlink" title="1. 使用ID3算法构造策树"></a>1. 使用ID3算法构造策树<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117000649.png" alt=""></h2><a id="more"></a>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117000632.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117000745.png" alt=""></p>
<h3 id="1-1-信息熵（平均信息量）"><a href="#1-1-信息熵（平均信息量）" class="headerlink" title="1.1 信息熵（平均信息量）"></a>1.1 信息熵（平均信息量）</h3><p>  划分数据集的大原则是：将无序的数据变得更加有序。我们可以使用多种方法划分数据集，但是每种方法都有各自的优缺点。组织杂乱无章数据的一种方法就是使用信息论度量信息，信息论是量化处理信息的分支科学。我们可以在划分数据之前或之后使用信息论量化度量信息的内容。<br> 在划分数据集之前之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。<br>在可以评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵，这个名字来源于信息论之父克劳德·香农。  </p>
<p>  熵定义为信息的期望值，在明晰这个概念之前，我们必须知道信息的定义。如果待分类的事务可能划分在多个分类之中，则符号$x_i$的信息定义为<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117001102.png" alt=""><br>其中p(xi)是选择该分类的概率。  </p>
<p>  为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式得到：  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117001159.png" alt=""></p>
<p>  其中n是分类的数目。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""计算信息熵"""</span></span><br><span class="line">    numEntries = len(dataSet)</span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet: <span class="comment">#the the number of unique elements and their occurance</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = float(labelCounts[key])/numEntries  <span class="comment"># 计算概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>) <span class="comment">#log base 2</span></span><br><span class="line">      <span class="comment"># # -----------计算香农熵的第二种实现方式start--------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># # 统计标签出现的次数</span></span><br><span class="line">    <span class="comment"># label_count = Counter(data[-1] for data in dataSet)</span></span><br><span class="line">    <span class="comment"># # 计算概率</span></span><br><span class="line">    <span class="comment"># probs = [p[1] / len(dataSet) for p in label_count.items()]</span></span><br><span class="line">    <span class="comment"># # 计算香农熵</span></span><br><span class="line">    <span class="comment"># shannonEnt = sum([-p * log(p, 2) for p in probs])</span></span><br><span class="line">    <span class="comment"># # -----------计算香农熵的第二种实现方式end--------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>

<p>制作数据集，并计算信息熵</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117084409.png" alt=""></p>
<p>  熵越高，则混合的数据也越多，我们可以在数据集中添加更多的分类，观察熵是如何变化的。这里我们增加第三个名为maybe的分类，测试熵的变化：  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117001944.png" alt=""></p>
<p>  得到熵之后，我们就可以按照获取最大信息增益的方法划分数据集，下一节我们将具体学习如何划分数据集以及如何度量信息增益  </p>
<p>  另一个度量集合无序程度的方法是基尼不纯度（Gini impurity），简单地说就是从一个数据集中随机选取子项，度量其被错误分类到其他分组里的概率。本书不采用基尼不纯度方法，这里就不再做进一步的介绍。下面我们将学习如何划分数据集，并创建决策树。  </p>
<h3 id="1-2-划分数据集"><a href="#1-2-划分数据集" class="headerlink" title="1.2 划分数据集"></a>1.2 划分数据集</h3><p>  上节我们学习了如何度量数据集的无序程度，分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以便判断当前是否正确地划分了数据集。我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式。想象一个分布在二维空间的数据散点图，需要在数据之间划条线，将它们分成两部分，我们应该按照x轴还是y轴划线呢？答案就是本节讲述的内容  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    <span class="string">"""dataSet 带划分数据集</span></span><br><span class="line"><span class="string">    	axis 划分数据集的特征</span></span><br><span class="line"><span class="string">    	value 需要返回的特征的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]     <span class="comment">#chop out axis used for splitting</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">     <span class="comment"># # -----------切分数据集的第二种方式 start------------------------------------</span></span><br><span class="line">    <span class="comment"># retDataSet = [data[:index] + data[index + 1:] for data in dataSet for i, v in enumerate(data) if i == index and v == value]</span></span><br><span class="line">    <span class="comment"># # -----------切分数据集的第二种方式 end------------------------------------</span></span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117003209.png" alt=""></p>
<p>  接下来我们将遍历整个数据集，循环计算香农熵和splitDataSet()函数，找到最好的特征划分方式。熵计算将会告诉我们如何划分数据集是最好的数据组织方式。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""选择最好的数据集划分方式"""</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>      <span class="comment">#the last column is used for the labels</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算初始信息熵</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):        <span class="comment">#iterate over all the features</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]<span class="comment">#create a list of all the examples of this feature</span></span><br><span class="line">        uniqueVals = set(featList)       <span class="comment">#get a set of unique values</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)    <span class="comment"># 得到划分后的数据集</span></span><br><span class="line">            prob = len(subDataSet)/float(len(dataSet))    <span class="comment"># 计算划分后数据集的概率</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)     <span class="comment"># 计算信息熵</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy     <span class="comment">#calculate the info gain; ie reduction in entropy</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):       <span class="comment">#compare this to the best gain so far</span></span><br><span class="line">            bestInfoGain = infoGain         <span class="comment">#if better than current best, set to best</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature                      <span class="comment">#returns an integer</span></span><br></pre></td></tr></table></figure>

<p>  遍历当前特征中的所有唯一属性值，对每个特征划分一次数据集 ，然后计算数据集的新熵值，并对所有唯一特征值得到的熵求和。信息增益是熵的减少或者是数据无序度的减少，大家肯定对于将熵用于度量数据无序度的减少更容易理解。最后，比较所有特征中的信息增益，返回最好特征划分的索引值 。  </p>
<h3 id="1-3构建决策树"><a href="#1-3构建决策树" class="headerlink" title="1.3构建决策树"></a>1.3构建决策树</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">     <span class="string">"""</span></span><br><span class="line"><span class="string">    Desc:</span></span><br><span class="line"><span class="string">        选择出现次数最多的一个结果</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        classList label列的集合</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bestFeature 最优的特征列</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">     <span class="comment"># 倒叙排列classCount得到一个字典集合，然后取出第一个就是结果（yes/no），即出现次数最多的结果</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">     <span class="comment"># # -----------majorityCnt的第二种方式 start------------------------------------</span></span><br><span class="line">    <span class="comment"># major_label = Counter(classList).most_common(1)[0]</span></span><br><span class="line">    <span class="comment"># return major_label</span></span><br><span class="line">    <span class="comment"># # -----------majorityCnt的第二种方式 end------------------------------------</span></span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Desc:</span></span><br><span class="line"><span class="string">        创建决策树</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataSet -- 要创建决策树的训练数据集</span></span><br><span class="line"><span class="string">        labels -- 训练数据集中特征对应的含义的labels，不是目标变量</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        myTree -- 创建完成的决策树</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 如果数据集的最后一列的第一个值出现的次数=整个集合的数量，也就说只有一个类别，就只直接返回结果就行</span></span><br><span class="line">    <span class="comment"># 第一个停止条件：所有的类标签完全相同，则直接返回该类标签。</span></span><br><span class="line">    <span class="comment"># count() 函数是统计括号中的值在list中出现的次数</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果数据集只有1列，那么最初出现label次数最多的一类，作为结果</span></span><br><span class="line">    <span class="comment"># 第二个停止条件：使用完了所有特征，仍然不能将数据集划分成仅包含唯一类别的分组。</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择最优的列，得到最优列对应的label含义</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 获取label的名称</span></span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    <span class="comment"># 初始化myTree</span></span><br><span class="line">    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="comment"># 注：labels列表是可变对象，在PYTHON函数中作为参数时传址引用，能够被全局修改</span></span><br><span class="line">    <span class="comment"># 所以这行代码导致函数外的同名变量被删除了元素，造成例句无法执行，提示'no surfacing' is not in list</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 取出最优列，然后它的branch做分类</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = set(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        <span class="comment"># 求出剩余的标签label</span></span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        <span class="comment"># 遍历当前选择特征包含的所有属性值，在每个数据集划分上递归调用函数createTree()</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line">        <span class="comment"># print('myTree', value, myTree)</span></span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117084341.png" alt=""></p>
<h2 id="2-决策树分类"><a href="#2-决策树分类" class="headerlink" title="2.决策树分类"></a>2.决策树分类</h2><p>  依靠训练数据构造了决策树之后，我们可以将它用于实际数据的分类。在执行数据分类时，需要决策树以及用于构造树的标签向量。然后，程序比较测试数据与决策树上的数值，递归执行该过程直到进入叶子节点；最后将测试数据定义为叶子节点所属的类型。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree, featLabels, testVec)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Desc:</span></span><br><span class="line"><span class="string">        对新数据进行分类</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        inputTree  -- 已经训练好的决策树模型</span></span><br><span class="line"><span class="string">        featLabels -- Feature标签对应的名称，不是目标变量</span></span><br><span class="line"><span class="string">        testVec    -- 测试输入的数据</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        classLabel -- 分类的结果值，需要映射label才能知道名称</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取tree的根节点对于的key值</span></span><br><span class="line">    firstStr = list(inputTree.keys())[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 通过key得到根节点对应的value</span></span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    <span class="comment"># 判断根节点名称获取根节点在label中的先后顺序，这样就知道输入的testVec怎么开始对照树来做分类</span></span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line">    <span class="comment"># 测试数据，找到根节点对应的label位置，也就知道从输入的数据的第几位来开始分类</span></span><br><span class="line">    key = testVec[featIndex]</span><br><span class="line">    valueOfFeat = secondDict[key]</span><br><span class="line">    print(<span class="string">'+++'</span>, firstStr, <span class="string">'xxx'</span>, secondDict, <span class="string">'---'</span>, key, <span class="string">'&gt;&gt;&gt;'</span>, valueOfFeat)</span><br><span class="line">    <span class="comment"># 判断分枝是否结束: 判断valueOfFeat是否是dict类型</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(valueOfFeat, dict):</span><br><span class="line">        classLabel = classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        classLabel = valueOfFeat</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117084732.png" alt=""></p>
<h2 id="3-决策树的存储"><a href="#3-决策树的存储" class="headerlink" title="3.决策树的存储"></a>3.决策树的存储</h2><p>将决策树存储起来，以便下次直接调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree, filename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Desc:</span></span><br><span class="line"><span class="string">        将之前训练好的决策树模型存储起来，使用 pickle 模块</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        inputTree -- 以前训练好的决策树模型</span></span><br><span class="line"><span class="string">        filename -- 要存储的名称</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="comment"># -------------- 第一种方法 start --------------</span></span><br><span class="line">    fw = open(filename, <span class="string">'wb'</span>)</span><br><span class="line">    pickle.dump(inputTree, fw)</span><br><span class="line">    fw.close()</span><br><span class="line">    <span class="comment"># -------------- 第一种方法 end --------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -------------- 第二种方法 start --------------</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        pickle.dump(inputTree, fw)</span><br><span class="line">    <span class="comment"># -------------- 第二种方法 start --------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Desc:</span></span><br><span class="line"><span class="string">        将之前存储的决策树模型使用 pickle 模块 还原出来</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        filename -- 之前存储决策树模型的文件名</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        pickle.load(fr) -- 将之前存储的决策树模型还原出来</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fr = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>





<h1 id="实例：使用决策树预测隐形眼镜类型"><a href="#实例：使用决策树预测隐形眼镜类型" class="headerlink" title="实例：使用决策树预测隐形眼镜类型"></a>实例：使用决策树预测隐形眼镜类型</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117085930.png" alt=""></p>
<p>我们发现决策树的匹配项过多，这叫做过度匹配，为了解决这一问题，我们可以去掉一些不必要的叶子结点。</p>
<p>  ID3算法无法直接处理数值型数据，尽管我们可以通过量化的方法将数值型数据转化<br>为标称型数值，但是如果存在太多的特征划分， ID3算法仍然会面临其他问题。  </p>
<p>过渡匹配的原因有以下几点：</p>
<ul>
<li>噪音数据：训练数据中存在噪音数据，决策树的某些节点有噪音数据作为分割标准，导致决策树无法代表真实数据。</li>
<li>缺少代表性数据：训练数据没有包含所有具有代表性的数据，导致某一类数据无法很好的匹配，这一点可以通过观察混淆矩阵（Confusion Matrix）分析得出。</li>
<li>多重比较（Mulitple Comparition）：举个列子，股票分析师预测股票涨或跌。假设分析师都是靠随机猜测，也就是他们正确的概率是0.5。每一个人预测10次，那么预测正确的次数在8次或8次以上的概率为 <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117091027.png" alt="">，只有5%左右，比较低。但是如果50个分析师，每个人预测10次，选择至少一个人得到8次或以上的人作为代表，那么概率为  <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117091111.png" alt=""> ，概率十分大，随着分析师人数的增加，概率无限接近1。但是，选出来的分析师其实是打酱油的，他对未来的预测不能做任何保证。上面这个例子就是<strong>多重比较</strong>。这一情况和决策树选取分割点类似，需要在每个变量的每一个值中选取一个作为分割的代表，所以选出一个噪音分割标准的概率是很大的。</li>
</ul>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>cv SIFT</title>
    <url>/jontyhuang.github.io/2019/11/15/cv-SIFT/</url>
    <content><![CDATA[<h1 id="scale-Invariant-Feature-Transform"><a href="#scale-Invariant-Feature-Transform" class="headerlink" title="scale Invariant Feature Transform"></a>scale Invariant Feature Transform</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/SIFT%E7%AE%97%E5%AD%90.jpeg" alt=""></p>
<h1 id="1-SIFT综述"><a href="#1-SIFT综述" class="headerlink" title="1.SIFT综述"></a>1.SIFT综述</h1><p>尺度不变特征变换是一种电脑视觉的算法用来检测与描述影像中的局部性特征，它可在空间尺度寻找极值点，并提取出位置、尺度、旋转不变量，此算法由David Lowe 在1999年发表。</p>
<a id="more"></a>

<p>此算法有其专利，专利拥有者为英属哥伦比亚大学。</p>
<p>局部影像特征的描述与侦测可以帮助辨识物体，SIFT 特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、些微视角改变的容忍度也相当高。基于这些特性，它们是高度显著而且相对容易撷取，在母数庞大的特征数据库中，很容易辨识物体而且鲜有误认。使用 SIFT特征描述对于部分物体遮蔽的侦测率也相当高，甚至只需要3个以上的SIFT物体特征就足以计算出位置与方位。在现今的电脑硬件速度下和小型的特征数据库条件下，辨识速度可接近即时运算。SIFT特征的信息量大，适合在海量数据库中快速准确匹配。</p>
<p>SIFT算法的特点有：</p>
<ol>
<li>SIFT特征是图像的局部特征，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；</li>
<li>独特性（Distinctiveness）好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；</li>
<li>多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；</li>
<li>高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；</li>
<li>可扩展性，可以很方便的与其他形式的特征向量进行联合。</li>
</ol>
<h1 id="2-高斯模糊"><a href="#2-高斯模糊" class="headerlink" title="2. 高斯模糊"></a>2. 高斯模糊</h1><p> SIFT算法是在不同的尺度空间上查找关键点，而尺度空间的获取需要使用高斯模糊来实现，Lindeberg等人已证明高斯卷积核是实现尺度变换的唯一变换核，并且是唯一的线性核。本节先介绍高斯模糊算法。</p>
<h2 id="2-1-二维高斯模糊"><a href="#2-1-二维高斯模糊" class="headerlink" title="2.1 二维高斯模糊"></a>2.1 二维高斯模糊</h2><p>高斯模糊是一种图像滤波器，利用正态模板计算模糊计算。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116160118.png" alt=""></p>
<p> 在二维空间中，这个公式生成的曲面的等高线是从中心开始呈正态分布的同心圆，如图2.1所示。分布不为零的像素组成的卷积矩阵与原始图像做变换。每个像素的值都是周围相邻像素值的加权平均。原始像素的值有最大的高斯分布值，所以有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。这样进行模糊处理比其它的均衡模糊滤波器更高地保留了边缘效果。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116160147.png" alt=""></p>
<p> 理论上来讲，图像中每点的分布都不为零，这也就是说每个像素的计算都需要包含整幅图像。在实际应用中，在计算高斯函数的离散近似时，在大概3σ距离之外的像素都可以看作不起作用，这些像素的计算也就可以忽略。通常，图像处理程序只需要计算$(6\times\sigma +1 )\times(6\times\sigma + 1)$矩阵就可以把保证相关像素的影响。 </p>
<h2 id="2-2-快速计算高斯卷积"><a href="#2-2-快速计算高斯卷积" class="headerlink" title="2.2 快速计算高斯卷积"></a>2.2 快速计算高斯卷积</h2><p>由于高斯模糊会在$\sigma$越大时，图像边缘缺失越严重。高斯卷积可以写成分离形式，所以我们可以先对行卷积再对列卷积。这样计算的时间复杂度可以 从O(M*M*N*N)降到O(2*M*M*N) , M和N为滤波器的窗口大小。</p>
<p>同时分离计算可以避免二维高斯计算带来的黑边，当进行一维计算时，在图像的边界位置，高斯卷积核会退化到相应的核数。</p>
<h1 id="3-尺度空间"><a href="#3-尺度空间" class="headerlink" title="3. 尺度空间"></a>3. 尺度空间</h1><h2 id="3-1-尺度空间理论"><a href="#3-1-尺度空间理论" class="headerlink" title="3.1 尺度空间理论"></a>3.1 尺度空间理论</h2><p> 尺度空间理论的基本思想是：在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为一种特征向量，实现边缘、角点检测和不同分辨率上的特征提取等。 </p>
<p> 尺度空间方法将传统的单尺度图像信息处理技术纳入尺度不断变化的动态分析框架中，更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够<strong>模拟人在距离目标由近到远时目标在视网膜上的形成过程</strong>。</p>
<p> 尺度空间满足视觉不变性。该不变性的视觉解释如下：当我们用眼睛观察物体时，一方面当物体所处背景的光照条件变化时，视网膜感知图像的亮度水平和对比度是不同的，因此要求尺度空间算子对图像的分析不受图像的灰度水平和对比度变化的影响，即满足<strong>灰度不变性和对比度不变性</strong>。另一方面，相对于某一固定坐标系，当观察者和物体之间的相对位置变化时，视网膜所感知的图像的位置、大小、角度和形状是不同的，因此要求尺度空间算子对图像的分析和图像的位置、大小、角度以及仿射变换无关，即<strong>满足平移不变性、尺度不变性、欧几里德不变性以及仿射不变性。</strong></p>
<h2 id="3-2-尺度空间的表示"><a href="#3-2-尺度空间的表示" class="headerlink" title="3.2 尺度空间的表示"></a>3.2 尺度空间的表示</h2><p>一个图像的尺度空间，<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116155236.png" alt="">)定义为一个变化尺度的高斯函数<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116155253.png" alt="">)与原图像<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116155331.png" alt="">的卷积。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116155351.png" alt=""></p>
<p>其中* 表示卷积运算,(x,y)是空间坐标，$\sigma$是尺度坐标。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116155426.png" alt=""></p>
<p>与上述高斯模糊一样，$(6 \times\sigma +1 )\times (6 \times\sigma + 1)$σ是尺度空间因子，值越小表示图像被平滑的越少，相应的尺度也就越小。大尺度对应于图像的相貌特征，小尺度对应于图像的细节特征。</p>
<h2 id="3-3-高斯金字塔的构建"><a href="#3-3-高斯金字塔的构建" class="headerlink" title="3.3 高斯金字塔的构建"></a>3.3 高斯金字塔的构建</h2><p>尺度空间在实现时使用高斯金字塔表示，高斯金字塔的构建分为两部分：</p>
<ul>
<li>对图像做不同尺度的高斯模糊</li>
<li>对图像做降采样（隔点采样）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116161731.png" alt=""></p>
<p>图像的金字塔模型是指，将原始图像不断降采样， 得到一系列大小不一的图像，由小到大，由下到上构建塔状模型。 原图像为金子塔的第一层，每次降采样所得到的新图像为金字塔的一层(每层一张图像)，每个金字塔共n层。金字塔的层数根据图像的原始大小和塔顶图像的大小共同决定，其计算公式如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116161926.png" alt="">)(3-3)</p>
<p>其中，M，N为原图像的大小，t为塔顶图像的最小维数的对数值。</p>
<p> 如，对于大小为512*512的图像，金字塔上各层图像的大小如表3.1所示，当塔顶图像为4*4时，n=7，当塔顶图像为2*2时，n=8。</p>
<p>为了体现查看都连续性，高斯金字塔在简单采样的基础上加了高斯滤波。如图3.1所示，将图像金字塔每层的一张图像使用不同参数做高斯模糊，使得高斯金字塔的每层含有多张高斯模糊的图像，将金字塔每层图像合称为一组(Octave), 金字塔每层只有一组图像，组数和层数相同。<strong>另外，在降采样时，高斯金字塔上面一组图像的初始图像（底层图像）是由前一组图像的倒数第三张图像降采样得到的。</strong></p>
<p> 注：由于组内的多张图像按层次叠放，因此组内的多张图像也称做多层，为避免与金字塔层的概念混淆，本文以下内容中，若不特别说明是金字塔层数，层一般指组内各层图像。 </p>
<h2 id="3-4-高斯差分金字塔"><a href="#3-4-高斯差分金字塔" class="headerlink" title="3.4 高斯差分金字塔"></a>3.4 高斯差分金字塔</h2><p> 2002年Mikolajczyk在详细的实验比较中发现尺度归一化的高斯拉普拉斯函数<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116162814.png" alt="">的极大值和极小值同其它的特征提取函数，例如：梯度，Hessian或Harris角特征比较，能够产生最稳定的图像特征。 </p>
<p> 而Lindeberg早在1994年就发现高斯差分函数（Difference of Gaussian ，简称DOG算子）与尺度归一化的高斯拉普拉斯函数 $\sigma^2 \nabla^2G$非常近似。其中$D(x, y, \sigma)$ 和$\sigma^2 \nabla^2G$的关系从如下公式推导。</p>
<p>二维高斯函数如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116163712.png" alt=""></p>
<p>对二维高斯函数的$\sigma$求导:</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191116163751767.png" alt="image-20191116163751767"></p>
<p>因此：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116163808.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116163839.png" alt=""></p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191116164416990.png" alt="image-20191116164416990"></p>
<p>这表明DOG算子可以近似LOG算子。</p>
<p> 其中k-1是个常数，并不影响极值点位置的求取。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116164832.png" alt=""></p>
<p>如图3.2所示，DOG算子完全可以代替LOG算子，进行极值检测。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117095734.png" alt="">（3-4） </p>
<p>在实际计算中，使用高斯金字塔每组中相邻上下图像相减。得到的就是高斯差分图像。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116165012.png" alt=""></p>
<h2 id="3-5-空间极值点的检测"><a href="#3-5-空间极值点的检测" class="headerlink" title="3.5 空间极值点的检测"></a>3.5 空间极值点的检测</h2><p>关键点是由DOG空间的局部极值点组成的，关键点的初步探查是<strong>通过同一组内各DoG相邻两层图像之间比较完成的</strong>。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。如图3.4所示，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。一个点如果在DOG空间本层以及上下两层的26个邻域中都是最大值或者是最小值，就认为该点是图像在该尺度下的一个特征点。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116165228.png" alt=""></p>
<p>高斯差分金字塔层数为S+ 2 的原因：</p>
<ul>
<li><p>为了满足高斯差分金字塔可以提取出S个特征点的要求。由于要在相邻尺度进行比较，如图3.3右侧每组含4层的高斯差分金子塔，只能在中间两层中进行两个尺度的极值点检测，其它尺度则只能在不同组中进行。为了在每组中检测S个尺度的极值点，则DOG金字塔每组需S+2层图像，而DOG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</p>
</li>
<li><p>为了满足尺度变化的连续性。假设s=3，也就是每个塔里有3层，则k=21/s=21/3，那么按照上图可得Gauss Space和DoG space 分别有3个（s个）和2个（s-1个）分量，在DoG space中，1st-octave两项分别是σ,kσ; 2nd-octave两项分别是2σ,2kσ;由于无法比较极值，我们必须在高斯空间继续添加高斯模糊项，使得形成σ,kσ,k2σ,k3σ,k4σ这样就可以选择DoG space中的中间三项kσ,k2σ,k3σ（只有左右都有才能有极值），那么下一octave中（由上一层降采样获得）所得三项即为2kσ,2$k^2$σ,2$k^3$σ，其首项2kσ=$2^{4/3}$。刚好与上一octave末项$k^3$σ=$2^{3/3}$尺度变化连续起来，所以每次要在Gaussian space添加3项，每组（塔）共S+3层图像，相应的DoG金字塔有S+2层图像。</p>
</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117173216.png" alt="s = 3情况"></p>
<p>当然这样产生的极值点并不全都是稳定的特征点，因为某些极值点响应较弱，而且DOG算子会产生较强的边缘响应。</p>
<h2 id="3-6-构建尺度空间需确定的参数"><a href="#3-6-构建尺度空间需确定的参数" class="headerlink" title="3.6 构建尺度空间需确定的参数"></a>3.6 构建尺度空间需确定的参数</h2><p>$\sigma$ ——尺度空间坐标</p>
<p>$O$ —— 组(Octave)数</p>
<p>$S$ —— 组内初始层数，实际组内为了满足高斯差分的会再增加3层</p>
<p>在上述尺度空间中,$O$ 和S， $\sigma$ 的关系如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116171123.png" alt="">)(3-5)</p>
<p> 其中$\sigma_0$是基准层尺度，O为组octave的索引，s为组内层的索引。*<em>关键点的尺度坐标$\sigma$就是按关键点所在的组和组内的层，利用公式(3-5)计算而来。 *</em></p>
<p> 在最开始建立高斯金字塔时，要预先模糊输入图像来作为第0个组的第0层的图像，这时相当于丢弃了最高的空域的采样率。因此通常的做法是先将图像的尺度扩大一倍来生成第-1组。我们假定初始的输入图像为了抗击混淆现象，已经对其进行<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117095502.png" alt="">)的高斯模糊，如果输入图像的尺寸用双线性插值扩大一倍，那么相当于<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117095532.png" alt="">。</p>
<p> 取式(3-4)中的k为组内总层数的倒数，即 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117100242.png" alt="">)(3-6)</p>
<p>尺度空间的所有取值如下，i为octave的组数，s为每组层数 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117171003.png" alt=""></p>
<p>我们发现，不同组之间越往上，尺度越大，直观上看，越往上越模糊，同一组内越往上越大。</p>
<p> 在构建高斯金字塔时，组内每层的尺度坐标按如下公式计算： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117100341.png" alt="">)(3-7)</p>
<p>其中$\sigma_0$ 是组内初始尺度，第一层lowe取$\sigma_0$=1.6，$S$=3,s为组内索引，不同组相同层的组内尺度坐标$\sigma(s)$是一样的。 组内下一层图像是由前一层图像按$\sigma(s)$进行高斯模糊所得。式(3-7)用于一次生成组内不同尺度的高斯图像，而在计算组内某一层图像的尺度时，直接使用如下公式进行计算： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117100747.png" alt="">)(3-8)</p>
<p> 该组内尺度在方向分配和特征描述时确定采样窗口的大小。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101013.png" alt=""></p>
<p> 图3.5为构建DOG金字塔的示意图，原图采用128*128的jobs图像，扩大一倍后构建金字塔。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101310.png" alt=""></p>
<h1 id="4-极值点定位（尺度不变性）"><a href="#4-极值点定位（尺度不变性）" class="headerlink" title="4. 极值点定位（尺度不变性）"></a>4. 极值点定位（尺度不变性）</h1><p> 以上方法检测到的极值点是离散空间的极值点，以下通过拟合三维二次函数来精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力。 </p>
<h2 id="4-1-关键点的精确定位"><a href="#4-1-关键点的精确定位" class="headerlink" title="4.1 关键点的精确定位"></a>4.1 关键点的精确定位</h2><p> 离散空间的极值点并不是真正的极值点，图4.1显示了二维函数离散空间得到的极值点与连续空间极值点的差别。利用已知的离散空间点插值得到的连续空间极值点的方法叫做子像素插值（Sub-pixel Interpolation）。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101513.png" alt=""></p>
<p> 为了提高关键点的稳定性，需要对尺度空间DoG函数进行曲线拟合。利用DoG函数在尺度空间的Taylor展开式(拟合函数)为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101541.png" alt=""></p>
<p>其中，<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101603.png" alt=""> 。求导并让方程等于零，可以得到极值点的偏移量为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101651.png" alt=""></p>
<p> 对应极值点，方程的值为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117210101.png" alt=""></p>
<p> 其中, <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117101603.png" alt="">代表相对插值中心的偏移量。 当它在任一维度上的偏移量大于0.5时 </p>
<p>（即x或y或$\sigma$），意味着插值中心已经偏移到它的邻近点上，所以必须改变当前关键点的位置。同时在新的位置上反复插值直到收敛；也有可能超出所设定的迭代次数或者超出图像边界的范围，此时这样的点应该删除，在Lowe中进行了5次迭代。另外，<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102232.png" alt="">)过小的点易受噪声的干扰而变得不稳定，所以将<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102232.png" alt="">小于某个经验值(Lowe论文中使用0.03，Rob Hess等人实现时使用0.04/S)的极值点删除。同时，在此过程中获取特征点的精确位置(原位置加上拟合的偏移量)以及尺度($\sigma(o. s) 和 \sigma_oct(s)$)。</p>
<h2 id="4-2-消除边缘响应"><a href="#4-2-消除边缘响应" class="headerlink" title="4.2 消除边缘响应"></a>4.2 消除边缘响应</h2><p><strong>这一步本质上要去掉DOG局部曲率非常不对称的像素。</strong></p>
<p> 一个定义不好的高斯差分算子的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。 </p>
<p> DOG算子会产生较强的边缘响应，需要剔除不稳定的边缘响应点。获取特征点处的Hessian矩阵，主曲率通过一个2x2 的Hessian矩阵H求出： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102343.png" alt=""></p>
<p> H的特征值α和β代表x和y方向的梯度， </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102358.png" alt=""></p>
<p> 表示矩阵H对角线元素之和，表示矩阵H的行列式。假设是α较大的特征值，而是β较小的特征值，令$\alpha = r\beta$，则 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102637.png" alt=""></p>
<p>导数由采样点相邻差估计得到,在下一节中说明。</p>
<p>D的主曲率和H的特征值成正比，令为α最大特征值，β为最小的特征值，则公式的值在两个特征值相等时最小，随着的增大而增大。值越大，说明两个特征值的比值越大，即在某一个方向的梯度值越大，而在另一个方向的梯度值越小，而边缘恰恰就是这种情况。所以为了剔除边缘响应点，需要让该比值小于一定的阈值，因此，为了检测<strong>主曲率是否在某域值r下</strong>，只需检测</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117102801.png" alt="">)(4-7)</p>
<p>(4-7)式成立的时候将关键点保留。</p>
<p>在Lowe的文章中，取r＝10。图4.2右侧为消除边缘响应后的关键点分布图。</p>
<p> <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103031.png" alt=""></p>
<h2 id="4-3-有限差分求导"><a href="#4-3-有限差分求导" class="headerlink" title="4.3 有限差分求导"></a>4.3 有限差分求导</h2><p>有限差分法以变量离散取值后对应的函数值来近似微分方程中独立变量的连续取值。在有限差分方法中，我们放弃了微分方程中独立变量可以取连续值的特征，而关注独立变量离散取值后对应的函数值。但是从原则上说，这种方法仍然可以达到任意满意的计算精度。因为方程的连续数值解可以通过减小独立变量离散取值的间格，或者通过离散点上的函数值插值计算来近似得到。这种方法是随着计算机的诞生和应用而发展起来的。其计算格式和程序的设计都比较直观和简单，因而，它在计算数学中使用广泛。</p>
<p>有限差分法的具体操作分为两个部分：</p>
<ol>
<li><p>用差分代替微分方程中的微分，将连续变化的变量离散化，从而得到差分方程组的数学形式；</p>
</li>
<li><p>求解差分方程组。</p>
<p>一个函数在x点上的一阶和二阶微商，可以近似地用它所临近的两点上的函数值的差分来表示。如对一个单变量函数f(x)，x为定义在区间[a,b]上的连续变量，以步长<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103235.png" alt="">将区间[a,b]离散化，我们会得到一系列节点， </p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103247.png" alt=""></p>
<p> 然后求出f(x)在这些点上的近似值。显然步长h越小，近似解的精度就越好。与节点$x_i$相邻的节点有$x_i-h$和$x_i+h$，所以在节点$x_i$处可构造如下形式的差值： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103437.png" alt="">节点的一阶向前差分</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103502.png" alt="">节点的一阶向后差分</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103535.png" alt="">节点的一阶中心差分</p>
<p> 本文使用中心差分法利用泰勒展开式求解第四节所使用的导数，现做如下推导。 </p>
<p> 函数f(x)在$x_i$处的泰勒展开式为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103624.png" alt="">)（4-8)</p>
<p>而</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103638.png" alt="">（4-9）</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103646.png" alt="">（4-10）</p>
<p> 忽略h平方之后的项，联立式(4-9)，(4-10)解方程组得： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103723.png" alt="">)(4-11)</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103804.png" alt="">)(4-12)</p>
<p>二元函数的泰勒展开式：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103900.png" alt=""></p>
<p>将<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103929.png" alt="">展开后 忽略次要项联立解方程得二维混合偏导如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117103954.png" alt="">)(4-13)</p>
<p> 综上，推导了4.1,4.2遇到的所有导数计算。同理，利用多元泰勒展开式，可得任意偏导的近似差分表示。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117104008.png" alt=""></p>
<p> 在图像处理中，取h=1，在图4.2所示的图像中，将像素0的基本中点导数公式整理如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117104036.png" alt=""></p>
<h2 id="4-4-三阶矩阵求逆公式"><a href="#4-4-三阶矩阵求逆公式" class="headerlink" title="4.4 三阶矩阵求逆公式"></a>4.4 三阶矩阵求逆公式</h2><p>高阶矩阵的求逆算法主要有归一法和消元法两种，现将三阶矩阵求逆公式总结如下：</p>
<p>若矩阵</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117104245.png" alt=""></p>
<p>|A| $\neq$ 0,则可逆。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117104437.png" alt="">)(4-14)</p>
<h1 id="5-关键点方向分配-方向不变性"><a href="#5-关键点方向分配-方向不变性" class="headerlink" title="5. 关键点方向分配(方向不变性)"></a>5. 关键点方向分配(方向不变性)</h1><p> 为了使描述符具有旋转不变性，需要利用图像的局部特征为给每一个关键点分配一个基准方向。使用图像梯度的方法求取局部结构的稳定方向。对于在DOG金字塔中检测出的关键点点，采集其所在高斯金字塔图像3σ邻域窗口内像素的梯度和方向分布特征。梯度的模值和方向如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117104524.png" alt="">)(5-1)</p>
<p> L为关键点所在的尺度空间值，按Lowe的建议，梯度的模值m(x,y)按$\sigma = 1.5\sigma_oct$的高斯分布加成，按尺度采样的3σ原则，邻域窗口半径为$3 * 1.5\sigma_oct$。</p>
<p> 在完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。梯度直方图将0~360度的方向范围分为36个柱(bins)，其中每柱10度。如图5.1所示，直方图的峰值方向代表了关键点的主方向，(为简化，图中只画了八个方向的直方图)。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110213.png" alt=""></p>
<p>方向直方图的峰值则代表了该特征点处邻域梯度的方向，以直方图中最大值作为该关键点的主方向。为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。因此，对于同一梯度值的多个峰值的关键点位置，在相同位置和尺度将会有多个关键点被创建但方向不同。仅有15％的关键点被赋予多个方向，但可以明显的提高关键点匹配的稳定性。实际编程实现中，就是把该关键点复制成多份关键点，并将方向值分别赋给这些复制后的关键点，并且，离散的梯度方向直方图要进行插值拟合处理，来求得更精确的方向角度值，检测结果如图5.2所示。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110329.png" alt=""></p>
<p> 至此，将检测出的含有位置、尺度和方向的关键点即是该图像的SIFT特征点。</p>
<h1 id="6-关键点的特征描述-（SIFT描述子）"><a href="#6-关键点的特征描述-（SIFT描述子）" class="headerlink" title="6. 关键点的特征描述 （SIFT描述子）"></a>6. 关键点的特征描述 （SIFT描述子）</h1><p>通过以上步骤，对于每一个关键点，拥有三个信息：位置、尺度以及方向。接下来就是为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变，比如光照变化、视角变化等等。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述子应该有较高的独特性，以便于提高特征点正确匹配的概率。 </p>
<p>SIFT描述子是关键点邻域高斯图像梯度统计结果的一种表示。通过对关键点周围图像区域分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。</p>
<p>Lowe建议描述子使用在关键点尺度空间内4*4的窗口中计算的8个方向的梯度信息，共4*4*8=128维向量表。表示步骤如下：</p>
<ol>
<li>确定计算描述子所需的图像区域</li>
</ol>
<p>特征描述子与特征点所在的尺度有关，因此，对梯度的求取应在特征点对应的高斯图像上进行。将关键点附近的邻域划分为d*d(Lowe建议d=4)个子区域，每个子区域做为一个种子点，每个种子点有8个方向。每个子区域的大小与关键点方向分配时相同，即每个区域有个<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110709.png" alt="">)子像素，为每个子区域分配边长<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110709.png" alt="">的矩形区域进行采样(个子像素实际用边长为 <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110824.png" alt=""> 的矩形区域即可包含，但由式(3-8)，<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110854.png" alt="">不大， 为了简化计算取其边长为 <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117110709.png" alt="">并且采样点宜多不宜少）。 考虑到实际计算时，需要采用双线性插值，所需图像窗口边长为<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117111004.png" alt="">)。在考虑到旋转因素(方便下一步将坐标轴旋转到关键点的方向)，如下图6.1所示，实际计算所需的图像区域半径为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117111013.png" alt="">（6-1）</p>
<p>计算结果四舍五入取整。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117221504.png" alt=""> </p>
<ol start="2">
<li>将坐标轴旋转为关键点的方向，以确保旋转不变性，如6.2所示。  </li>
</ol>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117111919.png" alt=""></p>
<p> 旋转后邻域内采样点的新坐标为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117111938.png" alt="">)(6-2)</p>
<ol start="3">
<li>将邻域内的采样点分配到对应的子区域内，将子区域内的梯度值分配到8个方向上，计算其权值。</li>
</ol>
<p>旋转后的采样点坐标在半径为radius的圆内被分配到d*d的子区域，计算影响子区域的采样点的梯度和方向，分配到8个方向上。</p>
<p>旋转后的采样点<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117112303.png" alt="">落在子区域的下标为</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117112316.png" alt="">)(6-3)</p>
<p> Lowe建议子区域的像素的梯度大小按$\sigma = 0.5 d$的高斯加权计算，即 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117112403.png" alt="">)(6-4)</p>
<p> 其中a，b为关键点在高斯金字塔图像中的位置坐标。 </p>
<p>4.插值计算每个种子点八个方向的梯度。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117112439.png" alt=""></p>
<p>如图6.3所示，将由式(6-3)所得采样点在子区域中的下标<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115458.png" alt="">)(图中蓝色窗口内红色点)线性插值，计算其对每个种子点的贡献。如图中的红色点，落在第0行和第1行之间，对这两行都有贡献。对第0行第3列种子点的贡献因子为dr，对第1行第3列的贡献因子为1-dr，同理，对邻近两列的贡献因子为dc和1-dc，对邻近两个方向的贡献因子为do和1-do。则最终累加在每个方向上的梯度大小为：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115617.png" alt=""></p>
<p> 其中k，m，n为0或为1。 </p>
<p>5.如上统计的4*4*8=128个梯度信息即为该关键点的特征向量。特征向量形成后，为了除光照变化的影响，需要对它们进行归一化处理，对于图像灰度值整体漂移，图像各点的梯度是邻域像素相减得到，所以也能去除。得到的描述子向量为<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115645.png" alt="">)，归一化后的特征向量为<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115702.png" alt="">,则 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115712.png" alt="">)(6-7)</p>
<p>6.描述子向量门限。非线性光照，相机饱和度变化对造成某些方向的梯度值过大，而对方向的影响微弱。因此设置门限值(向量归一化后，一般取0.2)截断较大的梯度值。然后，再进行一次归一化处理，提高特征的鉴别性。</p>
<ol start="7">
<li>按特征点的尺度对特征描述向量进行排序。</li>
</ol>
<p>至此，SIFT特征描述向量生成。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115816.png" alt=""></p>
<p>关键点描述子的生成步骤</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117211032.png" alt=""></p>
<h1 id="7-SIFT的缺点"><a href="#7-SIFT的缺点" class="headerlink" title="7. SIFT的缺点"></a>7. SIFT的缺点</h1><p>7、SIFT的缺点<br>SIFT在图像的不变特征提取方面拥有无与伦比的优势，但并不完美，仍然存在：</p>
<ol>
<li><p>实时性不高。</p>
</li>
<li><p>有时特征点较少。</p>
</li>
<li><p>对边缘光滑的目标无法准确提取特征点。</p>
</li>
</ol>
<p>等缺点，如下图7.1所示，对模糊的图像和边缘平滑的图像，检测出的特征点过少，对圆更是无能为力。近来不断有人改进，其中最著名的有SURF和CSIFT。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191117115912.png" alt=""></p>
]]></content>
      <categories>
        <category>basic learning of cv</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning of k-Nearest Neighbor</title>
    <url>/jontyhuang.github.io/2019/11/14/machine-learning-of-k-Nearest-Neighbor/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114204004.png" alt=""></p>
<a id="more"></a>

<h1 id="1-KNN"><a href="#1-KNN" class="headerlink" title="1. KNN"></a>1. KNN</h1><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><ul>
<li>优点：精度高、对异常值不敏感、无数据输入假定</li>
<li>缺点：计算复杂度高、空间复杂度高</li>
<li>适用的数据范围：数值型和标称型</li>
</ul>
<p>算法缺陷是：无法给出任何数据的基础结构信息，因此我们无法知晓平均实例样本和典型实例样本具有什么特征。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>存在一个样本数据集合，也称为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每个数据所属分类的对应关系。提取出每个新数据的特征，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20 的数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<p>因此，KNN是通过多数表决等方式进行预测，其不具备显式的学习过程。KNN实际上利用训练集对特征向量空间进行划分，并作为其分类的”模型“，<strong>k值的选择、距离度量及分类决策</strong>规则是kNN的三个基本要素。</p>
<h3 id="k的选择"><a href="#k的选择" class="headerlink" title="k的选择"></a>k的选择</h3><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115110540.png" alt=""></p>
<h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114210318.png" alt=""></p>
<h1 id="2-python如何使用KNN进行分类"><a href="#2-python如何使用KNN进行分类" class="headerlink" title="2. python如何使用KNN进行分类"></a>2. python如何使用KNN进行分类</h1><h2 id="1-实施KNN算法"><a href="#1-实施KNN算法" class="headerlink" title="1. 实施KNN算法"></a>1. 实施KNN算法</h2><p>伪代码如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114211950.png" alt=""></p>
<p>程序如下：</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191114212124348.png" alt="image-20191114212124348"></p>
<p>程序讲解：</p>
<ul>
<li>tile(A, n)函数是将A数组重复n次。当n为元组时，譬如(n,m)，则将A先在第二个维度复制m个，再在第一个维度复制n个刚刚第二个维度的数据。元组扩大，同理。上面程序的意思是将inX数组在第二维复制1个，再在第一个维度复制dataSetSize个。</li>
<li>程序的距离计算使用是欧式距离。</li>
</ul>
<h2 id="2-实例：使用KNN改进约会网站的配对效果"><a href="#2-实例：使用KNN改进约会网站的配对效果" class="headerlink" title="2. 实例：使用KNN改进约会网站的配对效果"></a>2. 实例：使用KNN改进约会网站的配对效果</h2><p>三种类型：</p>
<ul>
<li>不喜欢的人</li>
<li>魅力一般的人</li>
<li>极具魅力的人</li>
</ul>
<p>程序伪代码如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114214747.png" alt=""></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""将txt文件的内容转为features mat 和 label"""</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    numberOfLines = len(fr.readlines())         <span class="comment">#get the number of lines in the file</span></span><br><span class="line">    returnMat = zeros((numberOfLines,<span class="number">3</span>))        <span class="comment">#prepare matrix to return， 3个特征所以是3列</span></span><br><span class="line">    classLabelVector = []                       <span class="comment">#prepare labels return   </span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line = line.strip()</span><br><span class="line">        listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        returnMat[index,:] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br><span class="line"></span><br><span class="line">datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">color = [<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>]</span><br><span class="line">ax = fig.add_subplot(<span class="number">311</span>)  <span class="comment"># 将画布分为三行一列，该区域为分割后的第一块</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    index = np.where(np.array(datingLabels) == i)</span><br><span class="line">    ax.scatter(datingDataMat[index, <span class="number">0</span>],datingDataMat[index, <span class="number">1</span>],c=color[i - <span class="number">1</span>], label=i)<span class="comment"># scatter绘制</span></span><br><span class="line">    </span><br><span class="line">plt.xlabel(<span class="string">'col.0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'col.1'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">bx = fig.add_subplot(<span class="number">312</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    index = np.where(np.array(datingLabels) == i)</span><br><span class="line">    bx.scatter(datingDataMat[index, <span class="number">0</span>], datingDataMat[index, <span class="number">2</span>], c=color[i - <span class="number">1</span>], label=i)</span><br><span class="line">plt.xlabel(<span class="string">'Col.0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Col.2'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">cx = fig.add_subplot(<span class="number">313</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    index = np.where(np.array(datingLabels) == i)</span><br><span class="line">    cx.scatter(datingDataMat[index, <span class="number">1</span>], datingDataMat[index, <span class="number">2</span>], c=color[i - <span class="number">1</span>], label=i)</span><br><span class="line">plt.xlabel(<span class="string">'Col.1'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Col.2'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115104115.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    <span class="string">"""KNN识别程序，与训练集比较"""</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()     </span><br><span class="line">    classCount=&#123;&#125;          </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""对每个特征进行归一化， 返回归一化后的特征矩阵，样本数，特征中最小的值</span></span><br><span class="line"><span class="string">    样本特征值 0.8 400 0.5 </span></span><br><span class="line"><span class="string">    为什么归一化，因为特征的大小不一样，一些特征由于数值过大会给计算带来很大的影响，由于在本问题职中我们简单的将每个特征的权重看做相同"""</span></span><br><span class="line">    minVals = dataSet.min(<span class="number">0</span>)  <span class="comment"># 获取每一列的最小值</span></span><br><span class="line">    maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">    ranges = maxVals - minVals   <span class="comment"># 获取列数据差 ，即一个一行三列的矩阵 </span></span><br><span class="line">    normDataSet = zeros(shape(dataSet))  <span class="comment"># 创建存储矩阵</span></span><br><span class="line">    m = dataSet.shape[<span class="number">0</span>]  <span class="comment"># 获取训练集样本数</span></span><br><span class="line">    normDataSet = dataSet - tile(minVals, (m,<span class="number">1</span>))</span><br><span class="line">    normDataSet = normDataSet/tile(ranges, (m,<span class="number">1</span>))   <span class="comment">#element wise divide</span></span><br><span class="line">    <span class="keyword">return</span> normDataSet, ranges, minVals</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    hoRatio = <span class="number">0.10</span>      <span class="comment">#hold out 10%</span></span><br><span class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)       <span class="comment">#load data setfrom file</span></span><br><span class="line">    normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">    m = normMat.shape[<span class="number">0</span>]  <span class="comment">#获取样本数</span></span><br><span class="line">    numTestVecs = int(m*hoRatio)    <span class="comment">#设置验证集的索引</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">        classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">        <span class="keyword">if</span> (classifierResult != datingLabels[i]): errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"the total error rate is: %f"</span> % (errorCount/float(numTestVecs)))</span><br><span class="line">    print(errorCount)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115104245.png" alt=""></p>
<h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    <span class="string">"""KNN识别程序，与训练集比较"""</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()     </span><br><span class="line">    classCount=&#123;&#125;          </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">    returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">    <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(<span class="string">'trainingDigits'</span>)           <span class="comment">#load the training set</span></span><br><span class="line">    m = len(trainingFileList)  <span class="comment">#存储样本数</span></span><br><span class="line">    trainingMat = zeros((m,<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]     <span class="comment">#take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        hwLabels.append(classNumStr)</span><br><span class="line">        trainingMat[i,:] = img2vector(<span class="string">'trainingDigits/%s'</span> % fileNameStr)</span><br><span class="line">    testFileList = listdir(<span class="string">'testDigits'</span>)        <span class="comment">#iterate through the test set</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    mTest = len(testFileList)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">        fileNameStr = testFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]     <span class="comment">#take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        vectorUnderTest = img2vector(<span class="string">'testDigits/%s'</span> % fileNameStr)</span><br><span class="line">        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, classNumStr))</span><br><span class="line">        <span class="keyword">if</span> (classifierResult != classNumStr): errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"\nthe total number of errors is: %d"</span> % errorCount)</span><br><span class="line">    print(<span class="string">"\nthe total error rate is: %f"</span> % (errorCount/float(mTest)))</span><br><span class="line">handwritingClassTest()</span><br></pre></td></tr></table></figure>





<h1 id="3-解决运算量的问题搜索KD树"><a href="#3-解决运算量的问题搜索KD树" class="headerlink" title="3. 解决运算量的问题搜索KD树"></a>3. 解决运算量的问题搜索KD树</h1><h2 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h2><p>前面我们使用的方法都是线性扫描。当训练集很大时，这种方法是不可取的。</p>
<p>Kd树是k维空间存储的数据结构。</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191115110859239.png" alt="image-20191115110859239"></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115111745.png" alt=""></p>
<h2 id="搜索KD树"><a href="#搜索KD树" class="headerlink" title="搜索KD树"></a>搜索KD树</h2><p>利用KD树进行k近邻搜索，可以省去大部分数据点的搜索。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115112218.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115112834.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191115112759.png" alt=""></p>
<h1 id="4-实现KNN估值模型"><a href="#4-实现KNN估值模型" class="headerlink" title="4. 实现KNN估值模型"></a>4. 实现KNN估值模型</h1><h2 id="估值案例"><a href="#估值案例" class="headerlink" title="估值案例"></a>估值案例</h2><p>我们使用k最近邻算法来构建白酒的价格模型。这是一个估值模型，不是分类案例。需要预测的回归值为白酒的价格 。</p>
<h2 id="构造数据集"><a href="#构造数据集" class="headerlink" title="构造数据集"></a>构造数据集</h2><p>我们先考虑一个简单的价格模型。我们知道白酒的价格跟等级、年代有很大的关系。我们需要知道一批白酒的数据作为样本数据集，其中包含每瓶白酒的等级、年代、和价格（输出值）。</p>
<p>这批数据集你可以使用市场问卷调查，或者网络爬虫获取。为了简单我们自己模拟产生。</p>
<p>构建一个葡萄酒样本数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random,randint</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据等级和年代对价格进行模拟</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wineprice</span><span class="params">(rating,age)</span>:</span></span><br><span class="line">    peak_age=rating<span class="number">-50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据等级计算价格</span></span><br><span class="line">    price=rating/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> age&gt;peak_age:</span><br><span class="line">        <span class="comment"># 经过“峰值年”，后续5年里其品质将会变差</span></span><br><span class="line">        price=price*(<span class="number">5</span>-(age-peak_age)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 价格在接近“峰值年”时会增加到原值的5倍</span></span><br><span class="line">        price=price*(<span class="number">5</span>*((age+<span class="number">1</span>)/peak_age))</span><br><span class="line">    <span class="keyword">if</span> price&lt;<span class="number">0</span>: price=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> price</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一批数据代表样本数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wineset1</span><span class="params">()</span>:</span></span><br><span class="line">    rows=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">        <span class="comment"># 随机生成年代和等级</span></span><br><span class="line">        rating=random()*<span class="number">50</span>+<span class="number">50</span></span><br><span class="line">        age=random()*<span class="number">50</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到一个参考价格</span></span><br><span class="line">        price=wineprice(rating,age)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加一些噪音</span></span><br><span class="line">        price*=(random()*<span class="number">0.2</span>+<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加入数据集</span></span><br><span class="line">        rows.append(&#123;<span class="string">'input'</span>:(rating,age),<span class="string">'result'</span>:price&#125;)</span><br><span class="line">    <span class="keyword">return</span> rows</span><br></pre></td></tr></table></figure>

<h2 id="样本距离"><a href="#样本距离" class="headerlink" title="样本距离"></a>样本距离</h2><p>要使用k最近邻，首先要知道哪些是最近邻，所以我们还要有一个功能，就是要能计算两个对象之间的相似度。我们这里使用欧几里得距离作为数据间的距离，代表相似度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用欧几里得距离，定义距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean</span><span class="params">(v1,v2)</span>:</span></span><br><span class="line">    d=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(v1)):</span><br><span class="line">        d+=(v1[i]-v2[i])**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(d)</span><br></pre></td></tr></table></figure>



<h2 id="获取与新数据距离最近的k个样本数据"><a href="#获取与新数据距离最近的k个样本数据" class="headerlink" title="获取与新数据距离最近的k个样本数据"></a>获取与新数据距离最近的k个样本数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算待测商品和样本数据集中任一商品间的距离。data样本数据集，vec1待测商品</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdistances</span><span class="params">(data,vec1)</span>:</span></span><br><span class="line">    distancelist=[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历样本数据集中的每一项</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        vec2=data[i][<span class="string">'input'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加距离到距离列表</span></span><br><span class="line">        distancelist.append((euclidean(vec1,vec2),i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 距离排序</span></span><br><span class="line">    distancelist.sort()</span><br><span class="line">    <span class="keyword">return</span> distancelist  <span class="comment">#返回距离列表</span></span><br></pre></td></tr></table></figure>

<h2 id="根据距离最近的k个样本数据预测新对象的输出值"><a href="#根据距离最近的k个样本数据预测新对象的输出值" class="headerlink" title="根据距离最近的k个样本数据预测新对象的输出值"></a>根据距离最近的k个样本数据预测新对象的输出值</h2><p> 上面的步骤，我们已经获取了距离最近的k个样本对象。那么如何根据k个样本对象的属性和价格计算待测对象的价格呢？ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对距离值最小的前k个结果求平均</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knnestimate</span><span class="params">(data,vec1,k=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 得到经过排序的距离值</span></span><br><span class="line">    dlist=getdistances(data,vec1)</span><br><span class="line">    avg=<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对前k项结果求平均</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        idx=dlist[i][<span class="number">1</span>] </span><br><span class="line">        avg+=data[idx][<span class="string">'result'</span>]</span><br><span class="line">    avg=avg/k</span><br><span class="line">    <span class="keyword">return</span> avg</span><br></pre></td></tr></table></figure>

<p>2、求加权平均</p>
<p>如果使用直接求均值，有可能存在前k个最近邻中，可能会存在距离很远的数据，但是他仍然属于最近的前K个数据。</p>
<p>比如设定了k=5，距离最近的3个样本对象距离待测对象很近，但是第4、5个样本对象已经非常远离了待测对象。</p>
<p>当存在这种情况时，对前k个样本数据直接求均值会有偏差，所以使用加权平均，为较远的节点赋予较小的权值，对较近的节点赋予较大的权值。</p>
<p>那么具体该怎么根据数据间距离分配权值呢？这里使用三种递减函数作为权值分配方法。</p>
<p>三种权值分配的思想就是距离远的权值小，距离近的权值大。</p>
<p>2.1 可以使用高斯函数为距离分配权重</p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>ReID Fine-grained multi-feature fusion</title>
    <url>/jontyhuang.github.io/2019/11/14/ReID-Fine-grained-multi-feature-fusion/</url>
    <content><![CDATA[<p> 前面，我们基于一个优化的ResNet-50网络作为一个 baseline，学习的是图像数据的全局特征。然后我们基于baseline网络，使用了PCB分块方法，学习的是图像数据的局部特征。这里，将使用一个更复杂的模型来学习全局和局部特征，并训练一个细粒度多特征融合网络。 </p>
<h1 id="单一全局特征与局部特征学习存在的问题"><a href="#单一全局特征与局部特征学习存在的问题" class="headerlink" title="单一全局特征与局部特征学习存在的问题"></a>单一全局特征与局部特征学习存在的问题</h1><p> 下图是一幅行人图像学习全局特征和局部特征的特征响应图，左边部分是全局特征，右边部分是局部特征。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114162116.png" alt=""></p>
<a id="more"></a>

<p>全局特征的目的是学习到最显著的外观表现，但是，一些细节性的特征在全局特征学习时是被忽略的，比如人身上或者衣服上有个标志，当是这并不是所有的样本都有的，从上图的左边可以看到，全局特征会做特征均匀化，从而忽略掉一些细粒度的特征表现。</p>
<p>局部特征可以关注更多的细节，但是无论是做关键点定位后的姿态估计还是图像的水平分块，都有很多先验知识在里面，在很多的场景中，我们获得的图像数据并没有那么完整（比如大面积被障碍物遮挡，姿态的大幅度变化，行人在图像中的不同占比，以及分块特征没有对齐校准等等）。所以，局部特征的学习鲁棒性还是不够高，在做数据集的迁移时，模型往往适应性比较差。</p>
<p>所以，单一做全局特征或者局部特征的学习产生的效果还是不理想的。</p>
<h1 id="2-细粒度多特征融合网络"><a href="#2-细粒度多特征融合网络" class="headerlink" title="2. 细粒度多特征融合网络"></a>2. 细粒度多特征融合网络</h1><h2 id="2-1-设计思路和原理"><a href="#2-1-设计思路和原理" class="headerlink" title="2.1 设计思路和原理"></a>2.1 设计思路和原理</h2><p> 既然单一的学习全局特征和局部特征都存在着问题，一个简单的思路是将其组合起来 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114162305.png" alt=""></p>
<p> 上图为一种组合特征的划分方法。最左边为整张图像，我们学习的是局部特征，因此也是最粗的一级粒度特征。中间为每幅图像水平划分为2份，最右边为每幅图像水平划分为三份。中间和最右边的粒度等级依次为二级和三级。这三级的粒度特征可以作为我们网络学习的三个支路，最终可以整合为一个融合的特征。 </p>
<h2 id="2-2-网络结构分析"><a href="#2-2-网络结构分析" class="headerlink" title="2.2 网络结构分析"></a>2.2 网络结构分析</h2><p> 多粒度的网络模型（Multiple Granularities Network,MGN）是云从科技2018年提出来的网络架构，它属于结合了两种特征，具有细粒度多特征融合特性的模型，并且在主流数据集上取得了最领先的成果。下图是它的网络结构，首先，它的backbone网络也是ResNet-50，只不过只取了前3组卷积层做初步的特征提取。初步提取之后，三个分支正如上节中提到的三级粒度，最上面的一个分支提取的是全局特征，也就是学习的第一级粒度，中间和最下面的两个分支提取的是局部特征，分别学习第二级和第三级的粒度特征。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114162605.png" alt=""></p>
<p> 在初步的特征提取中，网络的参数是共有的，在后续三个分支的特征提取中，参数是独立的，这一思路也符合人为的观察效果。图中，ResNet-50有三层，分别对应后面的三个分支。在三个分支中可以看到，都有左右两个小方块，这一步实际上就是我们第三章中的特征图扩展，本来ResNet第四层卷积后会有个降采样，也就是stride=2,所以特征图谱尺寸要缩小一倍，也就是最上面那个分支，右边的小方块比左边的小方块小一倍的原因。而在第二个和第三个分支，我们将stride=1,也就是特征图扩张一倍，相当于没有了降采样的步骤，所以它左右方块大小是一样的。在第二个支路中，特征图之后又有两个支路，一个是没有做分割的特征，也就是全局特征（区别于第一支路的一点是这个全局特征已经做了特征图扩张了），另一个是水平分割成两部分，此为第二级粒度，之后，我们做一个最大值池化，得到的特征维度是2048，然后做降维，成256维，方便计算。第三个分支和第二个分支类似，也是独立出一个全局特征块，然后分成三个部分，做了池化和1*1卷积核的降维操作后得到不同的特征分块。 </p>
<p> 在loss的设计上，使用的是常见的loss：softmax loss和triplet loss。但是各分支对应的loss不同，属于triplet loss的特征图有：第一个分支中，做池化和降维后的256维特征图；第二个和第三个分支中，做了特征图扩张的全局特征，再池化和降维之后的256维特征图。属于triplet loss的特征图块有3个。属于softmax loss的特征图有：第一第二第三分支中的全局特征，在池化之后，降维之前的特征图块，以及第二第三分支各分块特征图的最终图块。属于softmax loss的特征图块有8个。关于分块特征图不给triplet loss训练也是有原因的，因为理想状态下，比如人分成两块，是上半身一块，下半身一块，但是往往分割的上半部分是人的整个图像，而下半部分是其他的物体，这样的分块特征图谱给三元组损失（triplet loss）训练是很容易得出奇怪结果的。 </p>
]]></content>
  </entry>
  <entry>
    <title>ReID Learn block and local features</title>
    <url>/jontyhuang.github.io/2019/11/14/ReID-Learn-block-and-local-features/</url>
    <content><![CDATA[<h1 id="1-局部特征学习方法"><a href="#1-局部特征学习方法" class="headerlink" title="1. 局部特征学习方法"></a>1. 局部特征学习方法</h1><p> 早期的ReID研究，人们更多的方向的是全局特征，就像上一篇说的baseline一样，将整个图像作为网络的输入，通过学习网络的特征提取得到特征图谱。但是ReID任务的数据集是多样性的，有时候并不能得到完好的全身图像，而全局特征也忽略了图像本身的一些细粒度信息，所以，基于局部特征的ReID也是行人重识别研究的一个重要方向之一。 </p>
<p> 基于局部特征学习方法的ReID目前主要有两种做法，一种是利用人体的关键点定位，通过区域联结获取行人的姿态特征。Spindle Net是这种做法的一个代表网络，如图所示。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155821.png" alt=""></p>
<a id="more"></a>

<p>图中，蓝色部分为已经预训练好的RPN网络，用于获得人体的14个关键点，同时由14个关键点得到7个ROI块，完整的图像通过CNN网络提取特征，同时7个ROI块也通过相同的网络来提取特征，CNN网络之间参数共享。最终得到的8个特征以不同的尺度结合在一起，以这种融合特征的方式去做ReID的任务。</p>
<p>另一种主要的做法是区域分块，一般通过水平分块切分一个图像，每个part部分分别提取特征，最终也是联结到一起，去训练网络使得损失loss降低，模型的网络参数不断更新。区域分块的方式可以关注行人图片上的细节特征，相比于做关键点定位的姿态估计网络，有些图像数据并没有清晰的人像，因此很难做到关键点的定位，即使是定位了也可能不准确，导致模型的识别产生较大的误差。</p>
<h1 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h1><p> 基于卷积基线网络的分块(Part-based Convolutional Baseline，PCB) 网络来自于2018年ECCV的一篇论文：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1711.09349.pdf">原文链接</a>。该模型属于上面介绍的均匀切块方法，论文中将整个图像水平切成6块，6个部分被别用不同的loss来训练网络。PCB网络的结构如下图所示。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155955.png" alt=""></p>
<p> PCB网络的backbone 网络的选择有很多，在后面的实验中，backbone 网络采用上一篇构建的baseline网络。 由上图可以看到，经过骨干网络提取的特征后，原来的均值池化层和全连接层被移除，将特征图水平分成6个部分，再分别对每个部分做全均值池化，此时每个部分的维度为2048，再经过一个1*1的卷积核降维得到的特征块维度为256。最后，对6个softmax分类器进行了训练，分类的数量取决于训练集ID个数。测试时的向量为降维前的2048维向量串接降维后的256维向量。该网络使用交叉熵代价函数作为损失函数，而去掉最后一次的全均值池化，是为了增加细粒度的特征。 </p>
<h1 id="3-计算结果分析-（完整代码见作者GitHub）"><a href="#3-计算结果分析-（完整代码见作者GitHub）" class="headerlink" title="3. 计算结果分析(（完整代码见作者GitHub）)"></a>3. 计算结果分析(（完整代码见作者<a href="https://link.zhihu.com/?target=https%3A//github.com/lixiangwang/Person-ReID">GitHub</a>）)</h1><p> 实验的环境和前面一样，基于PyTorch框架，数据加载同样使用ImageFolder和 torch.utils.data.DataLoader接口，每个batch包装前的数据是打乱的，使用8个CPU线程来加载。预处理的方式按照论文给出的方式，如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_train_list = [</span><br><span class="line">        transforms.Resize((<span class="number">384</span>,<span class="number">192</span>), interpolation=<span class="number">3</span>),</span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">        ]</span><br><span class="line">    transform_val_list = [</span><br><span class="line">        transforms.Resize(size=(<span class="number">384</span>,<span class="number">192</span>),interpolation=<span class="number">3</span>), <span class="comment">#Image.BICUBIC</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>



<p>所有的图像被resize为384*192大小，train set采用随机水平翻转的方式增强数据，将格式转换为tensor之后，对所有图像数据做正则化。</p>
<p>我们基于前面的baseline，按照论文思路做出PCB分块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCB</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, class_num )</span>:</span></span><br><span class="line">        super(PCB, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.part = <span class="number">6</span> </span><br><span class="line">        model_ft = models.resnet50(pretrained=<span class="literal">True</span>)</span><br><span class="line">        self.model = model_ft</span><br><span class="line">        self.avgpool = nn.AdaptiveAvgPool2d((self.part,<span class="number">1</span>))</span><br><span class="line">        self.dropout = nn.Dropout(p=<span class="number">0.5</span>)</span><br><span class="line">        self.model.layer4[<span class="number">0</span>].downsample[<span class="number">0</span>].stride = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        self.model.layer4[<span class="number">0</span>].conv2.stride = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.part):</span><br><span class="line">            name = <span class="string">'classifier'</span>+str(i)</span><br><span class="line">            setattr(self, name, ClassBlock(<span class="number">2048</span>, class_num, droprate=<span class="number">0.5</span>, relu=<span class="literal">False</span>, bnorm=<span class="literal">True</span>, num_bottleneck=<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.model.conv1(x)</span><br><span class="line">        x = self.model.bn1(x)</span><br><span class="line">        x = self.model.relu(x)</span><br><span class="line">        x = self.model.maxpool(x)</span><br><span class="line"></span><br><span class="line">        x = self.model.layer1(x)</span><br><span class="line">        x = self.model.layer2(x)</span><br><span class="line">        x = self.model.layer3(x)</span><br><span class="line">        x = self.model.layer4(x)</span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        x = self.dropout(x)</span><br><span class="line">        part = &#123;&#125;</span><br><span class="line">        predict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.part):</span><br><span class="line">            part[i] = torch.squeeze(x[:,:,i])</span><br><span class="line">            name = <span class="string">'classifier'</span>+str(i)</span><br><span class="line">            c = getattr(self,name)</span><br><span class="line">            predict[i] = c(part[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        y = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.part):</span><br><span class="line">            y.append(predict[i])</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCB_test</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,model)</span>:</span></span><br><span class="line">        super(PCB_test,self).__init__()</span><br><span class="line">        self.part = <span class="number">6</span></span><br><span class="line">        self.model = model.model</span><br><span class="line">        self.avgpool = nn.AdaptiveAvgPool2d((self.part,<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># remove the final downsample</span></span><br><span class="line">        self.model.layer4[<span class="number">0</span>].downsample[<span class="number">0</span>].stride = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        self.model.layer4[<span class="number">0</span>].conv2.stride = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.model.conv1(x)</span><br><span class="line">        x = self.model.bn1(x)</span><br><span class="line">        x = self.model.relu(x)</span><br><span class="line">        x = self.model.maxpool(x)</span><br><span class="line"></span><br><span class="line">        x = self.model.layer1(x)</span><br><span class="line">        x = self.model.layer2(x)</span><br><span class="line">        x = self.model.layer3(x)</span><br><span class="line">        x = self.model.layer4(x)</span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        y = x.view(x.size(<span class="number">0</span>),x.size(<span class="number">1</span>),x.size(<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>



<p> 在运行一个epoch的时间上比较如下表（基于Market-1501） </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114160539.png" alt=""></p>
<p> 可以看出，PCB方法的训练时间远比基线网络的要长，这是由于局部特征的分块计算。每一个part损失函数都不一样，计算量更大，同时，加入了几个策略，REA为数据扩展方法，增加了数据，而dropout等策略则增加了计算量，因而耗费了更多的训练时间。 </p>
<p> 对模型参数的实验是ReID任务的重要步骤，原论文中并没有给出所有的参数设置，所以需要我们的实验和调整。由于GPU显存为8G，所以我们的batchsize规定为32，对于epochs,我们做了多组实验，以top1和mAP作为主要指标，结果如图。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114160944.png" alt=""></p>
<p> 对于分块参数P的讨论，实验结果如下(基于Market-1501)。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114161045.png" alt=""></p>
<p> 对于指标mAP和Rank-1，分别做了两组实验，一个是基于基本骨干网络的PCB，即没有加入第三章的策略，一个是加入了第三章的训练策略。由于Re-ranking可以较大幅度的提高mAP，而我们更关注的是训练算法和模型本身，所以计算结果并没有做重排序。 </p>
<p> 从图可以看出，我们的tricks对模型的性能是有着较大提升的，同时，分块参数P=6时，模型的性能最佳。也就是说，原始的行人照片被分成六等份。从直观上的理解来看，6等份恰好可以适当的表示行人的6部分特征，而再细分的话，可能在语义上就重复了，比如一个人的小腿都被划成了几小块，实际上，小腿作为一个特征去训练似乎是最合理的。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114161155.png" alt=""></p>
<p> 上图为在Market-1501数据集上，训练过程的可视化，我们训练了80个epochs的数据，初始学习率为0.05，在第30个epochs时的学习率降为0.005，可以看到，loss有个突降，当学习率被调小时，相当于梯度下降的步长变得更小，寻找最优解变得更仔细，说明模型进入了更为细致的学习。在第60个epochs时候降为0.0005，可以看出,loss已经基本不变了，说明了模型的学习到了极限。观察train loss和val loss,<strong>整个过程中，无论tran loss是下降还是不变，val loss都没有上升，说明了模型没有发生过拟合，我们的tricks是有效的。</strong> </p>
<p> 模型在三个数据集上的评测结果如下： </p>
<p> <img src="https://pic1.zhimg.com/80/v2-c7197b0a6665a624d3dece0bb10b8c54_hd.jpg" alt="img"> </p>
<p>从上表可以看出，基于局部特征的PCB方法相对于基线网络的全局特征学习，具有更好的搜索效果，局部特征更关注图像的细节，而在PCB方法中，我们在测试的时候结合了降维前的特征分块和降维后的特征分块，而不是仅仅用降维后的特征分块训练，也保证了特征图谱中细粒度的特征不会被丢失。从表中还可以看出，我们的tricks对model性能的改进也很有帮助。</p>
<p>下面给出基于我们的baseline的PCB模型在三个数据集（Market-1501、DukeMTMC-reID和CUHK-03）上搜索目标行人的一个demo。</p>
<p> <img src="https://pic3.zhimg.com/80/v2-217f4b7b2f5c9e86561eb27743e3c7be_hd.jpg" alt="img"> </p>
<p> <img src="https://pic2.zhimg.com/80/v2-2547fbadada1df2c32b749200d49e289_hd.jpg" alt="img"> </p>
<p> <img src="https://pic1.zhimg.com/80/v2-6c779df9af9e424ca5e3ae1f6f1017a0_hd.jpg" alt="img"> </p>
]]></content>
  </entry>
  <entry>
    <title>ReID  construct baseline</title>
    <url>/jontyhuang.github.io/2019/11/14/ReID-construct-baseline/</url>
    <content><![CDATA[<h1 id="1-baseline的构建及ResNet-50的模型迁移"><a href="#1-baseline的构建及ResNet-50的模型迁移" class="headerlink" title="1 baseline的构建及ResNet-50的模型迁移"></a>1 baseline的构建及ResNet-50的模型迁移</h1><p> 什么是baseline? 即所谓的基线网络，就是为个性化的模型提供基础框架和算法。 </p>
<a id="more"></a>

<h2 id="1-1经典CNN的缺陷以及ResNet成因"><a href="#1-1经典CNN的缺陷以及ResNet成因" class="headerlink" title="1.1经典CNN的缺陷以及ResNet成因"></a>1.1经典CNN的缺陷以及ResNet成因</h2><p> 在深度学习中的一个重要思想是模型的深度和模型的准确率有着很大的关系，例如在CV领域中，由卷积层，池化层和全连接构成了经典CNN网络，如LeNet。CNN的网络层数越多，可以学习到更多层的特征。考虑到网络层数的增加，必然会使网络变得更复杂，训练成本也越高。此外，增加网络层数并不一定能达到好的模型效果。何凯明曾做过实验：应用在CIFAR-10的数据集上训练了两个经典CNN网络（由卷积层，池化层，全连接层构成），一个20层，一个56层，实验结果如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114123556.png" alt=""></p>
<p>从结果上可以看出，56-layer的模型性能比20-layer差，且层数加深，效果却变差。并且这不是模型过拟合所导致的，因为如果过拟合导致的测试不理想，那么在训练集上的效果应该是非常好才对。</p>
<p>造成这种结果的原因有两个：一个是<strong>随着神经网络的层数加深，很可能发生梯度消失或梯度爆炸</strong>，这两种梯度现象均会招致模型在迭代的时候出现错误的梯度引导，结果使模型的收敛存在问题；另一个是<strong>退化现象</strong>，即随着网络的层次加深，假如在之前某一层已经达到了很好的输出效果，那么后续的网络结构会削弱前面的好效果的，也就是网络的学习能力遭受了退化。</p>
<p>考虑上述第二种原因，如果使得后续的网络不影响前面的最优结果，设计的目的也达到了，这也是ResNet设计的初衷</p>
<h2 id="1-2-ReNet以及finutune一个初始化参数的网络"><a href="#1-2-ReNet以及finutune一个初始化参数的网络" class="headerlink" title="1.2 ReNet以及finutune一个初始化参数的网络"></a>1.2 ReNet以及finutune一个初始化参数的网络</h2><p> 微软亚研院何凯明博士借助深度残差网络，在众多CV算法比赛中成为冠军，同时其论文也获得了2016年CV顶会的最佳论文，ResNet也获得了很好的声誉，这在很大程度上导致了深度学习的革命。 </p>
<p> ResNet的重点部件是其残差模块，如图所示。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114123825.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114124019.png" alt=""></p>
<p> 残差网络单元其中可以分解成上面右图的形式，从图中可以看出，残差网络其实是由多种路径组合的一个网络，直白了说，残差网络其实是很多并行子网络的组合，整个残差网络其实相当于一个多人投票系统（Ensembling）。如果把残差网络理解成一个Ensambling系统，那么网络的一部分就相当于少一些投票的人，如果只是删除一个基本的残差单元，对最后的分类结果应该影响很小；而最后的分类错误率应该适合删除的残差单元的个数成正比的，论文里的结论也印证了这个猜测。 </p>
<p> ResNet的确可以做到很深，但是从上面的介绍可以看出，网络很深的路径其实很少，大部分的网络路径其实都集中在中间的路径长度上，如下图所示： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114124214.png" alt=""></p>
<p>我们可以看出大多数的梯度其实都集中在中间的路径上，论文里称为effective path。 从这可以看出其实ResNet只是表面上看起来很深，事实上网络却很浅。 所以ResNet真的解决了深度网络的梯度消失的问题了吗？似乎没有，ResNet其实就是一个多人投票系统。</p>
<p>在我们的ReID任务中，我们采用50层的深度残差网络ResNet-50作为基线网络，并且在使用ResNet-50的时候需要做一个finetune迁移学习。finetune是一种重要的迁移学习方式，即通过微调，不用对模型的各个参数进行重新训练。finetune一般都是基于一个大数据集预训练下的网络，对于一个数据量不是很大的深度学习任务，finetune也可以比避免因模型复杂而数据不够造成的过拟合学习。</p>
<p> 在我们的ReID任务中，我们的finetune的是一个ResNet-50网络，它最初是基于一个大数据集的初始训练。PyTorch的模型库中初始训练的ResNet-50的示意图如图。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114124830.png" alt=""></p>
<p> 模型<strong>需要finetune的是特征图谱和最终全连接层的分类标签</strong>。实验中，我们基于PyTorch，在模型库里面可以加载预训练网络，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models         <span class="comment">#torchvision库中的models包含了一些常用网络模型以及训练好的参数</span></span><br><span class="line">model_ft = models.resnet50(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p> pretrained参数为True则继承了模型库中的模型参数和结构，若为false则只加载模型结构，也就失去了finetune的意义。 </p>
<h1 id="2-模型的一些trciks"><a href="#2-模型的一些trciks" class="headerlink" title="2. 模型的一些trciks"></a>2. 模型的一些trciks</h1><p>tricks是个很只可言传不可意会的东西，因为很多论文包括一些顶会的论文都用到了一些tricks来提高跑分的分数却在论文中不说。</p>
<p>这里我们说几个常用的：</p>
<h2 id="2-1-REA"><a href="#2-1-REA" class="headerlink" title="2.1 REA"></a>2.1 REA</h2><p>数据扩展常作为一种增强训练效果的策略，它可以使有限的数据集经过算法获得更多的数据。</p>
<p> 随即擦除增广（Random Erasing Augmentation，REA）是一种基于随机擦除的数据扩展方法。算法思路为在图像中随机选择一个区块，掩盖上噪声区块。随机擦除是一种数据扩展的方式，可以降低模型过拟合的程度，因此可以提升模型的性能。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114125455.png" alt=""></p>
<p> 实验中采用原论文设置的参数，应用在一个batch的Market1501 数据集上的效果如图。 </p>
<p> <img src="https://pic3.zhimg.com/80/v2-2c11aa8316fad61151288377b22f0656_hd.jpg" alt="img"> </p>
<h2 id="2-2-动态学习率机制"><a href="#2-2-动态学习率机制" class="headerlink" title="2.2 动态学习率机制"></a>2.2 动态学习率机制</h2><p> 学习率（learning rate，lr）是深度学习的一个关键参数，它参与了优化器下降的步长，决定了网络参数更新的速度。一般而言，lr越大，更容易收敛，但下降步长过大容易错过最优解，学习率越小，下降步长越小，但网络收敛的更慢，同时也更容易陷入局部的最佳解。下图反映来不同学习率对优化器寻找损失最小值的表现。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114125556.png" alt=""></p>
<p> 在一个ReID任务中，我们设定了动态调整学习率的机制，即随着不同epochs数据的训练，模型的学习率是不同的，具体如何调整学习率需要观测训练过程的loss。一般而言，初始的lr设为较大值，以使模型能快速收敛，且不错过局部最优，等loss不再降低的时候，适当调小学习率，梯度下降的步长更小，使得模型学习的更细致。 </p>
<p> 罗浩大佬采用的一个warm up策略，<a href="https://link.zhihu.com/?target=http%3A//openaccess.thecvf.com/content_CVPRW_2019/papers/TRMTMCT/Luo_Bag_of_Tricks_and_a_Strong_Baseline_for_Deep_Person_CVPRW_2019_paper.pdf">论文链接（CVPR 2019）</a>。 </p>
<p> 按作者所说：Warmup学习率并不是一个新颖的东西， 在很多task上面都被证明是有效的，在之前的工作中也有过验证。标准Baseline使用是的常见阶梯下降型学习率，初始学习率为3.5e-4，总共训,120个epoch，在第40和70个epoch进行学习率下降。用一个很大的学习率初始化网路可能使得网络震荡到一个次优空间，因为网络初期的梯度是很大的。Warmup的策略就是初期用一个逐渐递增的学习率去初始化网络，渐渐初始化到一个更优的搜索空间。下图是论文中用最简单的线性策略，即前10个epoch学习从0逐渐增加到初始学习率。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114125754.png" alt=""></p>
<h2 id="2-3-特征图扩张"><a href="#2-3-特征图扩张" class="headerlink" title="2.3 特征图扩张"></a>2.3 特征图扩张</h2><p> 在使用ResNet-50作为backbone的时候，最后一层卷积层之后会接一个下采样，也就是最后一个卷积层的stride参数为2。在ReID中，输入图像为256*128，经过特征提取网络之后得到的特征图为8*4。考虑到更好的学习特征，一个策略就是扩大特征图的尺寸，也就是将最后一个卷积层的stride参数变为1，这样特征图尺寸就变为16*8。更大的特征图能体现到更多的特征，也就可以提升模型的学习能力。 </p>
<h1 id="3-计算结果分析代码地址"><a href="#3-计算结果分析代码地址" class="headerlink" title="3. 计算结果分析代码地址"></a>3. 计算结果分析<a href="https://github.com/lixiangwang/Person-ReID">代码地址</a></h1><h2 id="3-1-数据载入和预处理"><a href="#3-1-数据载入和预处理" class="headerlink" title="3.1 数据载入和预处理"></a>3.1 数据载入和预处理</h2><p> 在PyTorch中，ImageFolder和DataLoader函数可以载入指定路径的数据： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_datasets = &#123;&#125;</span><br><span class="line"><span class="comment">#ImageFolder 数据加载器，指定路径下加载并执行组合好的transforms操作</span></span><br><span class="line">image_datasets[<span class="string">'train'</span>] = datasets.ImageFolder(os.path.join(data_dir, <span class="string">'train'</span> + train_all),</span><br><span class="line">                                          data_transforms[<span class="string">'train'</span>])</span><br><span class="line">image_datasets[<span class="string">'val'</span>] = datasets.ImageFolder(os.path.join(data_dir, <span class="string">'val'</span>),</span><br><span class="line">                                                data_transforms[<span class="string">'val'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.utils.data.DataLoader：</span></span><br><span class="line"><span class="comment">#该接口主要用来将自定义的数据读取接口的输出或者PyTorch已有的数据读取接口的输入按照batch size封装成Tensor，后续只需要再包装成Variable即可作为模型的输入</span></span><br><span class="line"><span class="comment">#shuffle 是否将图片打乱 / num_workers：使用多少个子进程来导入数据 /pin_memory： 在数据返回前，是否将数据复制到CUDA内存中</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">dataloaders = &#123;x:torch.utils.data.DataLoader(image_datasets[x],batch_size=opt.batchsize, shuffle=<span class="literal">True</span>, num_workers=<span class="number">8</span>, pin_memory=<span class="literal">True</span>)<span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">'train'</span>, <span class="string">'val'</span>]&#125;</span><br></pre></td></tr></table></figure>

<p> 数据加载进来后需要预处理： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_train_list = [</span><br><span class="line">        <span class="comment">#transforms.RandomResizedCrop(size=128, scale=(0.75,1.0), ratio=(0.75,1.3333), interpolation=3), #Image.BICUBIC)</span></span><br><span class="line">        transforms.Resize((<span class="number">256</span>,<span class="number">128</span>), interpolation=<span class="number">3</span>),    <span class="comment">#重置图像大小（分辨率），interpolation为插值方法</span></span><br><span class="line">        transforms.Pad(<span class="number">10</span>),                               <span class="comment">#填充</span></span><br><span class="line">        transforms.RandomCrop((<span class="number">256</span>,<span class="number">128</span>)),                 <span class="comment">#按指定尺寸随机裁剪图像（中心坐标随机）</span></span><br><span class="line">        transforms.RandomHorizontalFlip(),                <span class="comment">#以0.5概率使图像随机水平翻转  （这些都是增强数据的实际效果，泛化性等）</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])      <span class="comment">#数据归一化</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">transform_val_list = [</span><br><span class="line">        transforms.Resize(size=(<span class="number">256</span>,<span class="number">128</span>),interpolation=<span class="number">3</span>), <span class="comment">#Image.BICUBIC</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>Transform是torchvision中的图像处理库。由于数据集的图像大小可能不同，我们需要统一训练数据的大小，transforms.Resize函数可以重置图像大小。</p>
<p>transforms.RandomCrop和transforms.RandomHorizontalFlip分别为随机裁剪和水平翻转，均为数据扩展的处理方法。在计算机视觉中，我们计算一副图像需要对其做标准化，即减去均值和除以标准差，在此之前需要将数据转换为tensor的格式才能计算。</p>
<h2 id="3-2-实验分析"><a href="#3-2-实验分析" class="headerlink" title="3.2 实验分析"></a>3.2 实验分析</h2><p>深度学习的训练需要大量的时间，因次，模型的调参是每个深度学习任务的重要步骤之一。由前文的叙述可知，实验我们采用了finetune的方式加载了一个预训练好的网络，并在此基础上加入了若干组训练策略。</p>
<p>在训练时间的比较中，我们规定batchsize为32，epoch的个数为80，均在Market-1501上的训练，实验结果如下表。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114154623.png" alt=""></p>
<p>实验中并没有考虑学习率变化的影响，应为学习率和梯度下降的方法一样，如果模型收敛较慢，只要是还在收敛，只要epochs数量足够，它对最终的训练时间是没有影响的。从表可以看到，几个明显增强训练时间的步骤是dropout和REA，dropout增大了网络的计算量，而REA则是增加了数据，带来了更大的时间开销。</p>
<p>关于数据预处理阶段图像统一尺寸的讨论：我们实验了几组重置后的尺寸，采用相同的算法(没有做Re-ranking)，在Market-1501上得到如下计算结果：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114154757.png" alt=""></p>
<p>从上表中可以看到，同一算法和数据集下，图像重置后的尺寸对实的结果影响不大，我们认为图像resize后的具体大小对模型的评测是没有大的影响的，所以为了方便起见，我们所有图像的大小在预处理阶段均resize到256*128的尺寸。实验中，我们实验了三个数据集：Market-1501，DukeMTMC-reID，CUHK-03。</p>
<p>随机选择Market-1501训练数据集中每个ID的一张图片作为val_set，其余图片作为train_set。批量大小设置为32，ResNet-50主干网络训练60个epochs，加入训练技巧后的网络训练80个epochs。 在增加训练技巧之前，训练过程中的损失曲线和top1误差曲线如下图。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114154839.png" alt=""></p>
<p> 初始学习率为0.05，前30个epochs的lr为0.05，30-60个epochs的lr为0.005，从train loss和val loss的曲线可以看出，模型收敛是比较快的，train_set的效果低于val_set的学习效果是由于模型本身的不足导致的，可以看到，训练后续学习平稳，且没有产生过拟合的现象。下图为加入训练策略后的训练情况。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155022.png" alt=""></p>
<p> 加入策略后，由于数据增多，计算变得更复杂，所以数据一共训练了80个epochs，前40个epochs的lr为0.05，后40个epochs的lr为0.005.图中可以明显看到，加入策略后，模型的收敛变慢了，在学习率调整后，模型得到了进一步学习，且train loss和val loss均保持平稳，没有过拟合的现象发生。 </p>
<p> DukeMTMC-reID和CUHK-03的训练过程和Market-1501类似，train-val组合验证的意义是监测过拟合的发生，而dropout也避免了过拟合。三组数据集在模型下的表现性能如下表： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155122.png" alt=""></p>
<p>从表中可以看出，加入的训练策略在三个数据集中均可以明显提高模型的性能。从结果上来看，三个数据集中难度最大的为CUHK-03，而CUHK-03数据集本身就具有很多的挑战性，比如在一个ID的标注框中却不止一个行人。</p>
<p>下为近两年的流行算法以及我们的基线网络性能上的对比。其中，our baseline是基于backbone为ResNet-50网络加上几个策略，并且没有做Re-ranking。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155148.png" alt=""></p>
<p> 从上表可以看到，我们的基线网络经过若干优化之后的性能还是很强的，这说明几个策略极大的改善了模型的性能，可以作为更复杂模型的基线网络。 </p>
<p> 下面三张分别为Market-1501、DukeMTMC-reID和CUHK-03的一组演示demo。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155247.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155256.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114155312.png" alt=""></p>
<p> query为待查询图像，右边列出gallery库中相似度排名前10的图像，绿色的编号表示查找正确，红色的编号表示查询错误。第三张图的CUHK-03的demo可以看到带查询图像特征很不明显，任务不清晰，且一框图片中可能存在多个人，为重识别一个很大的难点，目前来说，CUHK-03仍然是难度很大的数据集之一。 </p>
]]></content>
  </entry>
  <entry>
    <title>ReID what is it</title>
    <url>/jontyhuang.github.io/2019/11/14/ReID-what-is-it/</url>
    <content><![CDATA[<h1 id="什么是ReID"><a href="#什么是ReID" class="headerlink" title="什么是ReID"></a>什么是ReID</h1><p>ReID，也就是 Re-identification，其定义是利用算法，在图像库中找到要搜索的目标的技术，所以它是属于图像检索的一个子问题。</p>
<p>为什么会有这个方向呢？来看大背景：随着社会的发展，公共安全成为全社会的一个共同话题，与之相辅相成的视频监控系统也得到了大量的普及。视频监控系统可以直观的再现目标场景，可作为公安侦破案件的强力辅助。在执法部门的工作中，目标的识别和定位是及其关键的一步，然而现有的监控部署下，这个关键步骤几乎是靠着人力完成的。在这个讲究数据和效率的时代，通过人工观察监控录像查找结果显然存在着很大的资源浪费以及效率的低下。另外，由于摄像头的分辨率等硬件缺陷，很难得到清晰的人身图像，因此，已经大力推广的人脸识别技术已不再适用此场景。由于传统人工查询的不便性以及人脸识别的无法应用，研究者思考如何发明一项更合适的技术来取代人脸识别，能在监控领域以机器代替人力分析呢？故此，行人重识别（P-edestrian Re-identification，ReID）的研究也应随之展开。</p>
<p>说白了，在监控拍不到人脸的情况下，ReID可以代替人脸识别来在视频序列中找到我要找到目标对象。那么他的应用就很广了，可以做安防，可以做个人定位，在商场上可以配合推荐系统，搭建出个性化的推荐服务等等。下面一张图可以生动的解释它在安防的一个应用场景。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114111659.png" alt=""></p>
<a id="more"></a>

<h1 id="如何做ReID"><a href="#如何做ReID" class="headerlink" title="如何做ReID"></a>如何做ReID</h1><p> 从前面讲的，我们已经大致知道ReID是干什么的了，似乎就是去检索出一个目标对象。这里我会具体去讲这个任务如何去做。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112034.png" alt=""></p>
<p> 上面这张图向我们展示了ReID的一个任务过程，<strong>首先要做的是Detection，也就是检测出行人，其实这一步数据集已经帮我们做到了，下面介绍数据集的时候会讲到不同数据集采用的不同的目标检测方法以及ID的标注方式。剩下的部分，就是要去训练一个特征提取网络，根据特征所计算的度量距离得到损失值，我们选用一个优化器去迭代找到loss最小值，并不断更新网络的参数达到学习的效果。在测试的时候，我们用将要检索的图片（称为query或者probe），在底库gallery中，根据计算出的特征距离进行排序，选出最TOP的几张图片，来达到目标检索的目的。下面两张图分别是训练阶段和测试阶段的示意图：</strong> </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112143.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112211.png" alt=""> </p>
<p> 测试阶段中，我们利用训练后的网络计算特征从所有搜索到的图像中提取特征，并计算搜索图与地库之间的特征距离。然后根据计算出的距离对它们进行排序。排名越高，相似性越高，上图中，绿色边框的是正确检索的结果，红色边框的是错误检索的结果。 </p>
<h1 id="ReID数据集"><a href="#ReID数据集" class="headerlink" title="ReID数据集"></a>ReID数据集</h1><p> ReID的数据集已经完成的任务是行人检测以及对应的ID标注，因此一个数据集的好坏对于ReID的研究是至关重要的。目前学术界最常用的数据集有三个：Market1501、DukeMTMC-reID、CUHK-03。 </p>
<h2 id="1-Market-1501"><a href="#1-Market-1501" class="headerlink" title="1)Market-1501"></a>1)Market-1501</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112315.png" alt=""></p>
<p> Market-1501 数据集在清华大学校园中采集，夏天拍摄，在 2015 年构建并公开。它包括由6个摄像头（其中5个高清摄像头和1个低清摄像头）拍摄到的 1501 个行人、32668 个检测到的行人矩形框。每个行人至少由2个摄像头捕获到，并且在一个摄像头中可能具有多张图像。训练集有 751 人，包含 12,936 张图像，平均每个人有 17.2 张训练数据；测试集有 750 人，包含 19,732 张图像，平均每个人有 26.3 张测试数据。3368 张查询图像的行人检测矩形框是人工绘制的，而 gallery 中的行人检测矩形框则是使用DPM检测器检测得到的。该数据集提供的固定数量的训练集和测试集均可以在single-shot或multi-shot测试设置下使用。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112359.png" alt=""></p>
<p>目录介绍：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112436.png" alt=""></p>
<h2 id="2）DukeMTMC-reID"><a href="#2）DukeMTMC-reID" class="headerlink" title="2）DukeMTMC-reID"></a>2）DukeMTMC-reID</h2><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112531.png" alt=""></p>
<p> DukeMTMC-reID 于杜克大学内采集。DukeMTMC 数据集是一个大规模标记的多目标多摄像机行人跟踪数据集。它提供了一个由 8 个同步摄像机记录的新型大型高清视频数据集，具有 7,000 多个单摄像机轨迹和超过 2,700 多个独立人物，DukeMTMC-reID 是 DukeMTMC 数据集的行人重识别子集，并且提供了人工标注的bounding box。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112606.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114112731.png" alt=""></p>
<h1 id="ReID评测指标"><a href="#ReID评测指标" class="headerlink" title="ReID评测指标"></a>ReID评测指标</h1><p>这里需要参考周志华老师西瓜书的第二章内容。看过这本书的同学都知道，Cumulative Matching Characteristics (CMC) 是目前计算机视觉领域最流行的性能评估方法。在ReID任务中，考虑一个简单的 single-gallery-shot 情形（即单个对象图像的检索），每个数据集中的ID(gallery ID)只有一个实例. 对于每一次的识别(query), 算法将根据要查询的图像(query) 到所有gallery samples的距离从小到大排序。比如说Market-1501中 Query 和 gallery 集可能来自相同的摄像头视角，但是对于每个query identity, 他/她的来自同一个摄像头的 gallery samples 会被排除掉。对于每个 gallery identity，他们不会只随机采样一个instance. 这意味着在计算CMC时， query 将总是匹配 gallery 中“最简单”的正样本，而不关注其他更难识别的正样本。bounding_box_test 文件夹是 gallery 样本，bounding_box_train 文件夹是 train 样本，query 文件夹是 query 样本。</p>
<p>所以，如果在 multi-gallery-shot 情形下，CMC评估具有缺陷。因此，也使用 mAP（mean average precsion）作为评估指标。mAP可认为是PR曲线下的面积，即平均的查准率。</p>
<p><strong>（关于这里面mAP，CMC，ROC，PR曲线，查准率（precision），查全率（recall）等是啥请参考西瓜书2.3节）</strong></p>
<p>所以，这里我们一般采用两个指标:</p>
<p>1) <strong>首次命中率（rank-1）</strong>：表示在候选库中得到与检索目标相似度排名最高的图片为目标行人的概率。</p>
<p>2) <strong>平均精度均值（mAP）</strong>：对于一些数据集来说，一张probe图像在gallery中可能有多张相匹配的图像，而mAP则是同时考虑了准确率和召回率，更能客观反映模型的性能。</p>
<p><strong>下一篇将结合理论和代码讲述如何构建一个baseline网络，包括迁移学习finetune一个backbone，以及几个训练模型的tricks。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>cv Harris Corner</title>
    <url>/jontyhuang.github.io/2019/11/12/cv-Harris-Corner/</url>
    <content><![CDATA[<h1 id="Harris-角检测"><a href="#Harris-角检测" class="headerlink" title="Harris 角检测"></a>Harris 角检测</h1><p> 在做图像匹配时，常需要对两幅图像中的特征点进行匹配。为了保证匹配的准确性，所选择的特征必须有其独特性，角点可以作为一种不错的特征。 </p>
<p>那么为什么角点有其独特性呢？角点往往是两条边缘的交点，它是两条边缘方向变换的一种表示，因此其两个方向的梯度变换通常都比较大并且容易检测到。</p>
<a id="more"></a>

<p>这里我们理解一下Harris Corner 一种角点检测的算法</p>
<p>角点检测基本原理：  人们通常通过在一个小的窗口区域内观察点的灰度值大小来识别角点，如果往任何方向移动窗口都会引起比较大的灰度变换那么往往这就是我们要找的角点。如下图右</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112222554.png" alt=""></p>
<ul>
<li>“FALT”第一幅图像，由于是平坦区域，所以像素值在任何方向都没有变化，</li>
<li>“EDGE”第二幅图像，由于在边缘上，沿着边界线移动像素值不会有变化</li>
<li>“CORNER” 第三幅图像，在任何方向都会发生很大的变化。</li>
</ul>
<p>下面我们看一下Harris的数学公式，对于[x,y]平移[u,v]个单位后强度的变换有下式,I(x+u,y+v)是平移后的强度，I(x,y)是原图像像素。对于括号里面的值，如果是强度恒定的区域，那么它就接近于零，反之如果强度变化剧烈那么其值将非常大，所以我们期望E(u,v)很大。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112225845.png" alt=""></p>
<p>其中w是窗函数，它可以是加权函数，也可以是高斯函数 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230103.png" alt=""></p>
<p> 利用二维泰勒展开式我们有 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230023.png" alt=""></p>
<p>所以其中一阶可以近似为</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230212.png" alt=""></p>
<p> 于是我们可以给出Harris Corner的如下推导，其中Ix，Iy是x，y方向的Gradient模，乘以位移得到位移后的量 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230235.png" alt=""></p>
<p> 对于小的位移，我们可以用双线性插值方法近似： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230325.png" alt=""></p>
<p> 其中M为2*2矩阵如下 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230438.png" alt=""></p>
<p> 在本质上我们可以把二次项看成一个椭圆函数，<strong>我们对M进行特征值分析有λ1，λ2 （利用实对称矩阵都可以正交相似对角化）</strong></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112230645.png" alt=""></p>
<p>根据λ1，λ2的值我们可以把其分为三类：</p>
<p>1.λ1，λ2都很小且近似，E在所有方向接近于常数；</p>
<p>2.λ1&gt;&gt;λ2,或者λ2&gt;&gt;λ1, E将在某一方向上很大；</p>
<p>3.λ1，λ2都很大且近似，E将在所有方向上很大；</p>
<p>下图是一个例子：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191113002129.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191113002209.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191113002218.png" alt=""></p>
<p>如图所示：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112231234.png" alt=""></p>
<p> 最后我们通过计算角点响应值R来判断其属于哪个区间 ：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112231737.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112231746.png" alt=""></p>
<p> 其中k一般为常数取在0.04-0.06间。 R超过一定的阈值，则认为该点是角点，阈值设置是Harris角点检测算法的关键， 阈值设置过大会产生伪角点，阈值过小则会漏掉角点。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232058.png" alt=""></p>
<p> 算法步骤： </p>
<p> 1.计算图像x,y方向的梯度Ix，Iy ，使用高斯导数滤波器</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232215.png" alt=""></p>
<p> 2.计算每个像素点的梯度平方 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232236.png" alt=""></p>
<p> 3.计算梯度在每个像素点的和 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232258.png" alt=""></p>
<p> 4.定义在每个像素点的矩阵H，也就是前面的M </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232431.png" alt=""></p>
<p> 5.计算每个像素的角点响应 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112232528.png" alt=""></p>
<p> 6.设置阈值找出可能点并进行非极大值抑制 </p>
]]></content>
      <categories>
        <category>basic learning of cv</category>
      </categories>
  </entry>
  <entry>
    <title>cv image differentiation</title>
    <url>/jontyhuang.github.io/2019/11/10/cv-image-differentiation/</url>
    <content><![CDATA[<h1 id="图像的微分"><a href="#图像的微分" class="headerlink" title="图像的微分"></a>图像的微分</h1><p>在图像中，边缘可以看做一阶导数较大的像素处，因此我们可以使用图像的一阶导数来确定图像的边缘，像sobel等一系列算子都是基于这个思想的。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110191658.png" alt="函数图像"></p>
 <a id="more"></a>   

<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110191740.png" alt="一阶导"></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110191808.png" alt="二阶导"></p>
<p>上图的总结：<br>一阶微分：</p>
<ul>
<li>在恒定灰度值区域的微分值为零</li>
<li>在灰度台阶或斜坡微分值为零</li>
<li>沿着斜坡的微分值非零</li>
</ul>
<p>二阶微分：</p>
<ul>
<li>在恒定灰度区域的微分值为零</li>
<li>在灰度台阶或斜坡起点微分值为非零</li>
<li>沿着斜坡的微分值为零。</li>
</ul>
<p>总结:</p>
<ul>
<li>一阶导数在图像边缘产生较粗的边缘。如果是边缘的话，那么它的值变化不是如噪声那么大，这样一阶导数之间的差别不会很大，会产生一个缓坡，那么此处的二阶导数会更加平滑，意义不大。</li>
<li>二阶导数对于精细细节，如细线、孤立点、和噪声有较强的响应。譬如，如果是噪声的话，一阶导数在此处的值会比周围一定范围的内的值大很多，会产生一个高峰，因此其二阶导也会很大。</li>
<li>二阶导数在灰度斜坡和灰度台阶过度处产生双边响应，解释：由于一阶导数会有一个高峰，那么在高峰的底部其导数会非常大，因此会产生一个很明显的双边。</li>
<li>一阶导数的符号可以确定边缘的过渡是从亮到暗还是从暗到亮。解释：从亮到暗，它的一阶导数是负数，但是其负数变化</li>
<li>选导数提取边沿之前最好提取对图片做平滑，导数对噪声比较敏感。（譬如我们可以采取高斯滤波进行平滑操作）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112184617.png" alt=""></p>
<h1 id="图像一阶导的application"><a href="#图像一阶导的application" class="headerlink" title="图像一阶导的application"></a>图像一阶导的application</h1><h2 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h2><p>梯度方向是图像上某个像素点增长最快的方向，即方向导数中取最大值的方向。</p>
<p>梯度计算是图像边缘提取的重要中间步骤，根据x，y方向向量值，可以得到如下的重要参数振幅magnitude,角度theta。</p>
<p>图像的梯度计算如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110195112.png" alt=""></p>
<p>magnitude计算如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110195152.png" alt=""></p>
<p>但是为了节约计算资源，我们通常将上述公式省略为：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110195238.png" alt=""></p>
<p> Theta = tan-1(yGradient/xGradient) </p>
<p>magnitude表示边缘强度信息。</p>
<p>theta预言边缘方向走势。相对于水平方向的角度值。</p>
<p>当我们有一幅图像时，将某个像素点的对应值与其magnitude相加，则图像的边缘将被大大加强，轮廓会更加明显，是一个很典型的shape filter 的效果。</p>
<h2 id="梯度图像"><a href="#梯度图像" class="headerlink" title="梯度图像"></a>梯度图像</h2><p>由图像上各点梯度值所构成的图像成为梯度图像，往往在另一个矩阵中就是一个轮廓图。</p>
<h2 id="Roberts算子"><a href="#Roberts算子" class="headerlink" title="Roberts算子"></a>Roberts算子</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><p>Roberts算子又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。</p>
<p>Roberts算子的模板分为水平方向和垂直方向，如下式所示，从其模板可以看出，Roberts算子能较好的增强正负45度的图像边缘。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/gif.gif" alt=""></p>
<p> 例如，下面给出<strong>Roberts算子</strong>的<strong>模板</strong>，在<strong>像素点P5处</strong> <img src="https://private.codecogs.com/gif.latex?x" alt="x"> 和 <img src="https://private.codecogs.com/gif.latex?y" alt="y"> 方向上的梯度大小 <img src="https://private.codecogs.com/gif.latex?%7Bg%7D_%7Bx%7D%7D" alt="{g}_{x}}"> 和 <img src="https://private.codecogs.com/gif.latex?%7Bg%7D_%7By%7D%7D" alt="{g}_{y}}"> 分别计算为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112212103.png" alt=""></p>
<p>![](<a href="https://raw.githubusercontent.com/jontyhuang/PicGo/master/gif" target="_blank" rel="noopener">https://raw.githubusercontent.com/jontyhuang/PicGo/master/gif</a> (1).gif)</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213140.png" alt=""></p>
<h2 id="2-Prewitt算子"><a href="#2-Prewitt算子" class="headerlink" title="2.Prewitt算子"></a>2.Prewitt算子</h2><p>Prewitt算子是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用 3*3 模板对区域内的像素值进行计算，而Robert算子的模板为 2*2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像，其计算公式如下所示：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213337.png" alt=""></p>
<p>例如，下面给出<strong>Prewitt算子</strong>的<strong>模板</strong>，在<strong>像素点P5处</strong>x 和 y方向上的梯度大小gx和gy分别计算为:<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213354.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213424.png" alt=""></p>
<h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><p>Sobel算子是一种用于边缘检测的离散微分算子，它结合高斯平滑和微分求导。 该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。 </p>
<p> Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。 </p>
<p> Sobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中 <img src="https://private.codecogs.com/gif.latex?%7B%7Bd%7D_%7Bx%7D%7D" alt=""> 表示水平方向，<img src="https://private.codecogs.com/gif.latex?%7B%7Bd%7D_%7By%7D%7D" alt=""> 表示垂直方向。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213732.png" alt=""></p>
<p> 例如，下面给出<strong>Sobel算子</strong>的<strong>模板</strong>，在<strong>像素点P5处</strong> <img src="https://private.codecogs.com/gif.latex?x" alt="x"> 和 <img src="https://private.codecogs.com/gif.latex?y" alt="y"> 方向上的梯度大小 <img src="https://private.codecogs.com/gif.latex?%7Bg%7D_%7Bx%7D%7D" alt="{g}_{x}}"> 和 <img src="https://private.codecogs.com/gif.latex?%7Bg%7D_%7By%7D%7D" alt="{g}_{y}}"> 分别计算为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213807.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213818.png" alt=""></p>
<p> <img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112213843.png" alt=""> </p>
<h1 id="二阶导数应用：拉普拉斯"><a href="#二阶导数应用：拉普拉斯" class="headerlink" title="二阶导数应用：拉普拉斯"></a>二阶导数应用：拉普拉斯</h1><h1 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h1><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>用于检测团块，边缘检测，突出图像中的孤立点、孤立线或者线端点为目的的场合；图像的锐化操作（L3拉普拉斯变换后的图像与原图叠加）</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul>
<li><p>1）判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度值更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像的锐化操作。</p>
</li>
<li><p>2）在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系； </p>
</li>
<li><p>3） 最后通过梯度运算的结果对像素灰度进行调整。 </p>
<p>其中，Laplacian算子<strong>四邻域</strong>模板如下所示： </p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112214318.png" alt=""></p>
<p> Laplacian算子的<strong>八邻域</strong>模板如下所示： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191112214338.png" alt=""></p>
<p>通过Laplacian算子的模板可以发现：</p>
<ul>
<li><p>1）当邻域内像素灰度相同时，模板的卷积运算结果为0；</p>
</li>
<li><p>2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；</p>
</li>
<li><p>3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。</p>
</li>
</ul>
<h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>拉普拉斯算子是最简单的各向同性微分算子，具有旋转不变性。</p>
<p>一个二维图像f(x,y)的拉普拉斯微分算子的定义如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111224851.png" alt=""></p>
<p>将（2）和（3）式带入（1)得到（4）式：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111224906.png" alt=""></p>
<p><strong>正常推导为下式，上（2）式中二阶微分有问题</strong></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116003237.png" alt=""></p>
<p>写成权系数矩阵模板为（卷积形式）：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111225044.png" alt=""></p>
<p><strong>从模板我们可以看出，如果图像中一个较暗的区域出现一个亮点，用拉普拉斯变换会使这个亮点变得更亮。</strong></p>
<p>一般的增强技术对于陡峭的边缘和缓慢变换的边缘很难确定其边缘线的位置。但此算子却可用二微分正峰和负峰之间的过零点来确定，对孤立点或端点更为敏感。</p>
<p>还有其他几种拉普拉斯算子：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111225131.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111225155.png" alt=""></p>
<p>但是虽然是上述的卷积是负峰定义的拉普拉斯算子（即中心系数为负），正负系数均可以进行锐化操作。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116003331.png" alt=""></p>
<h3 id="图像的锐化"><a href="#图像的锐化" class="headerlink" title="图像的锐化"></a>图像的锐化</h3><p>图像的锐化操作实际就是</p>
<p>使灰度反差增强，从而使模糊图像变得更加清晰。图像模糊的实质就是图像受到平均运算或积分运算，因此可以对图像进行逆运算，如微分运算能够突出图像细节，使图像变得更为清晰。由于拉普拉斯是一种微分算子，它的应用可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域。因此，锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加而产生锐化图像。拉普拉斯锐化的基本方法可以由下式表示：</p>
<p>这种简单的锐化方法既可以产生拉普拉斯锐化处理的效果，同时又能保留背景信息，将原始图像叠加到拉普拉斯变换的处理结果中去，可以使图像中的各灰度值得到保留，使灰度突变处的对比度得到增强，最终结果是在保留图像背景的前提下，突现出图像中小的细节信息。</p>
<p>卷积实现如下:</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191111225204.png" alt=""></p>
<h1 id="各类算子的优缺点"><a href="#各类算子的优缺点" class="headerlink" title="各类算子的优缺点"></a>各类算子的优缺点</h1><h2 id="Roberts"><a href="#Roberts" class="headerlink" title="Roberts"></a>Roberts</h2><p>Robers算子利用局部差分算子寻找边缘，边缘定位精度较高，但是容易缺失一部分边缘，不具备抑制噪声的作用。该算子对具有陡峭边缘且含噪声少的图像效果会很好，尤其是边缘正负45度较多的图像，但是定位准确率较差。</p>
<h2 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h2><p>Sobel算子考虑了综合因素，对噪声较多的图像处理效果更好，Sobel 算子边缘定位效果不错，但检测出的边缘容易出现多像素宽度。</p>
<h2 id="Prewitt-算子"><a href="#Prewitt-算子" class="headerlink" title="Prewitt 算子"></a>Prewitt 算子</h2><p>Prewitt算子对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响，与Sobel 算子类似，不同的是在平滑部分的权重大小有些差异；</p>
<h2 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h2><p>Laplacian 算子不依赖于边缘方向的二阶微分算子，对图像中的阶跃型边缘点定位准确，该算子对噪声非常敏感，它使噪声成分得到加强，这两个特性使得该算子容易丢失一部分边缘的方向信息，造成一些不连续的检测边缘，同时抗噪声能力比较差，由于其算法可能会出现双像素边界，常用来判断边缘像素位于图像的明区或暗区，很少用于边缘检测；</p>
<h1 id="进阶版（高斯拉普拉斯算子Laplace-of-Gaussian）"><a href="#进阶版（高斯拉普拉斯算子Laplace-of-Gaussian）" class="headerlink" title="进阶版（高斯拉普拉斯算子Laplace of Gaussian）"></a>进阶版（高斯拉普拉斯算子Laplace of Gaussian）</h1><p>高斯拉普拉斯算子（LOG)基于高斯的一阶导数和二阶导数。上面我们提到拉普拉斯算子可以有效的反映出图像的边缘，但是对于噪声过于敏感，所以每次我们进行拉普拉斯变换的时候都需要先使用高斯函数进行平滑操作。这个时候就体现了高斯拉普拉斯算子的作用了。</p>
<p>一维高斯对应的x阶导数公式：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114073243.png" alt=""></p>
<p>二维高斯对应的导数公式：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114073341.png" alt=""></p>
<p>相应地，二维高斯函数的一阶、二阶梯度为：　 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114074038.png" alt=""></p>
<p> 　方向梯度为（角度取弧度）： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114074130.png" alt=""></p>
<p> 将梯度函数进行离散，可以得到一阶和二阶的梯度算子，使用这些算子与图像进行卷积，可以求取图像的一阶、二阶梯度以及各方向梯度。 </p>
<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>原图像与高斯卷积的表达式如下L:</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116000443.png" alt=""></p>
<p>数学推导公式如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116000739.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116001124.png" alt=""></p>
<p>上述公式少了一个系数，是由于工业中这个系数的作用不大，原函数的系数是为了函数积分值归一化，但是应用到卷积中，我们只需除以总值进行归一化。具体应该是</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116080138.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116070610.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/logcont.gif" alt=""></p>
<p>显示了一个近似于此函数的离散内核（对于高斯= 1.4） </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191116004020.png" alt="σ=1.4"></p>
<p> 随着高斯变得越来越窄，LoG内核变得与图1中所示的简单拉普拉斯内核相同。这是因为$\sigma$在离散网格上使用非常窄的高斯（&lt;0.5像素）进行平滑处理没有效果。因此，在离散网格上，简单的拉普拉斯算子可以看作是窄高斯LoG的极限情况。 </p>
<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p> LoG运算符计算图像的第二空间导数。这意味着在图像具有恒定强度（<em>即</em> 强度梯度为零）的区域中，LoG响应将为零。但是，在强度变化附近，LoG响应在较暗的一侧为正，而在较亮的一侧为负。这意味着在强度相同但强度不同的两个区域之间的合理锐利边缘处，LoG响应为： </p>
<ul>
<li>距离边缘很远时为零</li>
<li>正向边缘的一侧</li>
<li>在边缘另一侧为负</li>
<li>在边缘之间的某个点为零。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/logresp.gif" alt=""></p>
]]></content>
      <categories>
        <category>basic learning of cv</category>
      </categories>
  </entry>
  <entry>
    <title>cv-week1</title>
    <url>/jontyhuang.github.io/2019/11/09/cv-week1/</url>
    <content><![CDATA[<p><strong>本文原图像的长度为n,卷积核长度为f，卷积核步长为s。</strong></p>
<h1 id="为什么卷积核是奇数-奇数"><a href="#为什么卷积核是奇数-奇数" class="headerlink" title="为什么卷积核是奇数*奇数"></a>为什么卷积核是奇数*奇数</h1><p> 一是padding的原因，如果f是奇数，图像两边的padding是对称的。</p>
<p>第二点是奇数的卷积核 有central pixel 可以方便的确定position.  因为使用奇数尺寸的滤波器可简化索引，并更为直观，因为滤波器的中心落在整数值上。 </p>
<a id="more"></a>

<p>另：</p>
<p>举例，比如我们对4*4的图像进行2*2步长为1的卷积操作，输出图像长度为4-2+1.</p>
<p>通用公式为n-f+1。</p>
<p>我的理解是最后输出的结果其实卷积核的计算次数，n-f是卷积核接下来的操作次数，1是卷积核未滑动之前的次数。</p>
<p>我们为了获得和原图像大小相同的输出图像，进行padding操作。因此padding等于（f-1）/2。</p>
<h2 id="为什么需要padding"><a href="#为什么需要padding" class="headerlink" title="为什么需要padding"></a>为什么需要padding</h2><ul>
<li>图像会越来越小，再多次卷积之后，图像可能变的极小</li>
<li>图像的边界信息丢失，即图像的边界和角落的信息发挥作用比较少。</li>
</ul>
<p>因此为了解决上诉问题，我们在进行卷积操作之前填充这幅图像。</p>
<p>我们假设padding的长度为p。</p>
<p>当我们对图像进行填充之后，图像的长度变为（n+2p），那么最后输出的公式变为(n+2p-f+1)。而我们需要的是输入和输出的相同的，所以p= (f-1)/2。所以当f为奇数时，我们只需要填充相应的尺寸p即可。</p>
<h1 id="卷积步长不同计算公式"><a href="#卷积步长不同计算公式" class="headerlink" title="卷积步长不同计算公式"></a>卷积步长不同计算公式</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191110144843.png" alt=""></p>
<p>总结：</p>
<p>实际上，从技术的角度来说，图像的卷积操作其实互相关而不是卷积。数学上的卷积是存在一个镜像的操作，而图像的卷积则跳过了这个操作。</p>
]]></content>
      <categories>
        <category>basic learning of cv</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning of Cross validation</title>
    <url>/jontyhuang.github.io/2019/11/09/machine-learning-of-Cross-validation/</url>
    <content><![CDATA[<p><strong>一、训练集 vs. 测试集</strong></p>
<p>在模式识别（pattern recognition）与机器学习（machine learning）的相关研究中，经常会将数据集（dataset）分为训练集（training set）跟测试集（testing set）这两个子集，前者用以建立模型（model），后者则用来评估该模型对未知样本进行预测时的精确度，正规的说法是泛化能力（generalization ability）。怎么将完整的数据集分为训练集跟测试集，必须遵守如下要点：</p>
<p><strong>1、只有训练集才可以用在模型的训练过程中，测试集则必须在模型完成之后才被用来评估模型优劣的依据。<br>2、训练集中样本数量必须够多，一般至少大于总样本数的50%。<br>3、两组子集必须从完整集合中均匀取样。</strong></p>
<a id="more"></a>

<p>​    其中最后一点特别重要，均匀取样的目的是希望减少训练集/测试集与完整集合之间的偏差（bias），但却也不易做到。一般的作法是随机取样，当样本数量足 够时，便可达到均匀取样的效果，然而随机也正是此作法的盲点，也是经常是可以在数据上做手脚的地方。举例来说，当辨识率不理想时，便重新取样一组训练集/ 测试集，直到测试集的识别率满意为止，但严格来说这样便算是作弊了。</p>
<p>CV是用来验证分类器的性能一种统计分析方法,基本思想是把在某种意义下将原始数据(dataset)进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set),首先用训练集对分类器进行训练,在利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标.常见CV的方法如下:</p>
<h1 id="二交叉验证"><a href="#二交叉验证" class="headerlink" title="二交叉验证"></a>二交叉验证</h1><p>1).Hold-Out Method</p>
<p> 将原始数据随机分为两组,一组做为训练集,一组做为验证集,利用训练集训练分类器,然后利用验证集验证模型,记录最后的分类准确率为此Hold-OutMethod下分类器的性能指标.此种方法的好处的处理简单,只需随机把原始数据分为两组即可,其实严格意义来说Hold-Out Method并不能算是CV,因为这种方法没有达到交叉的思想,由于是随机的将原始数据分组,所以最后验证集分类准确率的高低与原始数据的分组有很大的关系,所以这种方法得到的结果其实并不具有说服性. </p>
<p>2).K-fold Cross Validation(记为K-CV)</p>
<p>将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性.</p>
<p> 3).Leave-One-Out Cross Validation(记为LOO-CV) </p>
<p>如果设原始数据有N个样本,那么LOO-CV就是N-CV,即每个样本单独作为验证集,其余的N-1个样本作为训练集,所以LOO-CV会得到N个模型,用这N个模型最终的验证集的分类准确率的平均数作为此下LOO-CV分类器的性能指标.相比于前面的K-CV,LOO-CV有两个明显的优点:<br>a.每一回合中几乎所有的样本皆用于训练模型,因此最接近原始样本的分布,这样评估所得的结果比较可靠。<br>b.实验过程中没有随机因素会影响实验数据,确保实验过程是可以被复制的。</p>
<p>  <strong>三、使用Cross-Validation时常犯的错误</strong> </p>
<p>由于实验室许多研究都有用到 evolutionary algorithms（EA）与 classifiers，所使用的 fitness function 中通常都有用到 classifier 的辨识率，然而把cross-validation 用错的案例还不少。前面说过，只有 training data 才可以用于 model 的建构，所以只有 training data 的辨识率才可以用在 fitness function 中。而 EA 是训练过程用来调整 model 最佳参数的方法，所以只有在 EA结束演化后，model 参数已经固定了，这时候才可以使用 test data。那 EA 跟 cross-validation 要如何搭配呢？Cross-validation 的本质是用来估测(estimate)某个 classification method 对一组 dataset 的 generalization error，不是用来设计 classifier 的方法，所以 cross-validation 不能用在 EA的 fitness function 中，因为与 fitness function 有关的样本都属于 training set，那试问哪些样本才是 test set 呢？如果某个 fitness function 中用了cross-validation 的 training 或 test 辨识率，那么这样的实验方法已经不能称为 cross-validation 了。 </p>
<p>​    EA 与 k-CV 正确的搭配方法，是将 dataset 分成 k 等份的 subsets 后，每次取 1份 subset 作为 test set，其余 k-1 份作为 training set，并且将该组 training set 套用到 EA 的 fitness function 计算中(至于该 training set 如何进一步利用则没有限制)。因此，正确的 k-CV 会进行共 k 次的 EA 演化，建立 k 个classifiers。而 k-CV 的 test 辨识率，则是 k 组 test sets 对应到 EA 训练所得的 k 个 classifiers 辨识率之平均值。</p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning of logistic regression</title>
    <url>/jontyhuang.github.io/2019/11/09/machine-learning-of-logistic-regression/</url>
    <content><![CDATA[<h1 id="线性回归原理（linear-Regression"><a href="#线性回归原理（linear-Regression" class="headerlink" title="线性回归原理（linear Regression)"></a>线性回归原理（linear Regression)</h1><p>线性回归是一种通过属性的线性组合来进行预测的线性模型，其目的是找到一条直线或者一个平面或者更高维的超平面，使得预测值与真实值之间的误差最小化。</p>
<p>线性回归：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109121452.png" alt=""></p>
<p>其中b是偏正值。</p>
<ul>
<li>当只有一个x时，h(x)是一个直线</li>
<li>当有两个自变量时，h(x)是一个平面。</li>
<li>当有更多的变量，h(x)高维的超平面。</li>
</ul>
<p>线性回归是通过数据在N维空间找到h(x)来描述这些数据的规律性，这是一个叫拟合的过程，h(x)叫做拟合线。</p>
<a id="more"></a>

<p>h(x) 的预测值会和真实值有所偏差，真实统计和h(X) 预测数据的差叫做残差。残差有正负，为了降低计算的复杂性，我们使用残差的平方进行计算。为了获得最好的h(x),我们保证个点和实际数据的残差平方和最小。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109121956.png" alt=""></p>
<p>为了获取可以使j最小的w和b。我们的解决方法是：</p>
<ul>
<li>偏导法</li>
<li>正规方程法</li>
<li>梯度下降法</li>
</ul>
<p>优点：</p>
<ul>
<li>权重w是每个x的权重，通过w的大小可以看出每个x的权重大小，可以看出因子的重要性。</li>
<li>有很好的 解释性</li>
</ul>
<p>缺点：</p>
<p>非线性的拟合不好。</p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>从前面的h(X)的预测值是连续的，所以这是一个回归模型。如果我们希望我们输出值的离散的 ，我们需要将h(x)进行一次函数变换，通过Sigmoid函数将连续的值映射为离散的（说的更为准确一些就是0和1），g(Y) =1的某些值属于类别1，另一些值属于类别0，这样的模型称为二分类模型。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109124928.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109123956.png" alt=""></p>
<p>有了这个sigmoid函数之后，如果有一个测试点x,那么就可以用sigmoid算出的函数值作为该点数类别1 的概率大小。</p>
<p> 我们把Sigmoid fuction计算得到的值大于等于0.5的归为类别1，小于0.5的归为类别0。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109124326.png" alt=""></p>
<p>同时逻辑回归和自适应线性网络非常相似，两者的区别在于逻辑回归的激活函数是Sigmiod function 而自适应线性网络的激活函数是y =x，两者的网络结构如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109124618.png" alt="自适应线性网络"></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109124640.png" alt=""></p>
<h1 id="逻辑回归的代价函数"><a href="#逻辑回归的代价函数" class="headerlink" title="逻辑回归的代价函数"></a>逻辑回归的代价函数</h1><p>要想解出w和b，我们就需要定义出一个目标函数，或者成为代价函数。</p>
<h2 id="按照回归的思想"><a href="#按照回归的思想" class="headerlink" title="按照回归的思想"></a>按照回归的思想</h2><p>模仿线性回归的代价函数，利用误差平方和来当代价函数。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109160718.png" alt=""></p>
<p>上式的完整如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109160751.png" alt=""></p>
<h2 id="从概率的角度建立loss函数"><a href="#从概率的角度建立loss函数" class="headerlink" title="从概率的角度建立loss函数"></a>从概率的角度建立loss函数</h2><p>下面的损失函数存在一定的错误，$J(w)$后面的式子还应当除以一个m。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109160950.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109161247.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109161542.png" alt=""></p>
<h1 id="利用梯度下降求参数"><a href="#利用梯度下降求参数" class="headerlink" title="利用梯度下降求参数"></a>利用梯度下降求参数</h1><p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109161856.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109161827.png" alt=""></p>
<h1 id="加入正则项"><a href="#加入正则项" class="headerlink" title="加入正则项"></a>加入正则项</h1><p> 对于<strong>线性回归模型</strong>，使用<strong>L1正则化</strong>的模型建叫做<strong>Lasso回归</strong>，使用L2正则化的模型叫做<strong>Ridge回归（岭回归）</strong>。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109163823.png" alt=""></p>
<p>加入正则化，是为了解决过拟合的问题。</p>
<p>下图是Python中Lasso回归的损失函数，式中加号后面一项<img src="https://img-blog.csdnimg.cn/20181213113937853.png" alt="img">即为<strong>L1正则化项</strong>。</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109164058.png" alt=""></p>
<p> 下图是Python中<strong>Ridge回归</strong>的损失函数，式中加号后面一项<img src="https://img-blog.csdnimg.cn/20181213113948341.png" alt="img">即为<strong>L2正则化项</strong>。 </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109164125.png" alt=""></p>
<p> 一般回归分析中回归w表示特征的系数，从上式可以看到<strong>正则化项</strong>是对系数<strong>做了处理（限制）</strong>。<strong>L1正则化和L2正则化的说明如下：</strong> </p>
<ul>
<li><p>L1正则化是指权值向量w中各个元素的绝对值之和，通常表示为<img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109164402.png" alt=""></p>
</li>
<li><p>L2正则化是值权值向量w中各个元素的平方和然后再求平方根， （可以看到Ridge回归的L2正则化项有平方符号），通常表示为<img src="https://img-blog.csdnimg.cn/20181213114018242.png" alt="img"> </p>
</li>
</ul>
<p>一般都会在正则化项之前添加一个系数，Python中用α表示，一些文章也用λ表示。这个系数需要用户指定。</p>
<p>那添加L1和L2正则化有什么用？下面是L1正则化和L2正则化的作用，这些表述可以在很多文章中找到。</p>
<ul>
<li><p>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择</p>
</li>
<li><p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合</p>
<h2 id="L1和L2正则化的直观理解"><a href="#L1和L2正则化的直观理解" class="headerlink" title="L1和L2正则化的直观理解"></a>L1和L2正则化的直观理解</h2><h3 id="L1正则化和特征选择"><a href="#L1正则化和特征选择" class="headerlink" title="L1正则化和特征选择"></a>L1正则化和特征选择</h3></li>
</ul>
<p>稀疏矩阵指的是很多元素为0，只有少数元素是非零值的矩阵，即得到的线性回归模型的大部分系数都是0. 通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，或者贡献微小（因为它们前面的系数是0或者是很小的值，即使去掉对模型也没有什么影响），此时我们就可以只关注系数是非零值的特征。这就是稀疏模型与特征选择的关系。</p>
<p> 假设有如下带<strong>L1正则化</strong>的损失函数：  </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109165254.png" alt=""></p>
<p>  其中J0是原始的损失函数，加号后面的一项是L1正则化项，α是正则化系数。注意到L1正则化是权值的绝对值之和，J是带有绝对值符号的函数，因此J是不完全可微的。机器学习的任务就是要通过一些方法（比如梯度下降）求出损失函数的最小值。当我们在原始损失函数J0后添加L1正则化项时，相当于对J0做了一个约束。令L=，则J=J0+LJ，此时我们的任务变成在L约束下求出J0取最小值的解。考虑二维的情况，即只有两个权值w1和w2，此时L=|w1|+|w2|对于梯度下降法，求解J0的过程可以画出等值线，同时L1正则化的函数L也可以在w1、w2的二维平面上画出来。如下图：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109165336.png" alt=""></p>
<p> 图中等值线是J0的等值线，黑色方形是L函数的图形。在图中，当J0等值线与L图形首次相交的地方就是最优解。上图中0J与L在L的一个顶点处相交，这个顶点就是最优解。注意到这个顶点的值是(w1,w2)=(0,w)。可以直观想象，因为L函数有很多『突出的角』（二维情况下四个，多维情况下更多），J0与这些角接触的机率会远大于与L其它部位接触的机率，而在这些角上，会有很多权值等于0，这就是为什么L1正则化可以产生稀疏模型，进而可以用于特征选择。</p>
<p>​        而正则化前面的系数α，可以控制L图形的大小。α越小，L的图形越大（上图中的黑色方框）；α越大，L的图形就越小，可以小到黑色方框只超出原点范围一点点，这是最优点的值(w1,w2)=(0,w)中的w可以取到很小的值。</p>
<p>综上所诉，由于w的解可能其某些方向向量为空，所以这些方向的w值为0，所以会产生一个稀疏矩阵。</p>
<h3 id="L2正则化和过拟合"><a href="#L2正则化和过拟合" class="headerlink" title="L2正则化和过拟合"></a>L2正则化和过拟合</h3><p>假设如下带有L2正则化的损失函数：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109170713.png" alt=""></p>
<p>同时可以画出其在二维平面上的图形：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109170801.png" alt=""></p>
<p>二维平面下L2正则化的函数图形是个圆，与方形相比，被磨去了棱角。因此J0与L相交时使得w1或w2等于零的机率小了许多，这就是为什么L2正则化不具有稀疏性的原因。</p>
<p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。</p>
<p>那为什么L2正则化可以获得值很小的参数？</p>
<p>以线性回归中的梯度下降法为例。假设要求的参数为θ，hθ(x)是我们的假设函数，那么线性回归的代价函数如下： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109171025.png" alt=""></p>
<p>那么在梯度下降法中，最终使用迭代计算参数 θ的迭代式为： </p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109171221.png" alt=""></p>
<p> 在添加了L2正则化迭代公式之后，迭代公式如下：</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191109171526.png" alt=""></p>
<p>从上师可以看出，λ越大，θj衰减得越快。另一个理解，λ越大，L2圆的半径越小，最后求得代价函数最值时各参数也会变得很小。 </p>
<h1 id="逻辑回归解决多分类问题"><a href="#逻辑回归解决多分类问题" class="headerlink" title="逻辑回归解决多分类问题"></a>逻辑回归解决多分类问题</h1><p>先将问题分为二分类问题，再对已分完的类继续二分类。</p>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>numpy&#39;s argpartition</title>
    <url>/jontyhuang.github.io/2019/11/09/numpy&#39;s-argpartition/</url>
    <content><![CDATA[<h1 id="argpartition"><a href="#argpartition" class="headerlink" title="argpartition"></a>argpartition</h1><p> numpy.argpartition(a, kth, axis=-1, kind=’introselect’, order=None) </p>
<p> 使用<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.argpartition.html" target="_blank" rel="noopener"><code>np.argpartition</code></a>.它不会对整个阵列进行排序.它只保证第k个元素处于排序位置,所有较小的元素将在它之前移动.因此,前k个元素将是k个最小元素. 返回是numpy数组的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.array([<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0.1</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">1.5</span>])</span><br><span class="line">k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">idx = np.argpartition(A, k)</span><br><span class="line">print(idx)</span><br><span class="line"><span class="comment"># [4 0 7 3 1 2 6 5]</span></span><br></pre></td></tr></table></figure>

<p>这将返回k个最小值.请注意,这些可能不是按排序顺序.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(A[idx[:k]])</span><br><span class="line"># [ 0.1  1.   1.5]</span><br></pre></td></tr></table></figure>

<p>要获得k最大值使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idx = np.argpartition(A, -k)</span><br><span class="line"># [4 0 7 3 1 2 6 5]</span><br><span class="line"></span><br><span class="line">A[idx[-3:]]</span><br><span class="line"># [  9.  17.  17.]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>numpy</category>
      </categories>
  </entry>
  <entry>
    <title>machine learning of LabelEncoder and OneHotEncode</title>
    <url>/jontyhuang.github.io/2019/11/07/machine-learning-of-LabelEncoder-and-OneHotEncode/</url>
    <content><![CDATA[<h1 id="LabelEncoder标准化标签"><a href="#LabelEncoder标准化标签" class="headerlink" title="LabelEncoder标准化标签"></a>LabelEncoder标准化标签</h1><p>labelEncoder是对<strong>不连续的数字或者文本</strong>进行编号。</p>
<ul>
<li>sklearn.preprocessing.LabelEncoder()：标准化标签，将标签值统一转换成range(标签值个数-1)范围内 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder()</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">le.fit([<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">100</span>])  <span class="comment">#对数组进行编码</span></span><br><span class="line">le.fit([<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">100</span>])  <span class="comment">#对数组进行编码，并返回标准化之后的数组</span></span><br><span class="line">le.transform([<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">67</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 输出： array([0,0,3,2,1])</span></span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h1 id="独热码oneHotEncode"><a href="#独热码oneHotEncode" class="headerlink" title="独热码oneHotEncode"></a>独热码oneHotEncode</h1><p> 独热码，在英文文献中称做 one-hot code, 直观来说就是有多少个状态就有多少比特，而且只有一个比特为1，其他全为0的一种码制。 </p>
<p>假如有三种颜色特征：红、黄、蓝。 在利用机器学习的算法时一般需要进行向量化或者数字化。那么你可能想令 红=1，黄=2，蓝=3. 那么这样其实实现了标签编码，即给不同类别以标签。然而这意味着机器可能会学习到“红&lt;黄&lt;蓝”，但这并不是我们的让机器学习的本意，<strong>只是想让机器区分它们，并无大小比较之意</strong>。所以这时标签编码是不够的，需要进一步转换。因为有三种颜色状态，所以就有3个比特。即红色：1 0 0 ，黄色: 0 1 0，蓝色：0 0 1 。<strong>如此一来每两个向量之间的距离都是根号2，在向量空间距离都相等</strong>，所以这样<strong>不会出现偏序性</strong>，基本不会影响基于向量空间度量算法的效果。</p>
<p>编码过程</p>
<p>假如只有一个特征是离散值：{sex：{male， female，other}}</p>
<p>该特征总共有3个不同的分类值，此时需要3个bit位表示该特征是什么值，对应bit位为1的位置对应原来的特征的值（一般情况下可以将原始的特征的取值进行排序，以便于后期使用），此时得到独热码为{100}男性 ，{010}女性，{001}其他</p>
<p>假如多个特征需要独热码编码，那么久按照上面的方法依次将每个特征的独热码拼接起来：<br> 　　　{sex：{male， female，other}}<br> 　　　{grade：{一年级， 二年级，三年级， 四年级}}<br> 此时对于输入为{sex：male； grade： 四年级}进行独热编码，可以首先将sex按照上面的进行编码得到{100}，然后按照grade进行编码为{0001}，那么两者连接起来得到最后的独热码{1000001}；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line">one_hot = preprocessing.OneHotEncoder()</span><br><span class="line">one_hot.fit([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]])  <span class="comment">#fit用来学习编码</span></span><br><span class="line">one_hot.transform([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]]).toarray()  <span class="comment">#进行编码</span></span><br><span class="line"><span class="comment"># array([[ 1.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  1.]])</span></span><br></pre></td></tr></table></figure>

<p>数据矩阵是4*3，即4个数据，3个特征维度。</p>
<p>观察左边的数据矩阵，第一列为第一个特征维度，有两种取值0\1. 所以对应编码方式为10 、01</p>
<p> 同理，第二列为第二个特征维度，有三种取值0\1\2，所以对应编码方式为100、010、001</p>
<p>同理，第三列为第三个特征维度，有四中取值0\1\2\3，所以对应编码方式为1000、0100、0010、0001</p>
<p>再来看要进行编码的参数[0 , 1, 3]， 0作为第一个特征编码为10, 1作为第二个特征编码为010， 3作为第三个特征编码为0001. 故此编码结果为 1 0 0 1 0 0 0 0 1</p>
<h1 id="独热编码意义何在"><a href="#独热编码意义何在" class="headerlink" title="独热编码意义何在"></a>独热编码意义何在</h1><p>独热编码（哑变量 dummy variable）是因为<strong>大部分算法是基于向量空间</strong>中的度量来进行计算的，为了使<strong>非偏序关系的变量取值不具有偏序性</strong>，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。</p>
<h2 id="特征向量映射到欧式空间"><a href="#特征向量映射到欧式空间" class="headerlink" title="特征向量映射到欧式空间"></a>特征向量映射到欧式空间</h2><p>将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。</p>
<h2 id="独热编码优缺点"><a href="#独热编码优缺点" class="headerlink" title="独热编码优缺点"></a>独热编码优缺点</h2><ul>
<li>优点：独热编码解决了分类器不好处理属性数据的问题，在一定程度上也起到了扩充特征的作用。它的值只有0和1，不同的类型存储在垂直的空间。</li>
<li>缺点：当类别的数量很多时，特征空间会变得非常大。在这种情况下，一般可以用PCA来减少维度。而且OneHotEncode+PCA这种组合在实际中也非常有用。</li>
</ul>
<h2 id="什么情况下-不-用独热编码"><a href="#什么情况下-不-用独热编码" class="headerlink" title="什么情况下(不)用独热编码"></a>什么情况下(不)用独热编码</h2><ul>
<li>用：独热编码用来解决类别型数据的离散值问题</li>
<li>不用：将离散型特征进行one-hot编码的作用，是为了让距离计算更合理，但如果特征是离散的，并且不用one-hot编码就可以很合理的计算出距离，那么就没必要进行one-hot编码。 有些基于树的算法在处理变量时，并不是基于向量空间度量，数值只是个类别符号，即没有偏序关系，所以不用进行独热编码。  Tree Model不太需要one-hot编码： 对于决策树来说，one-hot的本质是增加树的深度。</li>
</ul>
<h2 id="什么情况下-不-需要归一化"><a href="#什么情况下-不-需要归一化" class="headerlink" title="什么情况下(不)需要归一化"></a>什么情况下(不)需要归一化</h2><ul>
<li>需要： 基于参数的模型或基于距离的模型，都是要进行特征的归一化。</li>
<li>不需要：基于树的方法是不需要进行特征的归一化，例如随机森林，bagging 和 boosting等。</li>
</ul>
<h1 id="如果一个特征的特征值很多，如何使用onehot"><a href="#如果一个特征的特征值很多，如何使用onehot" class="headerlink" title="如果一个特征的特征值很多，如何使用onehot"></a>如果一个特征的特征值很多，如何使用onehot</h1><ul>
<li>将特征值进行合并，譬如分类变量是中国的村镇，可以合并到县或者市甚至省这一级别。</li>
</ul>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup Flip a coin</title>
    <url>/jontyhuang.github.io/2019/11/06/blue-cup-Flip-a-coin/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>问题描述<br>小明正在玩一个“翻硬币”的游戏。桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。比如，可能情形是：**oo***oooo<br>如果同时翻转左边的两个硬币，则变为：oooo***oooo<br>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？<br>我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：<br>输入格式<br>两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000<br>输出格式<br>一个整数，表示最小操作步数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入</span><br><span class="line"> **********</span><br><span class="line"> o****o****</span><br><span class="line">样例输出</span><br><span class="line">5</span><br><span class="line">样例输入</span><br><span class="line"> *o**o***o***</span><br><span class="line"> *o***o**o***</span><br><span class="line">样例输出</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String a = in.next();</span><br><span class="line">		<span class="keyword">char</span> arr[] = a.toCharArray();</span><br><span class="line">		String b =in.next();</span><br><span class="line">		<span class="keyword">char</span> brr[] = b.toCharArray();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i  =<span class="number">0</span>;i&lt;a.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i] == brr[i])&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">					arr[i] = <span class="string">'o'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					arr[i] = <span class="string">'*'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(arr[i+<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">					arr[i+<span class="number">1</span>] = <span class="string">'o'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					arr[i+<span class="number">1</span>] = <span class="string">'*'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				count ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(count);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup The amount that can not be bought</title>
    <url>/jontyhuang.github.io/2019/11/05/blue-cup-The-amount-that-can-t-be-bought/</url>
    <content><![CDATA[<p>小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。 小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。 你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。 本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。<br>输入格式<br>两个正整数，表示每种包装中糖的颗数(都不多于1000)<br>输出格式<br>一个正整数，表示最大不能买到的糖数<br>样例输入<br>4 7<br>样例输出<br>17<br>样例输入<br>3 5<br>样例输出<br>7</p>
<a id="more"></a>

<h1 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h1><p>方法一：自然数a,b互质,则不能表示成ax+by（x,y为非负整数）的最大整数是ab-a-b.<br>证明：<br>a或者b是1的情况下容易证明.<br>以下情况都是a&gt;1且b&gt;1的情况.<br>首先证明ab-a-b不能表示成ax+by<br>假设ab-a-b=ax+by,那么ab=am+bn (m,n都大于等于1)<br>左边是a的倍数,右边am是a的倍数,那么要求bn也要是a的倍数<br>b不是a的倍数,只能要求n是a的倍数,这样的话,bn=bn’a&gt;=ba<br>那么am=ab-bn&lt;=0就与am&gt;1矛盾.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">		in.close();</span><br><span class="line">		System.out.println(a*b-a-b);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法二（动态规划）"><a href="#方法二（动态规划）" class="headerlink" title="方法二（动态规划）"></a>方法二（动态规划）</h1><p>我们使用count来记录可以连续被a和b表示的数字个数。</p>
<p>当count大于等于a和b之间较小的数时，则之后的数字都可以被a和b表示出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.PortableInterceptor.SYSTEM_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>]; </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> b =in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> count = Math.min(a, b);</span><br><span class="line">		ans[a] =<span class="number">1</span>;</span><br><span class="line">		ans[b] =<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> n =<span class="number">0</span>;   <span class="comment">// 记录可以连续表示对个数</span></span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(n &lt;Math.min(a, b))&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[count] == <span class="number">1</span>)&#123;   <span class="comment">//ans[count] 为1 ，表示其可以被a和b表示出来</span></span><br><span class="line">				ans[count+b] =<span class="number">1</span>;</span><br><span class="line">				ans[count + a] = <span class="number">1</span>;</span><br><span class="line">				n ++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				n =<span class="number">0</span>;</span><br><span class="line">				result = count;</span><br><span class="line">			&#125;</span><br><span class="line">			count ++;</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.print(result);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>java basic grammar</title>
    <url>/jontyhuang.github.io/2019/11/04/java-basic-grammar/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>basic learning of Java</category>
      </categories>
  </entry>
  <entry>
    <title>blue cup ant</title>
    <url>/jontyhuang.github.io/2019/11/04/blue-cup-ant/</url>
    <content><![CDATA[<p>问题描述<br>长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</p>
<p>输入格式<br>第一行输入一个整数n (1 &lt; n &lt; 50), 表示蚂蚁的总数。接着的一行是n个用空格分开的整数 Xi (-100 &lt; Xi &lt; 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。<br>输出格式<br>要求输出1个整数，表示最后感冒蚂蚁的数目。<br>样例输入<br>3 5 -2 8<br>样例输出<br>1<br>样例输入<br>5 -10 8 -20 12 25<br>样例输出<br>3</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="comment">/*两只蚂蚁相遇掉头，和各走各的其实没区别。</span></span><br><span class="line"><span class="comment">由于速度一样，感冒蚂蚁永远传染不了开始时与它同向在前面，或反向在后面的蚂蚁。</span></span><br><span class="line"><span class="comment">而是否有在前面反向的蚂蚁决定了是否传染在后面同向的蚂蚁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> N = in.nextInt(); <span class="comment">//获得蚂蚁的数量</span></span><br><span class="line">		<span class="keyword">int</span> ant ;</span><br><span class="line">		<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">int</span> lr= <span class="number">0</span>,rl =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> cold = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> temp =Math.abs(cold);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">			ant = in.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(ant &lt; temp &amp;&amp; ant&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				lr++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(ant) &gt; temp  &amp;&amp; ant&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				rl ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((temp &lt;<span class="number">0</span> &amp;&amp; lr &gt;<span class="number">0</span>) || (temp &gt;<span class="number">0</span> &amp;&amp; rl&gt;<span class="number">0</span>))&#123;   <span class="comment">//如果temp向右，那么右边要存在往左的蚂蚁，这样才会感染temp左边往右走的蚂蚁。同理temp向左。</span></span><br><span class="line">			System.out.print(lr+rl+<span class="number">1</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>the blue cup sweet</title>
    <url>/jontyhuang.github.io/2019/11/03/blue-cup-sweet/</url>
    <content><![CDATA[<p>问题描述<br>有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：每个小朋友都把自己的糖果分一半给左手边的孩子。一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。反复进行这个游戏，直到所有小朋友的糖果数都相同为止。你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。<br>输入格式<br>程序首先读入一个整数N(2&lt;N&lt;100)，表示小朋友的人数。接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）<br>输出格式<br>要求程序输出一个整数，表示老师需要补发的糖果数。<br>样例输入<br>3 2 2 4<br>样例输出<br>4</p>
<a id="more"></a>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123; <span class="comment">//糖果是否一样</span></span><br><span class="line">		<span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(nums[i] == nums[i +<span class="number">1</span>])</span><br><span class="line">		&#123;i ++;</span><br><span class="line">			<span class="keyword">if</span> (i == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> N = in.nextInt(); <span class="comment">//获得小朋友的人数</span></span><br><span class="line">		<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[N];    <span class="comment">//存储每个小朋友手上的糖果数</span></span><br><span class="line">		<span class="keyword">int</span>[] input_num = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">//存储即将分配出去的糖果数</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			num[i] = in.nextInt();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>( !make(num))&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">				input_num[i] = num[i] /<span class="number">2</span>;  <span class="comment">//准备即将分出的糖果数</span></span><br><span class="line">				num[i] /= <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">				num[(i+<span class="number">1</span>) % N] += input_num[i];  <span class="comment">//左手边分一半</span></span><br><span class="line">				<span class="keyword">if</span>(num[(i+<span class="number">1</span>) % N] % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">					num[(i+<span class="number">1</span>) % N] ++;</span><br><span class="line">					count ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(count);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>the blue cup Points of chocolate</title>
    <url>/jontyhuang.github.io/2019/11/02/blue-cup-Points-of-chocolate/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。  小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：  </p>
<ul>
<li>形状是正方形 ，  </li>
<li>边长是整数大小相同</li>
</ul>
<p>例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。<br>当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？<br>输入格式：<br>第一行输入包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br>以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)<br>输入保证每位小朋友至少能获得一块1x1的巧克力。<br>输出格式：<br>输出切出的正方形巧克力最大可能的边长。<br>样例输入：<br>2 10<br>6 5<br>5 6<br>Sample Output<br>2</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] H,<span class="keyword">int</span>[] W,<span class="keyword">int</span> k,<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> current = <span class="number">0</span>;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;H.length;i++)&#123;</span><br><span class="line">			current += (H[i]/M) *(W[i]/M);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(current &gt;= k)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> N = in.nextInt(); <span class="comment">//获取巧克力的块数</span></span><br><span class="line">		<span class="keyword">int</span> k = in.nextInt(); <span class="comment">// 获取人数</span></span><br><span class="line">		<span class="keyword">int</span>[] H = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">int</span>[] W = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			H[i] = in.nextInt();</span><br><span class="line">			W[i] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = <span class="number">100000</span>;</span><br><span class="line">		<span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(low &lt;=high)&#123;    </span><br><span class="line">			M = (low +high) /<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(solve(H, W, k, M) &amp;&amp; !solve(H, W, k, M+<span class="number">1</span>))&#123;</span><br><span class="line">				System.out.println(M);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(solve(H, W, k, M))&#123;</span><br><span class="line">				low = M +<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				high = M- <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>the blue cup 种植园</title>
    <url>/jontyhuang.github.io/2019/11/01/blue-cup-plantation(prev54)/</url>
    <content><![CDATA[<p>题目：<br>问题描述<br>w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了了一株合根植物。 这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。 如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？ ### 输入格式<br>第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m, n&lt;1000）。 接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000) 接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。 格子的编号一行一行，从上到下，从左到右编号。 比如：5 * 4 的小格子，编号： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20<br>样例输入<br>5 4 16 2 3 1 5 5 9 4 8 7 8 9 10 10 11 11 12 10 14 12 16 14 18 17 18 15 19 19 20 9 13 13 17<br>样例输出<br>5 样例说明 其合根情况参考下图<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191114000400.png" alt=""></p>
<a id="more"></a>

<h1 id="程序一：（并查集）"><a href="#程序一：（并查集）" class="headerlink" title="程序一：（并查集）"></a>程序一：（并查集）</h1><p>我的理解:要想寻找一株合根植物，那么其实就是找连通图，判断两个点是否在连通图中，因此我们可以建立无向图，但是用图的数据结构最大是问题是，算法时效过低，因此我们将这个题目转化为对并查集的操作问题。<br>构建一个连通图，mat[i]的值是下一个结点的索引位置。当mat[i] = 时代表此时是根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] mat = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;   <span class="comment">//找到当前结点所在的连通图的根节点。返回其索引值。</span></span><br><span class="line">		<span class="keyword">while</span>(x != test.mat[x])&#123;</span><br><span class="line">			x = test.mat[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">liangen</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;  <span class="comment">//如果x在连通图中，y不在，那么根节点被赋值为y，y变为根节点，如果y在连通图中，x不在，那么y还是根节点，但是x加入了该连通图中。</span></span><br><span class="line">		mat[find(x)] = find(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> row = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> clo = in.nextInt();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = in.nextInt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=row*clo;i++)&#123;</span><br><span class="line">			mat[i] = i;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x1 = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span> x2 = in.nextInt(); <span class="comment">//获取连根坐标</span></span><br><span class="line">			test.liangen(x1,x2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=row*clo;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(find(i) == i)</span><br><span class="line">				count += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(count);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序二"><a href="#程序二" class="headerlink" title="程序二"></a>程序二</h1><p>解法是:如果两个结点在一个连通图中，那么两个结点的值就是一样，且其值代表连通图的序号，因此最后只需将连通图的序号加上单根植物的棵树即结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] mat = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(x != test.mat[x])&#123;</span><br><span class="line">			x = test.mat[x];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">liangen</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;   <span class="comment">//将结点加入到连通图中，如果两个点都不在连通图中，那么新建一个连通图。</span></span><br><span class="line">		<span class="keyword">if</span> (mat[x] == <span class="number">0</span> &amp;&amp; mat[y] ==<span class="number">0</span>)&#123;</span><br><span class="line">			test.count ++;</span><br><span class="line">			mat[x] = test.count;</span><br><span class="line">			mat[y] = test.count;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mat[x] != <span class="number">0</span>)&#123;</span><br><span class="line">				mat[y] = mat[x];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mat[x] = mat[y];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> row = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> clo = in.nextInt();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = in.nextInt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=row*clo;i++)&#123;</span><br><span class="line">			mat[i] = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x1 = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span> x2 = in.nextInt(); <span class="comment">//获取连根坐标</span></span><br><span class="line">			test.liangen(x1, x2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mat[i] == <span class="number">0</span>) count ++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(count);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>the blue cup of Java</category>
      </categories>
  </entry>
  <entry>
    <title>java-String-class</title>
    <url>/jontyhuang.github.io/2019/10/31/java-String-class/</url>
    <content><![CDATA[<h1 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h1><p>创建字符串最简单的方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting = <span class="string">"菜鸟教程"</span>;</span><br><span class="line">在代码中遇到字符串常量时，这里的值是 <span class="string">"菜鸟教程"</span><span class="string">"，编译器会使用该值创建一个 String 对象。</span></span><br></pre></td></tr></table></figure>
<p>和其它对象一样，可以使用关键字和构造方法来创建 String 对象。<br>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p>
<p>#创建格式化字符串<br>我们知道输出格式化数字可以使用 printf() 和 format() 方法。<br>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。<br>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。<br>如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"浮点型变量的值为 "</span> +</span><br><span class="line">                  <span class="string">"%f, 整型变量的值为 "</span> +</span><br><span class="line">                  <span class="string">" %d, 字符串变量的值为 "</span> +</span><br><span class="line">                  <span class="string">"is %s"</span>, floatVar, intVar, stringVar);</span><br></pre></td></tr></table></figure>
<p>你也可以这样写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">String fs;</span><br><span class="line">fs = String.format(<span class="string">"浮点型变量的值为 "</span> +</span><br><span class="line">                   <span class="string">"%f, 整型变量的值为 "</span> +</span><br><span class="line">                   <span class="string">" %d, 字符串变量的值为 "</span> +</span><br><span class="line">                   <span class="string">" %s"</span>, floatVar, intVar, stringVar);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>basic learning of Java</category>
      </categories>
  </entry>
  <entry>
    <title>Python-magic-function</title>
    <url>/jontyhuang.github.io/2019/10/30/Python-magic-function/</url>
    <content><![CDATA[<p>在Python中，所有以“<strong>”双下划线包起来的方法，都统称为“Magic Method”，中文称『魔术方法』,例如类的初始化方法 __init</strong> ,Python中所有的魔术方法均在官方文档中有相应描述，但是对于官方的描述比较混乱而且组织比较松散。很难找到有一个例子。</p>
<h1 id="构造和初始化"><a href="#构造和初始化" class="headerlink" title="构造和初始化"></a>构造和初始化</h1><p>　1、<strong>init</strong>：初始化函数，在创建实例对象为其赋值时使用，在<strong>new</strong>之后，<strong>init</strong>必须至少有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>是在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileObject</span>:</span> </span><br><span class="line">    <span class="string">'''给文件对象进行包装从而确认在删除时文件流关闭'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filepath=<span class="string">'~'</span>, filename=<span class="string">'sample.txt'</span>)</span>:</span> </span><br><span class="line">        <span class="comment">#读写模式打开一个文件 </span></span><br><span class="line">        self.file = open(join(filepath, filename), <span class="string">'r+'</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.file.close() </span><br><span class="line">        <span class="keyword">del</span> self.file</span><br></pre></td></tr></table></figure>

<p>2、<strong>new</strong>:很多人认为<strong>init</strong>是类的构造函数，其实不太确切，<strong>init</strong>更多的是负责初始化操作，相当于一个项目中的配置文件，<strong>new</strong>才是真正的构造函数，创建并返回一个实例对象，如果<strong>new</strong>只调用了一次，就会得到一个对象。<strong>继承自object的新式类才有<strong>new</strong>这一魔法方法</strong>，<strong>new</strong>至少必须要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供,<strong><strong>new</strong>必须要有返回值</strong>，返回实例化出来的实例（很重要），这点在自己实现<strong>new</strong>时要特别注意，可以return父类<strong>new</strong>出来的实例，或者直接是object的<strong>new</strong>出来的实例，若<strong>new</strong>没有正确返回当前类cls的实例，那<strong>init</strong>是不会被调用的，即使是父类的实例也不行。<strong>new</strong>是唯一在实例创建之前执行的方法，一般用在定义元类时使用。<br>创建对象的步骤：<br>a、首先调用<strong>new</strong>得到一个对象<br>b、调用<strong>init</strong>为对象添加属性<br>c、将对象赋值给变量<br>下面来看一个结合<strong>init</strong>和<strong>new</strong>两个魔法方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是__init__方法"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"这是__new__方法"</span>)</span><br><span class="line">        print(id(cls))</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">b =B()</span><br><span class="line"><span class="comment">#这是__new__方法</span></span><br><span class="line"><span class="comment">#1855412042008</span></span><br><span class="line"><span class="comment">#这是__init__方法</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#&lt;__main__.B object at 0x0000020ED3A1A358&gt;</span></span><br><span class="line">print(type(b))</span><br><span class="line"><span class="comment">#&lt;class '__main__.B'&gt;</span></span><br><span class="line">print((id(A)))</span><br><span class="line"><span class="comment">#1855412031624</span></span><br><span class="line">print(id(B))</span><br><span class="line"><span class="comment">#1855412042008</span></span><br></pre></td></tr></table></figure>
<p>从运行结果看，<strong>new</strong>中参数cls和B的id相同，表明<strong>new</strong> 中默认的参数cls就是B类本身，同时在return时返回了B类的实例，在创建完实例之后还需调用<strong>init</strong>函数，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"这是__init__方法"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"这是__new__方法"</span>)</span><br><span class="line">        print(id(cls))</span><br><span class="line">        <span class="keyword">return</span> object.__new__(A)</span><br><span class="line"></span><br><span class="line">b =B()</span><br><span class="line"><span class="comment">#这是__new__方法</span></span><br><span class="line"><span class="comment">#2250047313256</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#&lt;__main__.B object at 0x0000020ED3A1A358&gt;</span></span><br><span class="line">print(type(b))</span><br><span class="line"><span class="comment">#&lt;class '__main__.A'&gt;</span></span><br><span class="line">print((id(A)))</span><br><span class="line"><span class="comment">#2250047298152</span></span><br><span class="line">print(id(B))</span><br><span class="line"><span class="comment">#2250047313256</span></span><br></pre></td></tr></table></figure>
<p>我们发现<strong>init</strong>函数没有被调用，因为<strong>new</strong>返回是A的实例对象。</p>
<h1 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h1><p><strong>del</strong>：对象在程序运行结束之后进行垃圾回收的时候调用这个方法，来释放资源。此时，此方法是被自动调用的。除非有特殊要求，一般不要重写。在关闭数据库连接对象的时候，可以在这里，释放资源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    num_count = <span class="number">0</span>  <span class="comment"># 所有实例共享此变量，即不单独为每个实例分配</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,string)</span>:</span></span><br><span class="line">        self.string = string</span><br><span class="line">        NewClass.num_count += <span class="number">1</span></span><br><span class="line">        print(self.string +<span class="string">"  "</span> , NewClass.num_count)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        NewClass.num_count -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"del"</span> + self.string , NewClass.num_count)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"aa"</span>)</span><br><span class="line"></span><br><span class="line">aa = NewClass(<span class="string">"Hello"</span>)</span><br><span class="line">bb = NewClass(<span class="string">"World"</span>)</span><br><span class="line">cc = NewClass(<span class="string">"aaaa"</span>)</span><br><span class="line">print(<span class="string">"Over"</span>)</span><br><span class="line"></span><br><span class="line">Hello   <span class="number">1</span></span><br><span class="line">World   <span class="number">2</span></span><br><span class="line">aaaa   <span class="number">3</span></span><br><span class="line">Over</span><br><span class="line">delHello <span class="number">2</span></span><br><span class="line">delWorld <span class="number">1</span></span><br><span class="line">delaaaa <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看出在程序运行结束之后，<strong>del</strong>默认被调用了三次，分别对实例对象aa,bb,cc进行垃圾回收，因为此时创建的实例已经没有对象再指向它了。下面再看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,string)</span>:</span></span><br><span class="line">        self.string = string</span><br><span class="line">        print(self.string +<span class="string">"__init__方法被调用"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"del"</span> + self.string )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"aa"</span>)</span><br><span class="line"></span><br><span class="line">aa = NewClass(<span class="string">"Hello"</span>)</span><br><span class="line">bb = aa</span><br><span class="line"><span class="keyword">del</span> aa</span><br><span class="line"><span class="keyword">del</span> bb</span><br><span class="line">print(<span class="string">"Over"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello__init__方法被调用</span><br><span class="line">delHello</span><br><span class="line">Over</span><br></pre></td></tr></table></figure>
<p>可以看出，aa和bb指向的是同一个实例对象，在del aa的时候，<strong>del</strong>并没有被调用，因为此时这个对象还在被bb引用着，当del bb的时候，<strong>del</strong>就默认被调用了，因为此时没有变量再引用这个实例对象了，相当于其引用计数变为0了，这个对象理所当然就会被垃圾回收。</p>
<p>总而言之，<strong>del</strong>魔法方法是在对象没有变量再引用，其引用计数减为0，进行垃圾回收的时候自动调用的。</p>
<h1 id="calss"><a href="#calss" class="headerlink" title="__calss__"></a>__calss__</h1><p><strong>class</strong>：获得已知对象的类 ( 对象.<strong>class</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__class__.count += <span class="number">1</span></span><br><span class="line">        print(self.__class__.count)</span><br><span class="line">a =A()</span><br><span class="line">a.add()</span><br><span class="line">b=A()</span><br><span class="line">b.add()</span><br><span class="line">c=A()</span><br><span class="line">c.add()</span><br><span class="line"></span><br><span class="line">结果：    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>从运行结果可以看出，虽然a和b是两个不同的A类的实例对象，但采用了<strong>class</strong>之后，分别调用两个对象的addcount方法之后，获取到的对象的count属性却是在不断累加的，此时self.<strong>class</strong>.count不再是单纯的某个对象私有的属性，而是类的所有实例对象的共有属性,它相当于self.A.count。若将self.<strong>class</strong>.count += 1变为self.count += 1,此时<strong>class</strong>的效果就十分明显了。</p>
<h1 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h1><p><strong>str</strong>：在将对象转换成字符串  str(对象)  测试的时候，打印对象的信息，<strong><strong>str</strong>方法必须要return一个字符串类型的返回值</strong>，作为对实例对象的字符串描述，<strong>str</strong>实际上是被print函数默认调用的，当要print（实例对象）时，默认调用<strong>str</strong>方法，将其字符串描述返回。如果不是要用str()函数转换。当你打印一个类的时候，那么print首先调用的就是类里面的定义的<strong>str</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name  =  name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C的实例对象"</span>+self.name</span><br><span class="line">a = C(<span class="string">"ok"</span>)</span><br><span class="line">print(C)</span><br><span class="line">print(a)</span><br><span class="line">结果：</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">C</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">C</span>的实例对象<span class="title">ok</span></span></span><br></pre></td></tr></table></figure>

<h1 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a>__repr__</h1><p><strong>repr</strong>：如果说<strong>str</strong>体现的是一种可读性，是给用户看的，那么<strong>repr</strong>方法体现的则是一种准确性，是给开发人员看的，它对应的是repr()函数，重构<strong>repr</strong>方法后，在控制台直接敲出实例对象的名称，就可以按照<strong>repr</strong>中return的值显示了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name  =  name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"C的实例对象"</span>+self.name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"C的信息"</span>+self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = C(<span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">C的实例对象ok</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">C的信息ok</span><br></pre></td></tr></table></figure>



<h1 id="简单的定制"><a href="#简单的定制" class="headerlink" title="简单的定制"></a>简单的定制</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  time <span class="keyword">as</span> t</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 开始计时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.promt =<span class="string">'未开始运行'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.promt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start = t.localtime()</span><br><span class="line">        print(<span class="string">"计时开始"</span>)</span><br><span class="line">    <span class="comment"># 停止时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stop = t.localtime()</span><br><span class="line">        print(<span class="string">"计时结束"</span>)</span><br><span class="line">        self._clac()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_clac</span><span class="params">(self)</span>:</span>  <span class="comment"># 定义私有方法</span></span><br><span class="line">        self.lasted = []</span><br><span class="line">        self.promt = <span class="string">"总共运行的时间"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            self.lasted.append(self.stop[i] - self.start[i])</span><br><span class="line">            self.promt += str(self.lasted[i])</span><br><span class="line">        print(self.promt)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        promt = <span class="string">"总共运行了"</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            result.append(self.lasted[i] + other.lasted[i])</span><br><span class="line">            <span class="keyword">if</span> result[i]:</span><br><span class="line">                promt += (str(result[i]))</span><br><span class="line">        <span class="keyword">return</span>  promt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = MyTime()</span><br><span class="line">print(a.promt)</span><br><span class="line">a.start()</span><br><span class="line">t.sleep(<span class="number">3</span>)</span><br><span class="line">a.stop()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">未开始运行</span><br><span class="line">计时开始</span><br><span class="line">计时结束</span><br><span class="line">总共运行的时间<span class="number">000003</span></span><br></pre></td></tr></table></figure>



<h1 id="base"><a href="#base" class="headerlink" title="__base__"></a>__base__</h1><p><strong>bases</strong>：获取指定类的所有父类构成元素，使用方法为类名.<strong>bases</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(D.__bases__)</span><br><span class="line">结果：</span><br><span class="line">(&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;)</span><br></pre></td></tr></table></figure>

<h1 id="mro"><a href="#mro" class="headerlink" title="__mro__"></a>__mro__</h1><p>显示指定类的所有继承脉络和继承顺序，假如这个指定的类不具有某些方法和属性，但与其有血统关系的类中具有这些属性和方法，则在访问这个类本身不具有的这些方法和属性时，会按照<strong>mro</strong>显示出来的顺序一层一层向后查找，直到找到为止。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(D.__mro__)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure>

<h1 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h1><p><strong>call</strong>:具有<strong>call</strong>魔法方法的对象可以使用XXX()的形式被调用，比如说类的实例对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__被调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__call_方法被调用"</span>)</span><br><span class="line">lao = Dog()</span><br><span class="line">lao()</span><br><span class="line">结果：</span><br><span class="line">__init__被调用</span><br><span class="line">__call_方法被调用</span><br></pre></td></tr></table></figure>

<h1 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h1><h2 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h2><p><strong>getattribute</strong>：属性访问拦截器，在访问实例属性时自动调用。在python中，类的属性和方法都理解为属性，且均可以通过<strong>getattribute</strong>获取。当获取属性时，相当于对属性进行重写，直接return object.<strong>getattribute</strong>(self, <em>args, *</em>kwargs)或者根据判断return所需要的重写值，如果需要获取某个方法的返回值时，则需要在函数后面加上一个()即可。如果不加的话，返回的是函数引用地址。下面看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name1 = name</span><br><span class="line">        self.name2 = <span class="string">"cpp"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">"name1"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'redirect python'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> object.__getattribute__(self,item)</span><br><span class="line"></span><br><span class="line">S = Test(<span class="string">"python"</span>)</span><br><span class="line">print(S.name1)</span><br><span class="line">print(S.name2)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">redirect python</span><br><span class="line">cpp</span><br></pre></td></tr></table></figure>
<p>在创建实例对象s并对其初始化的时候，subject1的值设置为‘python’，subject2的值设置为‘cpp’，在访问s的subject1属性时，因为Test类对object类中的<strong>getattribute</strong>方法进行了重写，所以在调用此方法时，首先对要访问的属性做一个拦截和判断，此时<strong>getattribute</strong>方法中的参数item对应的是要访问的属性，若要访问subject1属性，则对该属性进行重写，返回了一个不同的字符串，我们可以看到，在初始化时，subject1 的值为‘python’，而在访问subject1这个属性时，返回的值是’redirect python’，而在访问subject2时，则调用其父类中的<strong>getattribute</strong>方法，返回正常的subject2属性的值。当然，在访问类的方法属性时，也可以通过重写<strong>getattribute</strong>的方法对其进行重写。</p>
<h2 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h2><p>定义当用户试图获取一个不存在的属性行为时<br>getattr 语法：<br>getattr(object, name[, default])<br>参数</p>
<ul>
<li>object – 对象。</li>
<li>name – 字符串，对象属性。</li>
<li>default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError</li>
</ul>
<h2 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a>__setattr__</h2><p>定义当一个属性被设置时的行为</p>
<h2 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a>__delattr__</h2><p>定义当一个属性被删除时的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class H:</span><br><span class="line">    def __getattribute__(self, item):</span><br><span class="line">        print(&quot;getattribute&quot;)</span><br><span class="line">        return super().__getattribute__(item)</span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        print(&quot;getattr&quot;)</span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        print(&quot;setattr&quot;)</span><br><span class="line">        super.__setattr__(key,value)</span><br><span class="line">    def __delattr__(self, item):</span><br><span class="line">        print(&quot;delattr&quot;)</span><br><span class="line">        super().__delattr__(item)</span><br><span class="line">&gt;&gt;&gt; c = H()</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">getattribute</span><br><span class="line">getattr</span><br><span class="line">&gt;&gt;&gt; c.x = 1</span><br><span class="line">setattr</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 9, in __setattr__</span><br><span class="line">TypeError:  expected 2 arguments, got 1</span><br><span class="line">&gt;&gt;&gt; del c.x</span><br><span class="line">delattr</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 12, in __delattr__</span><br><span class="line">AttributeError: x</span><br></pre></td></tr></table></figure>

<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p><img src="https://img-blog.csdnimg.cn/20191025223558501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ2NjM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
  <entry>
    <title>java-Scanner class</title>
    <url>/jontyhuang.github.io/2019/10/29/java-Scanner-class/</url>
    <content><![CDATA[<h1 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。<br>创建scanner对象的基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>我们可以通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：  </p>
<h2 id="使用next-方法"><a href="#使用next-方法" class="headerlink" title="使用next()方法"></a>使用next()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//从键盘接收数据</span></span><br><span class="line">		System.out.println(<span class="string">"next方式接收:"</span>);</span><br><span class="line">		<span class="comment">// 判断是否还有输入</span></span><br><span class="line">		<span class="keyword">if</span> (scan.hasNext())&#123;</span><br><span class="line">			String str1 = scan.next();</span><br><span class="line">			System.out.println(<span class="string">"接收数据为："</span> + str1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">next方式接收:</span><br><span class="line">aaa ccc</span><br><span class="line">接收数据为：aaa</span><br></pre></td></tr></table></figure>
<h2 id="使用nextLine-方法"><a href="#使用nextLine-方法" class="headerlink" title="使用nextLine()方法"></a>使用nextLine()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//从键盘接收数据</span></span><br><span class="line">		System.out.println(<span class="string">"next方式接收:"</span>);</span><br><span class="line">		<span class="keyword">if</span> (scan.hasNextLine())&#123;</span><br><span class="line">			String str1 = scan.nextLine();</span><br><span class="line">			System.out.println(<span class="string">"接收数据为："</span> + str1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">next方式接收:</span><br><span class="line">ddd ddd</span><br><span class="line">接收数据为：ddd ddd</span><br></pre></td></tr></table></figure>
<h2 id="next-和nextLine-）函数的区别："><a href="#next-和nextLine-）函数的区别：" class="headerlink" title="next()和nextLine(）函数的区别："></a>next()和nextLine(）函数的区别：</h2><p>next():<br>1、一定要读取到有效字符后才可以结束输入。<br>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>4、next() 不能得到带有空格的字符串。<br>5、<strong>next()以end作为结束。</strong><br>nextLine()：<br>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>2、可以获得空白。<br>3、以回车符作为结束。 （读一整行包括回车），读取结束光标放到下一行。 </p>
<h2 id="hasNext-方法的理解"><a href="#hasNext-方法的理解" class="headerlink" title="hasNext()方法的理解"></a>hasNext()方法的理解</h2><p>方法解释：当执行到hasNext（）时，它会先扫描缓冲区中是否有字符，有则返回true,继续扫描。直到扫描为空，这时并不返回false,而是将方法阻塞，等待你输入内容然后继续扫描。<br>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"请输入若干单词，以空格作为分隔"</span>);</span><br><span class="line">	        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	        <span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">	        &#123;</span><br><span class="line">	            System.out.println(<span class="string">"键盘输入的内容是："</span></span><br><span class="line">	                + sc.next());</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println(<span class="string">"执行吗"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入若干单词，以空格作为分隔</span><br><span class="line">sdsa ddd sssd</span><br><span class="line">键盘输入的内容是：sdsa</span><br><span class="line">键盘输入的内容是：ddd</span><br><span class="line">键盘输入的内容是：sssd</span><br></pre></td></tr></table></figure>
<p>当扫描器的输入为空时，将此方法阻塞，等待新的输入所以该程序未结束。<br>改进程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package Mycup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">	public static void main(String []args)&#123;</span><br><span class="line">		 System.out.println(<span class="string">"请输入若干单词，以空格作为分隔"</span>);</span><br><span class="line">	        Scanner sc = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">	        <span class="keyword">while</span>(!sc.hasNext(<span class="string">"#"</span>))   //判断接收到了<span class="comment">#号，则退出while</span></span><br><span class="line">	        &#123;</span><br><span class="line">	            System.out.println(<span class="string">"键盘输入的内容是："</span></span><br><span class="line">	                + sc.next());</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println(<span class="string">"执行吗"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-and-float"><a href="#int-and-float" class="headerlink" title="int and float"></a>int and float</h2><p>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取，<strong>同时只要输入的不是整型数据（除分隔符以外），则结束输入</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">        System.out.print(<span class="string">"输入整数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;</span><br><span class="line">            <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.nextInt();</span><br><span class="line">            <span class="comment">// 接收整数</span></span><br><span class="line">            System.out.println(<span class="string">"整数数据："</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 输入错误的信息</span></span><br><span class="line">            System.out.println(<span class="string">"输入的不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"输入小数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;</span><br><span class="line">            <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.nextFloat();</span><br><span class="line">            <span class="comment">// 接收小数</span></span><br><span class="line">            System.out.println(<span class="string">"小数数据："</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 输入错误的信息</span></span><br><span class="line">            System.out.println(<span class="string">"输入的不是小数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ javac ScannerDemo.java</span><br><span class="line">$ java ScannerDemo</span><br><span class="line">输入整数：<span class="number">12</span></span><br><span class="line">整数数据：<span class="number">12</span></span><br><span class="line">输入小数：<span class="number">1.2</span></span><br><span class="line">小数数据：<span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> Mycup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		 </span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (scan.hasNextDouble()) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = scan.nextDouble();</span><br><span class="line">            m = m + <span class="number">1</span>;</span><br><span class="line">            sum = sum + x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(m + <span class="string">"个数的和为"</span> + sum);</span><br><span class="line">        System.out.println(m + <span class="string">"个数的平均值是"</span> + (sum / m));</span><br><span class="line">        scan.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">21.4</span></span><br><span class="line">end</span><br><span class="line"><span class="number">4</span>个数的和为<span class="number">71.4</span></span><br><span class="line"><span class="number">4</span>个数的平均值是<span class="number">17.85</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>basic learning of Java</category>
      </categories>
  </entry>
  <entry>
    <title>Operating system experiments</title>
    <url>/jontyhuang.github.io/2019/10/29/Operating-system-experiments/</url>
    <content><![CDATA[<h1 id="Producers-and-Consumers"><a href="#Producers-and-Consumers" class="headerlink" title="Producers and Consumers"></a>Producers and Consumers</h1><p>有两个进程：一组生产者进程和一组消费者进程共享一个初始为空、固定大小为n的缓存（缓冲区）。生产者的工作是制造一段数据，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待，如此反复; 同时，只有缓冲区不空时，消费者才能从中取出消息，一次消费一段数据（即将其从缓存中移出），否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。<br>问题的核心是：<br>1.要保证不让生产者在缓存还是满的时候仍然要向内写数据;<br>2.不让消费者试图从空的缓存中取出数据。<br>生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
<p>解决思路：对于生产者，如果缓存是满的就去睡觉。消费者从缓存中取走数据后就叫醒生产者，让它再次将缓存填满。若消费者发现缓存是空的，就去睡觉了。下一轮中生产者将数据写入后就叫醒消费者。<br>不完善的解决方案会造成“死锁”，即两个进程都在“睡觉”等着对方来“唤醒”。</p>
<p>Python的实现方法是使用Threading.Lock这个函数，申请一个锁，当一个进程被锁住时，另一个进程就无法访问临界资源，从而实现互斥。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line">input = <span class="number">0</span></span><br><span class="line">out = <span class="number">0</span></span><br><span class="line">buf = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">num = len(buf)</span><br><span class="line">counter  = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">True</span> <span class="comment"># 标记线程结束了</span></span><br><span class="line">threadLock = threading.Lock() <span class="comment">#申请一个线程锁</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threadID, name, delay)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.delay = delay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> buf,input,out,counter</span><br><span class="line">        count =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;<span class="number">10</span>:</span><br><span class="line">            <span class="comment"># 获取锁,用于线程同步</span></span><br><span class="line">            threadLock.acquire()</span><br><span class="line">            print(<span class="string">"开始线程："</span> + self.name)</span><br><span class="line">            <span class="keyword">if</span> counter  == <span class="number">10</span> :</span><br><span class="line">                print(input,out)</span><br><span class="line">                print(<span class="string">"缓冲池已满，无法生产"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buf[input] = random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">                input = (input+<span class="number">1</span>) %num</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"%s生产成功,此时缓冲池的状态为%s"</span> %(self.name,buf))</span><br><span class="line">            <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            threadLock.release()</span><br><span class="line">            time.sleep(self.delay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threadID, name, delay)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.delay = delay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> buf,input,out,counter</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;<span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取锁,用于线程同步</span></span><br><span class="line">            threadLock.acquire()</span><br><span class="line">            print(<span class="string">"开始线程："</span> + self.name)</span><br><span class="line">            <span class="keyword">if</span> counter  == <span class="number">0</span>:</span><br><span class="line">               print(<span class="string">"缓冲池已空，无法消费"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buf[out] = <span class="number">0</span></span><br><span class="line">                out = (out+<span class="number">1</span>) %num</span><br><span class="line">                print(<span class="string">"%s消费成功！此时缓冲池状态为%s"</span> % (self.name,buf))</span><br><span class="line">                counter -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            threadLock.release()</span><br><span class="line">            time.sleep(self.delay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = PThread(<span class="number">1</span>,<span class="string">"生产者-1"</span>,<span class="number">4</span>)  <span class="comment">#第一个参数是编号，第二个是线程名，第三个是该生产者（消费者）生产（消费）一个产品的时间。</span></span><br><span class="line">p2 = PThread(<span class="number">2</span>,<span class="string">"生产者-2"</span>,<span class="number">3</span>)</span><br><span class="line">C1 = CThread(<span class="number">3</span>,<span class="string">"消费者-1"</span>,<span class="number">1</span>)</span><br><span class="line">C2 = CThread(<span class="number">4</span>,<span class="string">"消费者-2"</span>,<span class="number">1</span>)</span><br><span class="line">p1.start()  <span class="comment">#启动线程</span></span><br><span class="line">p2.start()</span><br><span class="line">C1.start()</span><br><span class="line">C2.start()</span><br></pre></td></tr></table></figure>

<h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><p>问题：<br>5个哲学家围坐在一个圆桌上，每两个哲学家之间都有一只筷子，哲学家平时进行思考，只有当他们饥饿时，才拿起筷子吃饭。规定每个哲学家只能先取其左边筷子，然后取其右边筷子，然后才可以吃饭。<br>难点：当五个哲学家同时饥饿时，将同时拿去左手边的筷子，此时就会出现“死锁”问题！</p>
<h2 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a>解决方法一：</h2><p>至多只允许有四位哲学家同时去拿左手边的筷子，最终能够保证至少一位哲学家能够进餐，用毕时释放他用过的两只筷子，从而使得更多的哲学家可以进餐。  </p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"哲学家进餐问题的解法：至多只允许四位哲学家同时进餐"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">ThreadLock = threading.Lock()</span><br><span class="line">chopstick = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]   <span class="comment"># 记录型信号量</span></span><br><span class="line">left_chopstick = [<span class="literal">False</span>] *<span class="number">5</span>  <span class="comment"># 记录哲学家是否拿到左手边的筷子</span></span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># 记录准备进餐人数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ThreadID, time)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.ThreadID = ThreadID</span><br><span class="line">        self.delay = time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">            ThreadLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> self._get_right() == <span class="literal">True</span>:</span><br><span class="line">                chopstick[(self.ThreadID + <span class="number">1</span>)%<span class="number">5</span>] = <span class="number">0</span>  <span class="comment"># 拿走右手边的筷子,开始进餐</span></span><br><span class="line">                print(<span class="string">"哲学家%d开始进餐！"</span>%self.ThreadID)</span><br><span class="line">                ThreadLock.release()  <span class="comment">#释放锁</span></span><br><span class="line">                time.sleep(self.delay)</span><br><span class="line">                chopstick[self.ThreadID] = <span class="number">1</span>        <span class="comment">#放下筷子</span></span><br><span class="line">                chopstick[(self.ThreadID +<span class="number">1</span> ) %<span class="number">5</span> ] = <span class="number">1</span></span><br><span class="line">                left_chopstick[self.ThreadID] = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">"哲学家%d进餐完毕！\n 哲学家%d放下左右手的筷子！！！"</span>%(self.ThreadID,self.ThreadID))</span><br><span class="line">                <span class="comment"># time.sleep(10) # 哲学家思考时间</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ThreadLock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_right</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断哲学家是否可以拿到右手边的筷子"""</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">if</span> chopstick[self.ThreadID] == <span class="number">1</span> :   <span class="comment">#PID哲学家未拿到左手边的筷子</span></span><br><span class="line">                <span class="keyword">if</span> num &lt; <span class="number">4</span>:</span><br><span class="line">                    chopstick[self.ThreadID] = <span class="number">0</span> <span class="comment"># 哲学家左手边的筷子未被拿走</span></span><br><span class="line">                    print(<span class="string">"哲学家%d拿走左手边的筷子"</span>%self.ThreadID)</span><br><span class="line">                    left_chopstick[self.ThreadID] = <span class="literal">True</span> <span class="comment">#记录下哲学家已经拿走了他左手边的筷子</span></span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"第五个哲学家试图拿左手边的筷子！"</span>)</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#哲学家左手边的筷子被拿走了</span></span><br><span class="line">            <span class="keyword">if</span> left_chopstick[self.ThreadID] == <span class="literal">True</span> <span class="keyword">and</span> chopstick[(self.ThreadID + <span class="number">1</span>)% <span class="number">5</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p0 = PThread(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    p1 = PThread(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    p2 = PThread(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    p3 = PThread(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">    p4 = PThread(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">    p0.start()</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p4.start()</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>仅当哲学家左右两只筷子均可用时，才允许他拿起筷子进餐。</p>
<h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""a philosopher Algorithm 本脚本关于哲学家的解法是:仅当哲学家的左右筷子皆可用时，才允许他拿起筷子进餐。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">__author__ = <span class="string">'黄建国'</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">chopstick = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]  <span class="comment"># 筷子的记录型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take_leftchopstick</span><span class="params">(philosopher,chopstick)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> chopstick[philosopher] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take_rightchopstick</span><span class="params">(philosopher,chopstick)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> chopstick[(philosopher+<span class="number">1</span>)%<span class="number">5</span>] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ThreadID,time)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.TreadID = ThreadID</span><br><span class="line">        self.delay = time  <span class="comment">#哲学家进餐时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">            threadLock.acquire() <span class="comment"># 获取锁</span></span><br><span class="line">            <span class="comment">#print("哲学家%d准备进餐!"%self.TreadID)</span></span><br><span class="line">            left = take_leftchopstick(self.TreadID,chopstick)</span><br><span class="line">            right = take_rightchopstick(self.TreadID,chopstick)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">                print(chopstick)</span><br><span class="line">                chopstick[self.TreadID] = <span class="number">0</span></span><br><span class="line">                chopstick[(self.TreadID+<span class="number">1</span>)%<span class="number">5</span>] = <span class="number">0</span></span><br><span class="line">                print(<span class="string">"哲学家%d可以进餐！"</span>%self.TreadID)</span><br><span class="line">                threadLock.release()  <span class="comment"># 开锁</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                time.sleep(self.delay)  <span class="comment"># 哲学家进餐时间</span></span><br><span class="line">                chopstick[self.TreadID] = <span class="number">1</span>  <span class="comment"># 哲学家进餐完毕，放下筷子</span></span><br><span class="line">                chopstick[(self.TreadID+<span class="number">1</span>) % <span class="number">5</span>] = <span class="number">1</span></span><br><span class="line">                print(<span class="string">"哲学家%d进餐完毕！"</span> % self.TreadID)</span><br><span class="line">                print(chopstick)</span><br><span class="line">                time.sleep(<span class="number">10</span>)  <span class="comment"># 思考时间,时间过后才会尝试继续进餐</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#print("哲学家%d无法进餐！"%self.TreadID)</span></span><br><span class="line">                threadLock.release()  <span class="comment"># 开锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span> :</span><br><span class="line">    print(chopstick)</span><br><span class="line">    p0 = PThread(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    p1 = PThread(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    p2 = PThread(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    p3 = PThread(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    p4 = PThread(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"线程创建完成"</span>)</span><br><span class="line">    p0.start()</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p4.start()</span><br></pre></td></tr></table></figure>

<h1 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h1><p>安全状态:<br>如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。<br>不安全状态:<br>不存在一个安全序列。不安全状态不一定导致死锁。<br>数据结构:<br>-1）可利用资源向量Available<br>是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。<br>2）最大需求矩阵Max<br>这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。<br>3）分配矩阵Allocation<br>这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。<br>4）需求矩阵Need。<br>这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由用户输入数据，分别对可利用资源向量矩阵AVAILABLE、最大需求矩阵MAX、分配矩阵ALLOCATION、需求矩阵NEED赋值。<br>银行家在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。<br>银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>设进程cusneed提出请求REQUEST [i]，则银行家算法按如下规则进行判断。<br>(1)如果REQUEST [cusneed] [i]&lt;= NEED[cusneed][i]，则转（2)；否则，出错。<br>(2)如果REQUEST [cusneed] [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。<br>(3)系统试探分配资源，修改相关数据：<br>AVAILABLE[i]-=REQUEST[cusneed][i];<br>ALLOCATION[cusneed][i]+=REQUEST[cusneed][i];<br>NEED[cusneed][i]-=REQUEST[cusneed][i];<br>(4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</p>
<h3 id="安全性检查算法"><a href="#安全性检查算法" class="headerlink" title="安全性检查算法"></a>安全性检查算法</h3><p>1)设置两个工作向量Work=AVAILABLE;FINISH<br>(2)从进程集合中找到一个满足下述条件的进程，<br>FINISH==false;<br>NEED&lt;=Work;<br>如找到，执行（3)；否则，执行（4)<br>(3)设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>Work=Work+ALLOCATION;<br>Finish=true;<br>GOTO 2<br>(4)如所有的进程Finish= true，则表示安全；否则系统不安全。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""银行家算法"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">security_algorithm</span><span class="params">(work,Need,Allocation)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对已分配的资源情况进行安全检查。</span></span><br><span class="line"><span class="string">    :param work: 可分配资源矩阵</span></span><br><span class="line"><span class="string">    :param Need: 需求资源矩阵</span></span><br><span class="line"><span class="string">    :param Allocation: 已分配资源矩阵</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = len(work)  <span class="comment"># 资源数</span></span><br><span class="line">    n = len(Need)  <span class="comment"># 进程数</span></span><br><span class="line">    Finish = [ <span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n) ]  <span class="comment"># 存储安全序列的安全情况</span></span><br><span class="line">    result = []  <span class="comment"># 存储一个安全序列</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; n*m:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 逐个线程检查是否可行</span></span><br><span class="line">            <span class="keyword">if</span> Finish[i] == <span class="literal">False</span>:  <span class="comment">#判断该进程是否已经完成</span></span><br><span class="line">                <span class="keyword">if</span> (Need[i]  &lt;= work).all():  <span class="comment"># 判断可分配资源矩阵是否小于该线程的需求资源矩阵，如果是，则进程分配，并释放该进程所有资源</span></span><br><span class="line">                    Finish[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                        work[j] = work[j] + Allocation[i][j]  <span class="comment"># 第i个进程的第j类资源被释放</span></span><br><span class="line">                        result += ((<span class="keyword">lambda</span> nums,i:[i] <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums <span class="keyword">else</span> [])(result,i))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    print(result)</span><br><span class="line">    print(Finish)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">lambda</span> Finish : <span class="literal">False</span> <span class="keyword">if</span> <span class="literal">False</span> <span class="keyword">in</span>  Finish <span class="keyword">else</span> <span class="literal">True</span>)(Finish)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contibute_resource</span><span class="params">(id,request,Available,Need,Allocation)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    该函数对资源欲分配方式进行安全性检查</span></span><br><span class="line"><span class="string">    :param id: 进程号</span></span><br><span class="line"><span class="string">    :param request:  欲分配资源矩阵</span></span><br><span class="line"><span class="string">    :param Available: 可使用资源向量</span></span><br><span class="line"><span class="string">    :param Need: 需求资源矩阵</span></span><br><span class="line"><span class="string">    :param Allocation: 已分配矩阵</span></span><br><span class="line"><span class="string">    :return: 该分配方式是否安全</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    Need_ = Need.copy()</span><br><span class="line">    Allocation_ = Allocation.copy()</span><br><span class="line">    <span class="keyword">if</span> (request &lt;= Need[id]).all() <span class="keyword">and</span> (request &lt;= Available).all(): <span class="comment"># 检测请求向量小于等于所需向量且小于等于可分配向量。</span></span><br><span class="line">        Available_ = Available - request</span><br><span class="line">        Need_[id] = Need_[id] - request</span><br><span class="line">        Allocation_[id] = Allocation_[id] + request</span><br><span class="line">        <span class="keyword">if</span> security_algorithm(Available_,Need_,Allocation_):  <span class="comment">#进行安全性检查</span></span><br><span class="line">            Need[id] = Need[id] - request</span><br><span class="line">            Allocation[id] = Allocation[id] + request</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>,Available-request,Need,Allocation</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>,Available,Need,Allocation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准备工作</span></span><br><span class="line">    Available = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>])  <span class="comment"># 可利用资源向量</span></span><br><span class="line">    Max = np.array([[<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>],  <span class="comment"># 第i个进程所需的m类最大资源</span></span><br><span class="line">                    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                    [<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                    [<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">    Allocation = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],  <span class="comment"># 已经分配的资源</span></span><br><span class="line">                           [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                           [<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                           [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">    Need = Max - Allocation  <span class="comment"># 所需的资源数量</span></span><br><span class="line">    security_algorithm(Available.copy(),Need.copy(),Allocation.copy())  <span class="comment">#先检查初始时刻的资源分配安全性。</span></span><br><span class="line">    <span class="keyword">while</span>  np.sum(Need) != <span class="number">0</span> :</span><br><span class="line">        id_course = input(<span class="string">"输入进程号:"</span>)  <span class="comment"># 获取进程id</span></span><br><span class="line">        id_course = int(id_course)</span><br><span class="line">        input_resource = input(<span class="string">"给该进程多少资源:"</span>)  <span class="comment"># 给该进程分配多少资源</span></span><br><span class="line">        input_resource = input_resource[<span class="number">1</span>:<span class="number">-1</span>]  <span class="comment"># 从字符串中提取出资源数</span></span><br><span class="line">        input_resource = [int(n) <span class="keyword">for</span> n <span class="keyword">in</span> input_resource.split(<span class="string">","</span>)]</span><br><span class="line">        input_resource = np.array(input_resource)</span><br><span class="line">        status, Available,Need,Allocation = contibute_resource(id_course,input_resource,Available,Need,Allocation)</span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            print(<span class="string">"分配成功"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"分配不成功，该线程等待！"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Operating system</category>
      </categories>
  </entry>
  <entry>
    <title>else and with</title>
    <url>/jontyhuang.github.io/2019/10/27/else-and-with/</url>
    <content><![CDATA[<h1 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h1><p>在 while … else 在条件语句为 false 时执行 else 的语句块。</p>
<p>实行break时不执行。</p>
<p>语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>循环输出数字，并判断大小：</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">   print (count, &quot; 小于 5&quot;)</span><br><span class="line">   count = count + 1</span><br><span class="line">else:</span><br><span class="line">   print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">1</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  大于或等于 <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="for-循坏使用else-语句"><a href="#for-循坏使用else-语句" class="headerlink" title="for 循坏使用else 语句"></a>for 循坏使用else 语句</h1><p>当for语句不执行或者执行完for语句时执行else语句。如果是break出for语句则else语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"无数据"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><p>with 语句的语法格式如下：</p>
<p>清单 1. with 语句的语法格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>with语句，不管在处理文件过程中是否发生异常，with语句在执行完毕之后都会自动自动关闭文件的句柄.</p>
<p>使用with语句去操作文件对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>使用try/finall语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>with语句执行过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="literal">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>) </span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <strong>enter</strong>() 方法；如果使用了 as 子句，则将 <strong>enter</strong>() 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <strong>exit</strong>() 方法，<strong>exit</strong>() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <strong>exit</strong>(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <strong>exit</strong>(exc_type, exc_value, exc_traceback),并返回True。</li>
<li>出现异常时，如果 <strong>exit</strong>(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ul>
<h1 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h1><p>开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 <strong>enter</strong>() 和 <strong>exit</strong>() 两个方法：</p>
<ul>
<li>context_manager.<strong>enter</strong>() ：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话</li>
<li>context_manager.<strong>exit</strong>(exc_type, exc_value, exc_traceback) ：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否 <strong>exit</strong>() 失败来处理异常</li>
</ul>
<p>下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供 <strong>enter</strong>() 和 <strong>exit</strong>() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 <strong>exit</strong>() 方法，然后检查是否定义了 <strong>enter</strong>() 方法。</p>
<p>假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到 <strong>enter</strong>() 方法中，释放操作可以放到 <strong>exit</strong>() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">自定义支持 <span class="keyword">with</span> 语句的对象</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyResource</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        self.tag = tag</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Resource [%s]'</span> % tag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[Enter %s]: Allocate resource.'</span> % self.tag</span><br><span class="line">        <span class="keyword">return</span> self   <span class="comment"># 可以返回不同的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[Exit %s]: Free resource.'</span> % self.tag</span><br><span class="line">        <span class="keyword">if</span> exc_tb <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited without exception.'</span> % self.tag</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited with exception raised.'</span> % self.tag</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>   <span class="comment"># 可以省略，缺省的None也是被看做是False</span></span><br></pre></td></tr></table></figure>
<p>DummyResource 中的 <strong>enter</strong>() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。</p>
<p><strong>exit</strong>() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，<strong>exit</strong>() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。</p>
<p>下面在 with 语句中访问 DummyResource ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用自定义的支持 <span class="keyword">with</span> 语句的对象</span><br><span class="line"><span class="keyword">with</span> DummyResource(<span class="string">'Normal'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run without exceptions.'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> DummyResource(<span class="string">'With-Exception'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run with exception.'</span></span><br><span class="line">    <span class="keyword">raise</span> Exception</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run with exception. Failed to finish statement-body!'</span></span><br></pre></td></tr></table></figure>
<p>第1个 with 语句的执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Resource [Normal]</span><br><span class="line">[Enter Normal]: Allocate resource.</span><br><span class="line">[<span class="keyword">with</span>-body] Run without exceptions.</span><br><span class="line">[Exit Normal]: Free resource.</span><br><span class="line">[Exit Normal]: Exited without exception.</span><br><span class="line">可以看到，正常执行时会先执行完语句体 <span class="keyword">with</span>-body，然后执行 __exit__() 方法释放资源。</span><br></pre></td></tr></table></figure>
<p>第2个 with 语句的执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Resource [With-Exception]</span><br><span class="line">[Enter With-Exception]: Allocate resource.</span><br><span class="line">[<span class="keyword">with</span>-body] Run <span class="keyword">with</span> exception.</span><br><span class="line">[Exit With-Exception]: Free resource.</span><br><span class="line">[Exit With-Exception]: Exited <span class="keyword">with</span> exception raised.</span><br><span class="line"> </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"G:/demo"</span>, line <span class="number">20</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">   <span class="keyword">raise</span> Exception</span><br><span class="line">Exception</span><br></pre></td></tr></table></figure>
<p>可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。</p>
<p>可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。</p>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
  <entry>
    <title>moudel</title>
    <url>/jontyhuang.github.io/2019/10/27/moudel/</url>
    <content><![CDATA[<p>如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<p>面是一个使用 python 标准库中模块的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#-*- coding: uft-8 -*-</span></span><br><span class="line"><span class="comment"># 文件名: using_sys.py</span></span><br><span class="line"><span class="string">' a test module'</span> </span><br><span class="line">__author__ = <span class="string">'jontyhuang'</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'命令行参数如下:'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   print(i)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'\n\nPython 路径为：'</span>, sys.path, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027185153.png" alt=""></p>
<ul>
<li>1、import sys 引入 python 标准库中的 sys.py 模块；导入sys模块之后，我们就有变量sys指向该模块，就可以访问该模块的所有功能，这是引入某一模块的方法。</li>
<li>2、sys.argv 是一个包含命令行参数的列表。argv至少有一个参数，因为第一个参数永远是该.py文件。</li>
<li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li>
</ul>
<p>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p>
<p>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p>
<p>第6行使用<strong>author</strong>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；</p>
<p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。之后才是真正的代码部分。</p>
<h1 id="import-模块名"><a href="#import-模块名" class="headerlink" title="import 模块名"></a>import 模块名</h1><p>新建一个fibo.py文件，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>,<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        print(b, end=<span class="string">''</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    pint()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span></span><br><span class="line">    result =[]</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>
<p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例</span><br><span class="line">&gt;&gt;&gt;fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">'fibo'</span></span><br></pre></td></tr></table></figure>

<p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<h1 id="from-模块名-import-函数名"><a href="#from-模块名-import-函数名" class="headerlink" title="from 模块名 import 函数名"></a>from 模块名 import 函数名</h1><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<p>from modname import name1[, name2[, … nameN]]<br>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。<br>为了避免名字的不方便，我们也可以使用简写</p>
<p><strong>import 模块名 as 简写名</strong></p>
<h1 id="from…-import-语句"><a href="#from…-import-语句" class="headerlink" title="from… import * 语句"></a>from… import * 语句</h1><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<h1 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h1><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>接着上面所说的为什么下划线(_)开头的名字不在此列呢？<br>这里涉及到一个变量的作用域</p>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，这个private作用是通过_前缀来实现的。</p>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p>
<p>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<strong>author</strong>，<strong>name</strong>就是特殊变量，using_sys模块定义的文档注释也可以用特殊变量<strong>doc</strong>访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似_xxx和<strong>xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，</strong>abc等；</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi, %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(name) &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> _private_1(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _private_2(name)</span><br></pre></td></tr></table></figure>
<p>我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
<h1 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h1><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<strong>name</strong>属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   print(<span class="string">'程序自身在运行'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我来自另一模块'</span>)</span><br></pre></td></tr></table></figure>
<p>运行输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name</span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>说明： 每个模块都有一个<strong>name</strong>属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p>
<p>说明：<strong>name</strong> 与 <strong>main</strong> 底下是双下划线， _ _ 是这样去掉中间的那个空格。</p>
<h1 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h1><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fibo)</span><br><span class="line">[<span class="string">'__name__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  </span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</span><br><span class="line"> <span class="string">'__package__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>,</span><br><span class="line"> <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>,</span><br><span class="line"> <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</span><br><span class="line"> <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>,</span><br><span class="line"> <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>,</span><br><span class="line"> <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>,</span><br><span class="line"> <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>,</span><br><span class="line"> <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>,</span><br><span class="line"> <span class="string">'getfilesystemencoding'</span>, <span class="string">'getobjects'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettotalrefcount'</span>,</span><br><span class="line"> <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>,</span><br><span class="line"> <span class="string">'intern'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>,</span><br><span class="line"> <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>,</span><br><span class="line"> <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</span><br><span class="line"> <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br></pre></td></tr></table></figure>
<p>如果没有给定参数，那么 dir() 函数会罗列出当前模块定义的所有名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir() <span class="comment"># 得到一个当前模块中定义的属性列表</span></span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'fib'</span>, <span class="string">'fibo'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span> <span class="comment"># 建立一个新的变量 'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a <span class="comment"># 删除变量名a</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sound/                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） <strong>all</strong>变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>
<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure>
<p>还有一种导入子模块的方法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo.echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种变化就是直接导入一个函数或者变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>
<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。</p>
<p>反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<h1 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h1><p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p>
<p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。</p>
<p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p>
<p>导入语句遵循如下规则：如果包定义文件 <strong>init</strong>.py 存在一个叫做 <strong>all</strong> 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 <strong>all</strong> 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/<strong>init</strong>.py中包含如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"echo"</span>, <span class="string">"surround"</span>, <span class="string">"reverse"</span>]</span><br></pre></td></tr></table></figure>
<p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong>all</strong> 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行<strong>init</strong>.py里定义的初始化代码）。</p>
<p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这个例子中，在执行 from…import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 <strong>all</strong> 就更没问题了）</p>
<p>通常我们并不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用 from Package import specific_submodule 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure>
<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性<strong>path</strong>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，你得在其他<strong>init</strong>.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
  <entry>
    <title>iterator and generator</title>
    <url>/jontyhuang.github.io/2019/10/27/iterator-and-generator/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>迭代器有两个基本的方法：iter() 和 next()。<br>字符串，列表或元组对象都可用于创建迭代器。<br>迭代器可以也可以使用常规for语句进行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例(Python <span class="number">3.0</span>+)</span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br><span class="line">执行以上程序，输出结果如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 next() 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例(Python <span class="number">3.0</span>+)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(it))</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(it))</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(it))  <span class="comment">#迭代器无对象，报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027160141.png" alt=""></p>
<h1 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h1><p>把一个类作为一个迭代器使用需要在类中实现两个方法 _<em>iter_</em>() 与 _<em>next_</em>() 。</p>
<p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 _<em>init_</em>(), 它会在对象初始化的时候执行。</p>
<p>_<em>iter_</em>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027161624.png" alt=""><br>if 语句是用来限制迭代次数，否则会不停的迭代下去。</p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下实例使用 yield 实现斐波那契数列：</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">def fibonacci(n): # 生成器函数 - 斐波那契</span><br><span class="line">    a, b, counter = 0, 1, 0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n): </span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += 1</span><br><span class="line">f = fibonacci(10) # f 是一个迭代器，由生成器返回生成</span><br><span class="line"> </span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (next(f), end=&quot; &quot;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line">执行以上程序，输出结果如下：</span><br><span class="line"></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<p><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027195325.png" alt=""></p>
<h2 id="for-创建生成器"><a href="#for-创建生成器" class="headerlink" title="for 创建生成器"></a>for 创建生成器</h2><p>列表<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027195402.png" alt=""><br>字典<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027195423.png" alt=""><br>元组<br><img src="https://raw.githubusercontent.com/jontyhuang/PicGo/master/20191027195441.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> <span class="keyword">not</span>(i % <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
  <entry>
    <title>list and tuple</title>
    <url>/jontyhuang.github.io/2019/10/27/list%20and%20tuple/</url>
    <content><![CDATA[<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
<h1 id="内嵌函数的运行"><a href="#内嵌函数的运行" class="headerlink" title="内嵌函数的运行"></a>内嵌函数的运行</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'bar() called'</span>)</span><br><span class="line">	<span class="keyword">print</span> (<span class="string">'foo() called'</span>)</span><br><span class="line">	<span class="keyword">return</span> bar()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;foo()</span><br><span class="line">foo() called</span><br><span class="line">bar() called</span><br></pre></td></tr></table></figure>
<p>我们可以发现，先执行的是外函数，再执行的内嵌函数</p>
<h1 id="无参数的装饰器"><a href="#无参数的装饰器" class="headerlink" title="无参数的装饰器"></a>无参数的装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br><span class="line">say(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<p>这个执行过程如果用无装饰器的代码理解，如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br><span class="line">say = debug(say)  <span class="comment"># 实际上@debug完成的就是这是操作。</span></span><br><span class="line">say(<span class="string">"hell0"</span>)</span><br></pre></td></tr></table></figure>
<p>如何理解上述执行的过程：<br>@debug的作用可以理解为say = debug(say)<br><strong>同时我们明白理解装饰函数在被装饰函数定义好后立即执行say = debug(say)的操作。</strong><br>整个装饰器实现过程如下：<br><strong>在@debug定义完之后就执行say = debug(say)的操作，由于debug函数存在返回值，那么say就指向了wrapper，接下来的say(“hello”)实际是wrapper(“hello”)函数。</strong>最后返回func函数即say函数 ，最后执行say函数 。其实前面加粗的部分是装饰器所实现的功能，很明显这部分实现的功能和say()定义函数里的代码毫无关系。</p>
<p>进一步理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"this is debug"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><figcaption><span>is debug```</span></figcaption><table><tr><td class="code"><pre><span class="line">在上面的程序中，我们没有运行函数，但是debug函数却执行了，也就是执行了say= debug(say)这个操作。那么之后say的调用就是调用装饰器内部函数的过程。</span><br><span class="line"></span><br><span class="line"># 带参数的装饰器</span><br><span class="line">有时候，需要装饰器有参数，比如设计一个计时程序，用来测试网络训练和测试的时间，此时需要指定当前执行的是训练或测试过程，为此，需要传入一个状态参数。此处说明一下装饰器传参的方式：@debug(args1,args2)等价于func=debug(args1,args2)(func)，值得说明的是此处所谓的参数是指装饰器的参数而不是被装饰函数的参数，被装饰函数的参数是通过*args和**kwargs自然地传递的。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def debug(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&quot;[&#123;&#125;] call &#123;&#125; &quot;.format(text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@debug(&quot;train&quot;)</span><br><span class="line">def training():</span><br><span class="line">    print(&quot;traing&quot;)</span><br><span class="line">@debug(&quot;testing&quot;)</span><br><span class="line">def testing():</span><br><span class="line">    print(&quot;testing&quot;)</span><br><span class="line"></span><br><span class="line">training()</span><br><span class="line">testing()</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[train] call training </span><br><span class="line">traing</span><br><span class="line">[testing] call testing </span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
<p>整个执行过程的理解：<br>在定义@debug(“train”)完成之后，立即执行了training = debug(“train”)(training)这个语句，这个句子可以分开理解<code>next = debug(&quot;train&quot;), training = next(training)</code>其中debug(“train”)语句执行debug函数，返回decorator函数，接着执行decorator(training)这个函数，最后就得到了wrapper这个函数，那么其实此时执行的traning()其实就是wrapper()这个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timing</span><span class="params">(status=<span class="string">"Train"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"this is timing"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'this is debug in timing'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func1 = func(*args, **kw)</span><br><span class="line">            print(<span class="string">'[%s] time: %.3f s'</span>%(status, time.time()-start))</span><br><span class="line">            <span class="keyword">return</span> func1</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> debug</span><br><span class="line"><span class="meta">@timing()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Training</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">Training()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug <span class="keyword">in</span> timing</span><br><span class="line">[Train] time: <span class="number">3.000</span> s</span><br></pre></td></tr></table></figure>
<p>对上述过程分步描述：<br>首先说明，@timing()在此处等价于Training=timing(‘Train’)(Training)</p>
<ul>
<li>第一步，打印第一句话，然后Training=timing(‘Train’)(Training)=debug(Training)。</li>
<li>第二步，打印第二句话，且debug(Training)返回wrapper，即Training=wrapper。（到这一步都只是定义Testing所产生的操作，即即使不调用该函数，上两句话也会被打印）</li>
<li>调用wrapper函数，记下起始时间start，执行Testing函数，延时2秒，打印所用时间，返回func1。<br>值得说明的是，这里返回的func1是None，因为这个返回值实际是Testing函数的返回值，而这个函数我并没有定义返回值。</li>
</ul>
<h1 id="多装饰器"><a href="#多装饰器" class="headerlink" title="多装饰器"></a>多装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@debug1(args)</span></span><br><span class="line"><span class="meta">@debug2</span></span><br><span class="line"><span class="meta">@debug3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这等价于:func = debug1(args)(debug2(debug3(func)))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timing</span><span class="params">(status=<span class="string">'Train'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'this is timing'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'this is debug in timing'</span>)</span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper3</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func1 = func(*args,**kwargs)</span><br><span class="line">            print(<span class="string">'[%s] time: %.3f s '</span>%(status,time.time()-start))</span><br><span class="line">            <span class="keyword">return</span> func1</span><br><span class="line">        <span class="keyword">return</span> wrapper3</span><br><span class="line">    <span class="keyword">return</span> debug</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'this is debug1'</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'this is a wrapper in debug1'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'this is debug2'</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'this is a wrapper in debug2'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line">    </span><br><span class="line"><span class="meta">@debug1</span></span><br><span class="line"><span class="meta">@debug2</span></span><br><span class="line"><span class="meta">@timing(status='Test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug <span class="keyword">in</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug2</span><br><span class="line">this <span class="keyword">is</span> debug1</span><br><span class="line">this <span class="keyword">is</span> a wrapper <span class="keyword">in</span> debug1</span><br><span class="line">this <span class="keyword">is</span> a wrapper <span class="keyword">in</span> debug2</span><br><span class="line">[Test] time: <span class="number">2.001</span> s</span><br></pre></td></tr></table></figure>
<p>程序在定义完成后，执行fun = debug1(debug2(timing(‘Test’)(fun)))语句，我们可以得到，wrapper3作用域的func = fun,wrapper2作用域的func = wrapper3，wrapper1作用域的func=wrapper2，最后fun = wrapper1。<br>这个可以从里往外进行逻辑推理。<br>观察结果，类似于自底向上完成装饰器的定义，自顶向下完成装饰器的功能。</p>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
  <entry>
    <title>decorator</title>
    <url>/jontyhuang.github.io/2019/10/26/decorator/</url>
    <content><![CDATA[<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
<h1 id="内嵌函数的运行"><a href="#内嵌函数的运行" class="headerlink" title="内嵌函数的运行"></a>内嵌函数的运行</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'bar() called'</span>)</span><br><span class="line">	<span class="keyword">print</span> (<span class="string">'foo() called'</span>)</span><br><span class="line">	<span class="keyword">return</span> bar()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;foo()</span><br><span class="line">foo() called</span><br><span class="line">bar() called</span><br></pre></td></tr></table></figure>
<p>我们可以发现，先执行的是外函数，再执行的内嵌函数</p>
<h1 id="无参数的装饰器"><a href="#无参数的装饰器" class="headerlink" title="无参数的装饰器"></a>无参数的装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br><span class="line">say(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<p>这个执行过程如果用无装饰器的代码理解，如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br><span class="line">say = debug(say)  <span class="comment"># 实际上@debug完成的就是这是操作。</span></span><br><span class="line">say(<span class="string">"hell0"</span>)</span><br></pre></td></tr></table></figure>
<p>如何理解上述执行的过程：<br>@debug的作用可以理解为say = debug(say)<br><strong>同时我们明白理解装饰函数在被装饰函数定义好后立即执行say = debug(say)的操作。</strong></p>
<p>整个装饰器实现过程如下：<br><strong>在@debug定义完之后就执行say = debug(say)的操作，由于debug函数存在返回值，那么say就指向了wrapper，接下来的say(“hello”)实际是wrapper(“hello”)函数。</strong>最后返回func函数即say函数 ，最后执行say函数 。其实前面加粗的部分是装饰器所实现的功能，很明显这部分实现的功能和say()定义函数里的代码毫无关系。</p>
<p>进一步理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"this is debug"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定参数</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__))</span><br><span class="line">        print(<span class="string">'Prepare and say...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello &#123;&#125;!"</span>.format(something))</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><figcaption><span>is debug```</span></figcaption><table><tr><td class="code"><pre><span class="line">在上面的程序中，我们没有运行函数，但是debug函数却执行了，也就是执行了say= debug(say)这个操作。那么之后say的调用就是调用装饰器内部函数的过程。</span><br><span class="line"></span><br><span class="line"># 带参数的装饰器</span><br><span class="line">有时候，需要装饰器有参数，比如设计一个计时程序，用来测试网络训练和测试的时间，此时需要指定当前执行的是训练或测试过程，为此，需要传入一个状态参数。此处说明一下装饰器传参的方式：@debug(args1,args2)等价于func=debug(args1,args2)(func)，值得说明的是此处所谓的参数是指装饰器的参数而不是被装饰函数的参数，被装饰函数的参数是通过*args和**kwargs自然地传递的。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def debug(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&quot;[&#123;&#125;] call &#123;&#125; &quot;.format(text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@debug(&quot;train&quot;)</span><br><span class="line">def training():</span><br><span class="line">    print(&quot;traing&quot;)</span><br><span class="line">@debug(&quot;testing&quot;)</span><br><span class="line">def testing():</span><br><span class="line">    print(&quot;testing&quot;)</span><br><span class="line"></span><br><span class="line">training()</span><br><span class="line">testing()</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[train] call training </span><br><span class="line">traing</span><br><span class="line">[testing] call testing </span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
<p>整个执行过程的理解：<br>在定义@debug(“train”)完成之后，立即执行了training = debug(“train”)(training)这个语句，这个句子可以分开理解<code>next = debug(&quot;train&quot;), training = next(training)</code>其中debug(“train”)语句执行debug函数，返回decorator函数，接着执行decorator(training)这个函数，最后就得到了wrapper这个函数，那么其实此时执行的traning()其实就是wrapper()这个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timing</span><span class="params">(status=<span class="string">"Train"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"this is timing"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'this is debug in timing'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func1 = func(*args, **kw)</span><br><span class="line">            print(<span class="string">'[%s] time: %.3f s'</span>%(status, time.time()-start))</span><br><span class="line">            <span class="keyword">return</span> func1</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> debug</span><br><span class="line"><span class="meta">@timing()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Training</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">Training()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug <span class="keyword">in</span> timing</span><br><span class="line">[Train] time: <span class="number">3.000</span> s</span><br></pre></td></tr></table></figure>
<p>对上述过程分步描述：<br>首先说明，@timing()在此处等价于Training=timing(‘Train’)(Training)</p>
<ul>
<li>第一步，打印第一句话，然后Training=timing(‘Train’)(Training)=debug(Training)。</li>
<li>第二步，打印第二句话，且debug(Training)返回wrapper，即Training=wrapper。（到这一步都只是定义Testing所产生的操作，即即使不调用该函数，上两句话也会被打印）</li>
<li>调用wrapper函数，记下起始时间start，执行Testing函数，延时2秒，打印所用时间，返回func1。</li>
</ul>
<p>值得说明的是，这里返回的func1是None，因为这个返回值实际是Testing函数的返回值，而这个函数我并没有定义返回值。</p>
<h1 id="多装饰器"><a href="#多装饰器" class="headerlink" title="多装饰器"></a>多装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@debug1(args)</span></span><br><span class="line"><span class="meta">@debug2</span></span><br><span class="line"><span class="meta">@debug3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这等价于:func = debug1(args)(debug2(debug3(func)))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timing</span><span class="params">(status=<span class="string">'Train'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'this is timing'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'this is debug in timing'</span>)</span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper3</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            func1 = func(*args,**kwargs)</span><br><span class="line">            print(<span class="string">'[%s] time: %.3f s '</span>%(status,time.time()-start))</span><br><span class="line">            <span class="keyword">return</span> func1</span><br><span class="line">        <span class="keyword">return</span> wrapper3</span><br><span class="line">    <span class="keyword">return</span> debug</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'this is debug1'</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'this is a wrapper in debug1'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'this is debug2'</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'this is a wrapper in debug2'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line">    </span><br><span class="line"><span class="meta">@debug1</span></span><br><span class="line"><span class="meta">@debug2</span></span><br><span class="line"><span class="meta">@timing(status='Test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug <span class="keyword">in</span> timing</span><br><span class="line">this <span class="keyword">is</span> debug2</span><br><span class="line">this <span class="keyword">is</span> debug1</span><br><span class="line">this <span class="keyword">is</span> a wrapper <span class="keyword">in</span> debug1</span><br><span class="line">this <span class="keyword">is</span> a wrapper <span class="keyword">in</span> debug2</span><br><span class="line">[Test] time: <span class="number">2.001</span> s</span><br></pre></td></tr></table></figure>
<p>程序在定义完成后，执行fun = debug1(debug2(timing(‘Test’)(fun)))语句，我们可以得到，wrapper3作用域的func = fun,wrapper2作用域的func = wrapper3，wrapper1作用域的func=wrapper2，最后fun = wrapper1。</p>
<p>这个可以从里往外进行逻辑推理。</p>
<p>观察结果，类似于自底向上完成装饰器的定义，自顶向下完成装饰器的功能。</p>
]]></content>
      <categories>
        <category>basic learning of Python</category>
      </categories>
  </entry>
</search>
